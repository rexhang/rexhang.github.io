<<<<<<< HEAD
{"meta":{"title":"Rexhang的Blog","subtitle":"blog","description":"RexHang","author":"RexHang","url":"https://blog.rexhang.com","root":"/"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2022-11-23T16:49:22.678Z","updated":"2022-10-25T14:41:49.320Z","comments":false,"path":"/404.html","permalink":"https://blog.rexhang.com/404.html","excerpt":"","text":""},{"title":"关于","date":"2021-01-04T09:06:55.000Z","updated":"2022-10-25T14:41:49.325Z","comments":false,"path":"about/index.html","permalink":"https://blog.rexhang.com/about/index.html","excerpt":"","text":"Rexhang全身心致力于Web前端开发以及Nodejs、java等编程技术的研究包括javascript脚本，Jquery，Bootstrap，react，vue，angular等前端框架的研究，并不断完善自我争取更促进互联网与现实世界的更和谐并到更贴近的交互体验！"},{"title":"分类","date":"2022-11-23T16:49:22.678Z","updated":"2022-10-25T14:41:49.325Z","comments":false,"path":"categories/index.html","permalink":"https://blog.rexhang.com/categories/index.html","excerpt":"","text":""},{"title":"书单","date":"2022-11-23T16:49:22.678Z","updated":"2022-10-25T14:41:49.325Z","comments":false,"path":"books/index.html","permalink":"https://blog.rexhang.com/books/index.html","excerpt":"","text":""},{"title":"标签","date":"2022-11-23T16:49:22.678Z","updated":"2022-10-25T14:41:49.326Z","comments":false,"path":"tags/index.html","permalink":"https://blog.rexhang.com/tags/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2022-11-23T16:49:22.678Z","updated":"2022-10-25T14:41:49.325Z","comments":false,"path":"links/index.html","permalink":"https://blog.rexhang.com/links/index.html","excerpt":"","text":""},{"title":"项目","date":"2022-11-23T16:49:22.678Z","updated":"2022-10-25T14:41:49.326Z","comments":false,"path":"repository/index.html","permalink":"https://blog.rexhang.com/repository/index.html","excerpt":"","text":""}],"posts":[{"title":"如何编写web前端开发岗简历","slug":"如何编写web前端开发岗简历","date":"2022-12-15T04:10:01.000Z","updated":"2022-12-15T02:44:40.334Z","comments":true,"path":"2022/12/15/articles/2/","link":"","permalink":"https://blog.rexhang.com/2022/12/15/articles/2/","excerpt":"","text":"如何编写web前端开发岗简历 编写简历时，首先要包括你的个人信息，包括姓名、联系方式、电子邮箱和地址。接下来，你可以简要介绍你的教育背景和工作经验。 在简历中提及你对 Web 前端开发的经验。你可以提到你掌握的主要技术，例如 HTML、CSS 和 JavaScript，并列出你的项目经验。此外，你还可以提到你对用户体验和交互设计的兴趣和经验。 另外，你可以在简历中提到你的专业技能和特长，例如掌握的其他编程语言和框架，或者对数据分析和可视化的经验。这些内容可以帮助雇主了解你的能力，并决定是否与你进一步沟通。 最后，你可以在简历中列出你的证书和荣誉，以及参加过的培训和活动。这些内容有助于雇主了解你的专业知识和技能水平，并评估你是否符合他们的招聘标准。 总之，在编写简历时，要注意清晰、简洁、准确地展示你的个人信息和专业技能，以便雇主能够快速了解你，并决定是否与你进一步沟通 个人信息，包括姓名、电话号码、电子邮件地址和社交媒体链接。 教育经历，包括毕业院校、学位和专业。 工作经历，包括公司名称、职位名称和工作描述。 技能清单，包括掌握的语言、框架和工具。 项目经验，包括项目名称、描述和贡献。 证书或其他资格证明。 编写简历时，要尽量详细且简洁，将你的能力和经验介绍给招聘方。为了让你的简历更加出色，还可以添加下列内容： 个人简介，包括你的专业方向、兴趣爱好和个人特点。 其他语言能力，如果你会一种或多种外语，可以在简历中提及。 兴趣爱好或个人项目，如果你有一些有趣的兴趣爱好或个人项目，可以在简历中提及。 总之，编写简历时要注意交代清楚你的能力和经验，并以简洁易读的方式展现出来。 编写一份web前端开发岗简历，首先应该包含您的个人信息，包括姓名、联系方式和电子邮件地址。接下来，应该概述您的专业技能和工作经验，并突出您在web前端开发方面的专业知识和经验。 在描述您的专业技能时，应该清楚地说明您掌握的技术和工具，例如HTML、CSS、JavaScript、jQuery、Bootstrap等。此外，还应该简要说明您了解的开发框架和库，例如React、Vue、Angular等。 在描述您的工作经验时，应该简要介绍您曾经参与的项目，包括项目的主要功能、您负责的工作内容和您贡献的主要技术。此外，还应该提及您的工作态度和工作能力，例如认真负责、注重团队合作、熟练掌握代码调试等。 在编写完简历之后，应该仔细检查语法和拼写错误，并确保简历内容简洁明了，表达出您的专业知识和工作经验。此外，还应该考虑简历的整体布局和设计，以确保简历能够吸引招聘方的眼球。 在简历开头写明自己的个人信息，包括姓名、电话号码、电子邮件地址、个人网站等。 接下来，写出自己的教育背景，包括所就读的大学和专业。如果有相关的证书或培训课程，也可以在这一部分提及。 在工作经验部分，按照时间倒序列出自己的工作经历。对于每个工作经历，可以描述工作内容、工作职责和所取得的成就。 在技能部分，列出自己在web前端开发方面的技能，包括熟悉的编程语言、框架和工具。还可以提及自己对用户体验和可用性的关注程度。 在简历末尾，可以附上作品集，展示自己在web前端开发方面的能力。这一部分可以包括项目链接、设计稿和截图等。 在简历最后，可以写一段自荐信，介绍自己的工作理念和为公司所做的贡献。 总的来说，编写web前端开发岗简历时，应该注重个人信息的准确性、工作经历的详实性","categories":[{"name":"面试经","slug":"面试经","permalink":"https://blog.rexhang.com/categories/%E9%9D%A2%E8%AF%95%E7%BB%8F/"},{"name":"前端","slug":"面试经/前端","permalink":"https://blog.rexhang.com/categories/%E9%9D%A2%E8%AF%95%E7%BB%8F/%E5%89%8D%E7%AB%AF/"},{"name":"JavaScript","slug":"面试经/前端/JavaScript","permalink":"https://blog.rexhang.com/categories/%E9%9D%A2%E8%AF%95%E7%BB%8F/%E5%89%8D%E7%AB%AF/JavaScript/"}],"tags":[{"name":"面试经","slug":"面试经","permalink":"https://blog.rexhang.com/tags/%E9%9D%A2%E8%AF%95%E7%BB%8F/"},{"name":"前端","slug":"前端","permalink":"https://blog.rexhang.com/tags/%E5%89%8D%E7%AB%AF/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://blog.rexhang.com/tags/JavaScript/"}]},{"title":"json-server的使用(接口数据mock好帮手)","slug":"json-server","date":"2022-12-15T04:00:20.000Z","updated":"2022-12-15T02:40:42.706Z","comments":true,"path":"2022/12/15/articles/1/","link":"","permalink":"https://blog.rexhang.com/2022/12/15/articles/1/","excerpt":"","text":"简介 json-server: 接口数据mock好帮手 新建文件&lt;db.json&gt;, 内容如下: 123456789101112131415161718192021222324252627&#123; &quot;posts&quot;: [ &#123; &quot;id&quot;: 1, &quot;title&quot;: &quot;json-server&quot;, &quot;author&quot;: &quot;typicode&quot; &#125; ], &quot;comments&quot;: [ &#123; &quot;id&quot;: 1, &quot;body&quot;: &quot;some comment&quot;, &quot;postId&quot;: 1 &#125; ], &quot;profile&quot;: &#123; &quot;name&quot;: &quot;typicode&quot; &#125;, &quot;users&quot;: [ &#123; &quot;id&quot;: 1, &quot;name&quot;: &quot;rexhang&quot;, &quot;guid&quot;: &quot;ee7a6768-bb2c-423c-ac06-5c7905c035b5&quot;, &quot;time&quot;: &quot;Wed, 14 Dec 1970 13:20:02 GMT&quot; &#125; ]&#125; 安装&amp;启动 npm install -g json-server 默认启动在localhost:3000端口，参数: 可以监听文件变化 –watch, 可以指定端口号 –port, 可以指定host –host json-server --watch db.json --port 8111 --host 127.0.0.1 然后会以JSON成员为键名，生成若干个请求地址，http://127.0.0.1:8111/JSON_KEY 请求方法(实现CURD) with REST Client(Ext) -&gt; 直达官网 Create 123456789###POST http://127.0.0.1:8111/userscontent-type: application/json &#123; &quot;name&quot;: &quot;rexhang&quot;, &quot;guid&quot;: &quot;&#123;&#123;$guid&#125;&#125;&quot;, &quot;time&quot;: &quot;&#123;&#123;$datetime rfc1123|iso8601&#125;&#125;&quot;&#125; Update 1234567###PATCH http://127.0.0.1:8111/users/1content-type: application/json &#123; &quot;name&quot;: &quot;rexhang&quot;&#125; Read 12###GET http://127.0.0.1:8111/profile 1234###GET http://127.0.0.1:8111/users?id=1&amp;name=rexhang Delete 12###DELETE http://127.0.0.1:8111/users/1","categories":[{"name":"前端","slug":"前端","permalink":"https://blog.rexhang.com/categories/%E5%89%8D%E7%AB%AF/"},{"name":"开发工具","slug":"前端/开发工具","permalink":"https://blog.rexhang.com/categories/%E5%89%8D%E7%AB%AF/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"},{"name":"node","slug":"前端/开发工具/node","permalink":"https://blog.rexhang.com/categories/%E5%89%8D%E7%AB%AF/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/node/"}],"tags":[{"name":"开发工具","slug":"开发工具","permalink":"https://blog.rexhang.com/tags/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"},{"name":"devtools","slug":"devtools","permalink":"https://blog.rexhang.com/tags/devtools/"},{"name":"node","slug":"node","permalink":"https://blog.rexhang.com/tags/node/"}]},{"title":"使用mask实现视频弹幕人物遮罩过滤，就是牛逼","slug":"使用mask实现视频弹幕人物遮罩过滤，就是牛逼","date":"2022-09-30T08:17:28.000Z","updated":"2022-10-25T14:41:49.323Z","comments":true,"path":"2022/09/30/articles/2/","link":"","permalink":"https://blog.rexhang.com/2022/09/30/articles/2/","excerpt":"","text":"经常看一些LOL比赛直播的小伙伴，肯定都知道，在一些弹幕网站（Bilibili、虎牙）中，当人物与弹幕出现在一起的时候，弹幕会“巧妙”的躲到人物的下面，看着非常的智能。 简单的一个截图例子： 其实，这里是运用了 CSS 中的 mask 属性实现的。 mask 简单用法介绍 这里只简单介绍下 mask 的基本用法： 最基本，使用 mask 的方式是借助图片，类似这样： 12345&#123; /* Image values */ mask: url(mask.png); /* 使用位图来做遮罩 */ mask: url(masks.svg#star); /* 使用 SVG 图形中的形状来做遮罩 */&#125; 当然，使用图片的方式后文会再讲。借助图片的方式其实比较繁琐，因为我们首先还得准备相应的图片素材，除了图片，mask 还可以接受一个类似 background 的参数，也就是渐变。 类似如下使用方法： 123&#123; mask: linear-gradient(#000, transparent) /* 使用渐变来做遮罩 */&#125; 那该具体怎么使用呢？一个非常简单的例子，上述我们创造了一个从黑色到透明渐变色，我们将它运用到实际中，代码类似这样： 下面这样一张图片，叠加上一个从透明到黑色的渐变， 1234&#123; background: url(image.png) ; mask: linear-gradient(90deg, transparent, #fff);&#125; 应用了 mask 之后，就会变成这样： 这个 DEMO，可以先简单了解到 mask 的基本用法。 这里得到了使用 mask 最重要结论：添加了 mask 属性的元素，其内容会与 mask 表示的渐变的 transparent 的重叠部分，并且重叠部分将会变得透明。 值得注意的是，上面的渐变使用的是 linear-gradient(90deg, transparent, #fff)，这里的 #fff 纯色部分其实换成任意颜色都可以，不影响效果。 使用 mask 实现人物遮罩过滤 了解了 mask 的用法后，接下来，我们运用 mask，简单实现视频弹幕中，弹幕碰到人物，自动被隐藏过滤的例子。 首先，我简单的模拟了一个召唤师峡谷，以及一些基本的弹幕： 方便示意，这里使用了一张静态图，表示了召唤师峡谷的地图，并非真的视频，而弹幕则是一条一条的 &lt;p&gt; 元素，和实际情况一致。伪代码大概是这样： 123456789&lt;!-- 地图 --&gt;&lt;div class=&quot;g-map&quot;&gt;&lt;/div&gt;&lt;!-- 包裹所有弹幕的容器 --&gt;&lt;div class=&quot;g-barrage-container&quot;&gt; &lt;!-- 所有弹幕 --&gt; &lt;div class=&quot;g-barrage&quot;&gt;6666&lt;/div&gt; ... &lt;div class=&quot;g-barrage&quot;&gt;6666&lt;/div&gt;&lt;/div&gt; 为了模拟实际情况，我们再用一个 div 添加一个实际的人物，如果不做任何处理，其实就是我们看视频打开弹幕的感受，人物被视频所遮挡： 注意，这里我添加了一个人物亚索，并且用 animation 模拟了简单的运动，在运动的过程中，人物是被弹幕给遮挡住的。 接下来，就可以请出 mask 了。 我们利用 mask 制作一个 radial-gradient ，使得人物附近为 transparent，并且根据人物运动的 animation，给 mask 的 mask-position 也添加上相同的 animation 即可。最终可以得到这样的效果： 1234567891011.g-barrage-container &#123; position: absolute; mask: radial-gradient(circle at 100px 100px, transparent 60px, #fff 80px, #fff 100%); animation: mask 10s infinite alternate;&#125;@keyframes mask &#123; 100% &#123; mask-position: 85vw 0; &#125;&#125; 实际上就是给放置弹幕的容器，添加一个 mask 属性，把人物所在的位置标识出来，并且根据人物的运动不断的去变换这个 mask 即可。我们把 mask 换成 background，原理一看就懂。 把 mask 替换成 background 示意图： background 透明的地方，即 mask 中为 transparent 的部分，实际就是弹幕会被隐藏遮罩的部分，而其他白色部分，弹幕不会被隐藏，正是完美的利用了 mask 的特性。 其实这项技术和视频本身是无关的，我们只需要根据视频计算需要屏蔽掉弹幕的位置，得到相应的 mask 参数即可。如果去掉背景和运动的人物，只保留弹幕和 mask，是这样的： 需要明确的是，使用 mask，不是将弹幕部分给遮挡住，而是利用 mask，指定弹幕容器之下，哪些部分正常展示，哪些部分透明隐藏。 实际生产环境中的运用 当然，上面我们简单的还原了利用 mask 实现弹幕遮罩过滤的效果。但是实际情况比上述的场景复杂的多，因为人物英雄的位置是不确定的，每一刻都在变化。所以在实际生产环境中，mask 图片的参数，其实是由后端实时对视频进行处理计算出来的，然后传给前端，前端再进行渲染。 对于运用了这项技术的直播网站，我们可以审查元素，看到包裹弹幕的容器的 mask 属性，每时每刻都在发生变化： 返回回来的其实是一个 SVG 图片，大概长这个样子： 这样，根据视频人物的实时位置变化，不断计算新的 mask，再实时作用于弹幕容器之上，实现遮罩过滤。","categories":[{"name":"大前端","slug":"大前端","permalink":"https://blog.rexhang.com/categories/%E5%A4%A7%E5%89%8D%E7%AB%AF/"},{"name":"css3","slug":"大前端/css3","permalink":"https://blog.rexhang.com/categories/%E5%A4%A7%E5%89%8D%E7%AB%AF/css3/"}],"tags":[{"name":"css3","slug":"css3","permalink":"https://blog.rexhang.com/tags/css3/"},{"name":"mask","slug":"mask","permalink":"https://blog.rexhang.com/tags/mask/"},{"name":"遮罩","slug":"遮罩","permalink":"https://blog.rexhang.com/tags/%E9%81%AE%E7%BD%A9/"}]},{"title":"CocosCreator实现不规则区域点击","slug":"CocosCreator实现不规则区域点击","date":"2022-09-30T07:36:22.000Z","updated":"2022-10-25T14:41:49.321Z","comments":true,"path":"2022/09/30/articles/1/","link":"","permalink":"https://blog.rexhang.com/2022/09/30/articles/1/","excerpt":"","text":"一、问题背景在CocosCreator中，点击图片透明区域依然触发节点的点击事件。但在web开发中，可以使用Inkscape、SvgPathEditor等矢量图编辑器转为SVG，或者直接从figma中导出SVG，然后监听不规则图形事件。 以地图边界高亮为例：html 类似地图的不规则图形事件处理 123svg &#123; height: 50vw; &#125;path &#123; fill: #d3d3d3; transition: .6s fill; opacity: 0.6;&#125;path:hover &#123; fill: #eee;opacity: 0.6; &#125; 但CocosCreator中Sprite目前支持的格式为jpg和png，未直接支持SVG。 二、方案调研图像模板(image_stencil) mask 如何控制只让图像遮罩的可视区域响应点击 图像模板可以根据设置的透明度阈值，只有当模板像素的 alpha 值大于该阈值时，才会绘制内容。 但是该方式点击透明区域，依然会触发该节点的事件。 通过查看2.4.7版本 CCMask.js 的源码 ，可以看到在碰撞检测中，图像模板类型的mask的命中方式与矩形保持一致，只有椭圆才是单独检测，故该方式并不能解决问题。 123456789101112131415161718192021222324252627282930_hitTest (cameraPt) &#123; let node = this.node; let size = node.getContentSize(), w = size.width, h = size.height, testPt = _vec2_temp; node._updateWorldMatrix(); // If scale is 0, it can&#x27;t be hit. if (!Mat4.invert(_mat4_temp, node._worldMatrix)) &#123; return false; &#125; Vec2.transformMat4(testPt, cameraPt, _mat4_temp); testPt.x += node._anchorPoint.x * w; testPt.y += node._anchorPoint.y * h; let result = false; if (this.type === MaskType.RECT || this.type === MaskType.IMAGE_STENCIL) &#123; result = testPt.x &gt;= 0 &amp;&amp; testPt.y &gt;= 0 &amp;&amp; testPt.x &lt;= w &amp;&amp; testPt.y &lt;= h; &#125; else if (this.type === MaskType.ELLIPSE) &#123; let rx = w / 2, ry = h / 2; let px = testPt.x - 0.5 * w, py = testPt.y - 0.5 * h; result = px * px / (rx * rx) + py * py / (ry * ry) &lt; 1; &#125; if (this.inverted) &#123; result = !result; &#125; return result;&#125; 多边形mask 1.Creator | 编辑器中可操作顶点的多边形遮罩2.【组件分享】使用Mask+Graphic魔改的多边形遮罩组件3.[ Mask + PolygonCollider 简易自定义多边形遮罩制作 ] 沿着mask的思路，在论坛上找到了多边形mask的实现方式。大致都是在CCMask源码的基础上，增加多边形的节点添加和碰撞检测，其中一位作者实现的组件非常吸睛，GitHub上共有400余Star，目前cocos商店已有该组件。感兴趣可阅读源码。 效果如下： 比较有意思是其碰撞检测（点是否在多边形内），采用射线法判断。 定义：从目标点出发引一条射线，看这条射线和多边形所有边的交点数目。如果有奇数个交点，则说明在内部，如果有偶数个交点，则说明在外部。 具体步骤：将测试点的Y坐标与多边形的每一个点进行比较，会得到一个测试点所在的行与多边形边的交点的列表。在下图的这个例子中有8条边与测试点所在的行相交，而有6条边没有相交。如果测试点的两边点的个数都是奇数个则该测试点在多边形内，否则在多边形外。在这个例子中测试点的左边有5个交点，右边有三个交点，它们都是奇数，所以点在多边形内。 算法实现： 12345678910111213141516171819202122232425isInPolygon(checkPoint: cc.Vec2, polygonPoints: cc.Vec2[]) &#123; let counter = 0, i: number, xinters: number; let p1: cc.Vec2, p2: cc.Vec2; let pointCount = polygonPoints.length; p1 = polygonPoints[0]; for (i = 1; i &lt;= pointCount; i++) &#123; p2 = polygonPoints[i % pointCount]; if ( checkPoint.x &gt; Math.min(p1.x, p2.x) &amp;&amp; checkPoint.x &lt;= Math.max(p1.x, p2.x) ) &#123; if (checkPoint.y &lt;= Math.max(p1.y, p2.y)) &#123; if (p1.x != p2.x) &#123; xinters = (checkPoint.x - p1.x) * (p2.y - p1.y) / (p2.x - p1.x) + p1.y; if (p1.y == p2.y || checkPoint.y &lt;= xinters) &#123; counter++; &#125; &#125; &#125; &#125; p1 = p2; &#125; return (counter &amp; 1) !== 0;&#125; 多边形mesh 多边形裁剪图片(非mask,使用mesh)，新增 gizmo 支持https://github.com/baiyuwubing/cocos-creator-examples/tree/master/meshTexture 2年前开发，已停止维护，使用不佳，节点关联顺序容易紊乱。根据作者的描述，可以解决mask过多带来性能影响。 像素点计算 creator 2.4.8中获取像素信息 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768const getPixelData = (node: cc.Node, x: number, y: number) =&gt; &#123; const pixelsData = getPixelsData(node); const startIndex = node.width * 4 * Math.floor(node.height - y) + 4 * Math.floor(x); const pixelData = pixelsData.slice(startIndex, startIndex + 4); return pixelData;&#125;;const isPixelTransparent = (node: cc.Node, x: number, y: number) =&gt; &#123; const pixelData = getPixelData(node, x, y); return pixelData[3] === 0;&#125;;const getPixelsData = (node: cc.Node) =&gt; &#123; if (!cc.isValid(node)) &#123; return null; &#125; // 节点宽度 const width = Math.floor(node.width); const height = Math.floor(node.height); // 创建临时摄像机用于渲染目标节点 const cameraNode = new cc.Node(); cameraNode.parent = node; const camera = cameraNode.addComponent(cc.Camera); // eslint-disable-next-line no-bitwise camera.clearFlags |= cc.Camera.ClearFlags.COLOR; camera.backgroundColor = cc.color(0, 0, 0, 0); camera.zoomRatio = cc.winSize.height / height; // 将节点渲染到 RenderTexture中 const renderTexture = new cc.RenderTexture(); renderTexture.initWithSize( width, height, cc.RenderTexture.DepthStencilFormat.RB_FMT_S8 ); camera.targetTexture = renderTexture; camera.render(node); const pixelData = renderTexture.readPixels(); return pixelData;&#125;;/** 点击事件是否合法，非透明像素 */ isValidTouch(e: cc.Event.EventTouch) &#123; const touchLocation = e.touch.getLocation(); /** 相对节点左下角的相对坐标，即图片内的坐标 */ const locationInNode = this.node.convertToNodeSpaceAR(touchLocation); /** 非本节点内 透传 */ if (!this.node.getBoundingBoxToWorld().contains(touchLocation)) &#123; this.setSwallowTouches(false); return false; &#125; const &#123; anchorX, anchorY, width, height &#125; = this.node; const x = locationInNode.x + anchorX * width; const y = -(locationInNode.y - anchorY * height); const isValid = !isPixelTransparent(this.node, x, y); this.setSwallowTouches(isValid); return isValid; &#125; /** 设置是否阻止点击事件透传 */ setSwallowTouches(bool: boolean) &#123; (this.node as any)._touchListener.setSwallowTouches(bool); &#125; 方案对比 方案名称 优点 缺点 图像模板mask - 适合图片快速裁剪渲染 - 不满足要求 多边形mask - 适用于多边形定制化裁剪 - 参考文章 [@]Mask组件多边形方案性影响手机Web性能。多边形mask使用过多，低端机性能下降严重（碰撞检测占主要原因） - 手动描边 多边形mesh - 根据作者描述，比mask性能更优 - 手动描边 像素点计算 - 颗粒度精细，能精确到像素点 - 无需特殊处理图片 - 图片过大时，可能带来性能问题 可能的最佳实践？在论坛中看到有个大佬在尝试svg拓展 Creator + SVG 解析渲染扩展组件 ，已上架cocos商店【价值80¥】","categories":[{"name":"大前端","slug":"大前端","permalink":"https://blog.rexhang.com/categories/%E5%A4%A7%E5%89%8D%E7%AB%AF/"},{"name":"游戏引擎","slug":"大前端/游戏引擎","permalink":"https://blog.rexhang.com/categories/%E5%A4%A7%E5%89%8D%E7%AB%AF/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"}],"tags":[{"name":"cocos2d","slug":"cocos2d","permalink":"https://blog.rexhang.com/tags/cocos2d/"},{"name":"CocosCreator","slug":"CocosCreator","permalink":"https://blog.rexhang.com/tags/CocosCreator/"},{"name":"游戏引擎","slug":"游戏引擎","permalink":"https://blog.rexhang.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"}]},{"title":"JS中非常实用的『一行代码』","slug":"JS中非常实用的『一行代码』","date":"2022-08-04T04:03:28.000Z","updated":"2022-12-15T02:28:27.977Z","comments":true,"path":"2022/08/04/articles/1/","link":"","permalink":"https://blog.rexhang.com/2022/08/04/articles/1/","excerpt":"","text":"导读: 最近在国外技术社区看到了一些关于 一行代码 的文章📄，感觉很有意思，就整理了下来并且自己额外补充了一部分分享给大家🤜，希望对各位读者们有所帮助💕。 最近一次更新时间 2022-08-21 12:00:15 这些方法使用到了一些API，简化了操作，但是有些方法写一行属实不太优雅，所以这里主要还是学习API的使用小技巧。 一、日期处理 检查日期是否有效该方法用于检测给出的日期是否有效 123const isDateValid = (...val) =&gt; !Number.isNaN( new Date(...val).valueOf() );// how to useisDateValid(&quot;December 17, 1995 03:24:00&quot;); // =&gt; true 计算两个日期之间的间隔该方法用于计算两个日期之间的间隔时间(day) 123const dayDif = (date1, date2) =&gt; Math.ceil( Math.abs( date1.getTime() - date2.getTime() ) / 86400000);// how to usedayDif(new Date(&quot;2022-08-01&quot;), new Date(&quot;2022-08-04&quot;)); // =&gt; 3 查找日期位于一年中的第几天该方法用于检测给出的日期位于今年的第几天 1234const dayOfYear = date =&gt; Math.floor( ( date - new Date(date.getFullYear(), 0, 0) ) / 1000 / 60 / 60 / 24 )// how to usedayOfYear(new Date(&quot;2022-08-01&quot;)); // =&gt; 213dayOfYear(new Date(&quot;2022-01-01&quot;)); // =&gt; 1 时间格式化该方法用于转换时间 12345const timeFromDate = date =&gt; date.toTimeString().slice(0, 8);// how to usetimeFromDate(new Date(2022, 08, 04, 12, 30, 0)); // =&gt; &#x27;12:30:00&#x27;timeFromDate(new Date(2022, 08, 04, 12, 30, 60)); // =&gt; &#x27;12:31:00&#x27;timeFromDate(new Date()); // =&gt; 此刻的时间 二、字符串处理 字符串首字母大写该方法用于将英文字符串的首字母大写处理 123const capitalize = str =&gt; str.charAt(0).toUpperCase() + str.slice(1);// how to usecapitalize(&quot;hello world&quot;); // =&gt; Hello world 翻转字符串该方法用于将一个字符串进行翻转操作并返回翻转后的内容 123const reverse = str =&gt; str.split(&#x27;&#x27;).reverse().join(&#x27;&#x27;);// how to usereverse(&quot;hello world&quot;); // =&gt; dlrow olleh 随机字符串该方法用于生成一个随机的字符串并返回 123const randomString = () =&gt; Math.random().toString(36).slice(2);// how to userandomString(); // =&gt; anyString 去除字符串中的HTML该方法用于去除字符串中的HTML元素 123const stripHtml = html =&gt; (new DOMParser().parseFromString(html, &#x27;text/html&#x27;)).body.textContent || &#x27;&#x27;;// how to usestripHtml(&quot;&lt;div&gt;Beware of the missing closing tag&lt;/div&gt;hello world&lt;i&gt;!&lt;i&gt;&quot;); // =&gt; &#x27;Beware of the missing closing taghello world!&#x27; 获取URL的search参数并json化该方法用于获取当前访问的URL中的search内容并解析成JSON键值对形式 123const urlParams = search =&gt; Object.fromEntries(new URLSearchParams(search));// how to useurlParams(location.search); // =&gt; &#123; id: &#x27;1&#x27;, name: &#x27;rexhang&#x27; &#125; 去除数字之外的所有字符该方法用于去除数字之外的所有字符 1234const toNumber = str =&gt; Number(str.replace(/\\D/g, &#x27;&#x27;));// how to useconst str = &#x27;hello 123 is god 456&#x27;;toNumber(str); // =&gt; 123456 空值(null | undefined)合并运算符该方法用于更简短的定义空值情况下的时候, null 或者 undefined 会认定为判断范围， 其余认为正常赋值 1234567891011121314const aa = isA ?? false;const bb = isB ?? &#x27;hello&#x27;;const cc = isC ?? &#x27;ok&#x27;;const dd = isD ?? &#x27;done&#x27;;// how to useconst isA = null;const isB = &#x27;&#x27;;const isC = undefined;const isD = false;const aa = isA ?? &#x27;...&#x27;;const bb = isB ?? &#x27;hello&#x27;;const cc = isC ?? &#x27;ok&#x27;;const dd = isD ?? &#x27;done&#x27;;console.log(aa, bb, cc, dd); 二、数组处理 从数组中移除重复项该方法用于从数组中移除重复项 123const removeDuplicates = arr =&gt; [...new Set(arr)];// how to useremoveDuplicates([1, 1, 3, 4, 1, 5]); // =&gt; [1, 3, 4, 5] 打乱数组顺序该方法用于打乱数组顺序，随机取random后的数组 1234const randomArr = arr =&gt; arr.sort(() =&gt; 0.5 - Math.random());// how to useconst arr = [&#x27;🙂&#x27;, &#x27;66&#x27;, true, 11, &#123;name: &#x27;rexhang&#x27;&#125;];console.log(randomArr(arr)); // random arr, eg: [&#x27;66&#x27;, 11, true, &#123;name: &#x27;rexhang&#x27;&#125;, &#x27;🙂&#x27;]; 从数组中随机去一个值该方法用于从数组中随机去一个值 1234const takeARandomItem = arr =&gt; arr[Math.floor(Math.random() * arr.length)]// how to useconst eles = [&#x27;🙂&#x27;, &#x27;66&#x27;, true, 11, &#123;name: &#x27;rexhang&#x27;&#125;];console.log(takeARandomItem(eles)); // random item of arr, eg: &#x27;🙂&#x27;; 从数组中取出最大/小值(仅限数字|字符串数字)该方法用于从数组中取出最大/小值(仅限数字|字符串数字) 1234567const getMaxMinValue = arr =&gt; (&#123; max: Math.max(...arr), min: Math.min(...arr),&#125;)// how to useconst items = [11, 12, 11, 1, &#x27;0&#x27;];console.log(getMaxMinValue(items)); // &#123; max: 12, min: 0 &#125; 判断数组是否为空该方法用于判断数组是否为空 12345const isNotEmpty = arr =&gt; Array.isArray(arr) &amp;&amp; !!arr.length;// how to useisNotEmpty([1, 3]); // =&gt; trueisNotEmpty([]); // =&gt; trueisNotEmpty(&quot;[1, 3]&quot;); // =&gt; 非数组返回false 长期且持续更新中…","categories":[{"name":"大前端","slug":"大前端","permalink":"https://blog.rexhang.com/categories/%E5%A4%A7%E5%89%8D%E7%AB%AF/"},{"name":"效率","slug":"大前端/效率","permalink":"https://blog.rexhang.com/categories/%E5%A4%A7%E5%89%8D%E7%AB%AF/%E6%95%88%E7%8E%87/"},{"name":"前端开发","slug":"大前端/效率/前端开发","permalink":"https://blog.rexhang.com/categories/%E5%A4%A7%E5%89%8D%E7%AB%AF/%E6%95%88%E7%8E%87/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://blog.rexhang.com/tags/javascript/"},{"name":"javascript数组","slug":"javascript数组","permalink":"https://blog.rexhang.com/tags/javascript%E6%95%B0%E7%BB%84/"},{"name":"javascript字符串","slug":"javascript字符串","permalink":"https://blog.rexhang.com/tags/javascript%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"js小tips","slug":"js小tips","permalink":"https://blog.rexhang.com/tags/js%E5%B0%8Ftips/"},{"name":"js技巧","slug":"js技巧","permalink":"https://blog.rexhang.com/tags/js%E6%8A%80%E5%B7%A7/"}]},{"title":"一套面向常规统计图表，以数据驱动的高交互可视化图形语法 - G2","slug":"G2","date":"2022-08-04T01:27:08.000Z","updated":"2022-10-25T14:41:49.322Z","comments":true,"path":"2022/08/04/articles/2/","link":"","permalink":"https://blog.rexhang.com/2022/08/04/articles/2/","excerpt":"","text":"G2 一套面向常规统计图表，以数据驱动的高交互可视化图形语法。 网站 • 教程文档 • 博客 • G2Plot G2 是一套基于图形语法理论的可视化底层引擎，以数据驱动，提供图形语法与交互语法，具有高度的易用性和扩展性。使用 G2，你可以无需关注图表各种繁琐的实现细节，一条语句即可使用 Canvas 或 SVG 构建出各种各样的可交互的统计图表。 📺 线上示例 ✨ 特性 💯 完善的图形语法：数据到图形的映射，能够绘制出所有的图表。 🤩 全新的交互语法：通过触发和反馈机制可以组合出各种交互行为，对数据进行探索。 🦍 强大的 View 模块：可支持开发个性化的数据多维分析图形。 👬 双引擎渲染：Canvas 或 SVG 任意切换。 💄 可视化组件体系：面向交互、体验优雅。 🛡 全面拥抱 TypeScript：提供完整的类型定义文件。 📦 安装1$ npm install @antv/g2 🔨 快速上手 在绘图前我们需要为 G2 准备一个 DOM 容器： 1&lt;div id=&quot;c1&quot;&gt;&lt;/div&gt; 12345678910111213141516171819202122232425import &#123; Chart &#125; from &#x27;@antv/g2&#x27;;const data = [ &#123; genre: &#x27;Sports&#x27;, sold: 275 &#125;, &#123; genre: &#x27;Strategy&#x27;, sold: 115 &#125;, &#123; genre: &#x27;Action&#x27;, sold: 120 &#125;, &#123; genre: &#x27;Shooter&#x27;, sold: 350 &#125;, &#123; genre: &#x27;Other&#x27;, sold: 150 &#125;,];// Step 1: 创建 Chart 对象const chart = new Chart(&#123; container: &#x27;c1&#x27;, // 指定图表容器 ID width: 600, // 指定图表宽度 height: 300, // 指定图表高度&#125;);// Step 2: 载入数据源chart.data(data);// Step 3: 创建图形语法，绘制柱状图chart.interval().position(&#x27;genre*sold&#x27;);// Step 4: 渲染图表chart.render(); ⌨️ 本地开发1234567891011121314# 安装依赖$ npm install# 运行测试用例$ npm run test# 打开 electron 运行测试用例，监听文件变化构建$ npm run test-live# 运行 CI$ npm run ci# 运行网站$ npm start 🏷️ 版本 v3.5.x: https://github.com/antvis/G2/tree/v3.5.x v4.0.x: https://github.com/antvis/G2/tree/v4.0.x 你也可以在业务中使用基于 G2 封装的常规统计图表 G2Plot ，可以使用配置的方式快速生成一个通用图表，降低开发者的使用成本。","categories":[{"name":"大前端","slug":"大前端","permalink":"https://blog.rexhang.com/categories/%E5%A4%A7%E5%89%8D%E7%AB%AF/"},{"name":"图表","slug":"大前端/图表","permalink":"https://blog.rexhang.com/categories/%E5%A4%A7%E5%89%8D%E7%AB%AF/%E5%9B%BE%E8%A1%A8/"},{"name":"G2","slug":"大前端/图表/G2","permalink":"https://blog.rexhang.com/categories/%E5%A4%A7%E5%89%8D%E7%AB%AF/%E5%9B%BE%E8%A1%A8/G2/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://blog.rexhang.com/tags/javascript/"}]},{"title":"React代码整洁优化实践","slug":"React代码整洁优化实践","date":"2022-08-02T14:16:48.000Z","updated":"2022-10-25T14:41:49.322Z","comments":true,"path":"2022/08/02/articles/1/","link":"","permalink":"https://blog.rexhang.com/2022/08/02/articles/1/","excerpt":"","text":"整洁的代码不仅仅是正常运行的代码，更是要求易于阅读、简单易懂、组织整齐。在本文中，我会们将示例几种代码整洁案例。在阅读这些建议时，要记住这些只是建议！ 如果你不同意它们中的任何一个，那也完全没关系。以下这些实践，个人觉得对我自己编写 React 代码很有帮助。1. 仅对一个条件进行渲染 如果需要在条件为true时渲染某些内容，而在条件为false时不渲染任何内容，不推荐使用三元表达式，改用与运算符&amp;&amp;，它可以方便地条件渲染一个元素。 优化前: 1234567891011import React from &quot;react&quot;;export const TopNav = (props: &#123; showSearch?: boolean &#125;) =&gt; &#123; const &#123; showSearch = false &#125; = props; return ( &lt;div className=&quot;doc-head&quot;&gt; &#123;/* 三元表达式进行条件渲染 */&#125; &#123;showSearch ? &lt;SearchBox placeholder=&quot;输入关键词搜索&quot; onSearch=&#123;(keyword) =&gt; window.location.assign(`/privatecloud/search?q=$&#123;keyword&#125;`)&#125; style=&#123;&#123; marginRight: 100 &#125;&#125; /&gt; : null&#125; &lt;/div&gt; );&#125;; 优化后: 1234567891011import React from &quot;react&quot;;export const TopNav = (props: &#123; showSearch?: boolean &#125;) =&gt; &#123; const &#123; showSearch = false &#125; = props; return ( &lt;div className=&quot;doc-head&quot;&gt; &#123;/* 与运算符&amp;&amp;进行条件渲染 */&#125; &#123;showSearch &amp;&amp; &lt;SearchBox placeholder=&quot;输入关键词搜索&quot; onSearch=&#123;(keyword) =&gt; window.location.assign(`/privatecloud/search?q=$&#123;keyword&#125;`)&#125; style=&#123;&#123; marginRight: 100 &#125;&#125; /&gt;&#125; &lt;/div&gt; );&#125;; 2. 每一个条件都可能进行渲染 如果需要在条件为 true 时渲染某些内容，而在条件为 false 时渲染其他内容。推荐使用三元表达式！ 优化前: 123&#123;/* 条件 True 和 False 都要渲染内容 */&#125;&#123; good &amp;&amp; &lt;p&gt;Good!&lt;/p&gt; &#125;&#123; !good &amp;&amp; &lt;p&gt;&lt;b&gt;Not Good!&lt;b&gt;&lt;/p&gt; &#125; 优化后: 123456789101112&#123; /* 三元表达式 */&#125;&#123; good ? ( &lt;p&gt;Good!&lt;/p&gt; ) : ( &lt;p&gt; &lt;b&gt;Not Good!&lt;/b&gt; &lt;/p&gt; );&#125; 3. 组件 Boolean props 传参 组件接收参数的属性值为布尔类型, 并且传入 true 值时，可以省略填写值，并不会影响组件内取到 true 值 优化前: 12&lt;Hello disabled=&#123;true&#125; /&gt;&lt;Hello disabled=&#123;false&#125; /&gt; 优化后: 12&lt;Hello disabled /&gt;&lt;Hello disabled=&#123;false&#125; /&gt; 4. 组件 String props 传参 组件 Props 值为 String, 推荐使用双引号包裹，不使用花括号或反引号。 优化前: 123&lt;Hello personName=&#123;&quot;Jim&quot;&#125; /&gt;&lt;Hello personName=&#123;&#x27;Tom&#x27;&#125; /&gt;&lt;Hello personName=&#123;`Ken`&#125; /&gt; 优化后: 123&lt;Hello personName=&quot;Jim&quot; /&gt;&lt;Hello personName=&quot;Tom&quot; /&gt;&lt;Hello personName=&quot;Ken&quot; /&gt; 5. Event handler functions 如果一个事件函数只接受一个参数，不需要传入匿名函数：onChange={ e =&gt; handleChange(e) }，推荐这种写法(直接等于函数)： onChange={ handleChange } 。 优化前: 1234const handleChange = (e) =&gt; &#123; console.info(e.target.value);&#125;;&lt;input id=&quot;name&quot; value=&#123;inputValue&#125; onChange=&#123;(e) =&gt; handleChange(e)&#125; /&gt;; 优化后: 1234567const handleChange = (e) =&gt; &#123; console.info(e.target.value);&#125;;&#123; /* 事件只有一个参数，不需要匿名函数*/&#125;&lt;input id=&quot;name&quot; value=&#123;inputValue&#125; onChange=&#123;handleChange&#125; /&gt;; 6. components as props 将组件作为参数传递给另一个组件时，如果该组件不接受任何参数，则无需将该传递的组件包装在函数中。 优化前: 12&lt;Hello ClockComponent=&#123;() =&gt; &lt;Clock timestamp=&#123;new Date().getTime()&#125; /&gt;&#125; /&gt;&lt;Hello ClockComponent=&#123;() =&gt; &lt;Clock /&gt;&#125; /&gt; 优化后: 12&lt;Hello ClockComponent=&#123;() =&gt; &lt;Clock timestamp=&#123;new Date().getTime()&#125; /&gt;&#125; /&gt;&lt;Hello ClockComponent=&#123;Clock&#125; /&gt; 7. 设置 state 依赖先前的 state 如果新 state 依赖于先前 state，则始终将 state 设置为先前 state 的函数。可以批处理 React 状态更新。 优化前: 1234567891011121314151617181920212223import React, &#123; useState &#125; from &quot;react&quot;;export const Hello = () =&gt; &#123; const [cout, setCount] = useState &lt; number &gt; 0; // 依赖先前/上一个的state值 (异步调用) const handleClick = (e) =&gt; setCount(cout + 1); // 期望执行2次 首次执行理应 cout = 2 const handleClickRunDouble = (e) =&gt; &#123; // 执行第二个handleClick执行的时候第一个count设置未完成(异步的)，所以还是 count = 0 = 0 + 1 = 1 因此 首次的点击得到的值 = 1 而并非2, 如果需要实现2 那么就得利用setState的批处理方式 handleClick(e); handleClick(e); &#125;; return ( &lt;div&gt; &lt;button onclick=&#123;handleClick&#125;&gt;click here&lt;/button&gt; &lt;span&gt;&#123;count&#125;&lt;/span&gt; &lt;button onclick=&#123;handleClickRunDouble&#125;&gt;click here &amp; lunch 2 times&lt;/button&gt; &lt;/div&gt; );&#125;; 优化后: 123456789101112131415161718192021222324import React, &#123; useState &#125; from &quot;react&quot;;export const Hello = () =&gt; &#123; const [cout, setCount] = useState &lt; number &gt; 0; &#123; /* 将set调用设置为批处理模式 使用set方法提供的callback内的数值 */ &#125; const handleClick = (e) =&gt; setCount((c) =&gt; c + 1); // 首次调用后会输出最新的值 count = 2; const handleClickRunDouble = (e) =&gt; &#123; handleClick(e); handleClick(e); &#125;; return ( &lt;div&gt; &lt;button onclick=&#123;handleClick&#125;&gt;click here&lt;/button&gt; &lt;span&gt;&#123;count&#125;&lt;/span&gt; &lt;button onclick=&#123;handleClickRunDouble&#125;&gt;click here &amp; lunch 2 times&lt;/button&gt; &lt;/div&gt; );&#125;; 以上 7 个就是我推荐和总结的几个React代码整洁优化实践 。 最后，祝大家开发愉快！","categories":[{"name":"大前端","slug":"大前端","permalink":"https://blog.rexhang.com/categories/%E5%A4%A7%E5%89%8D%E7%AB%AF/"},{"name":"面试经","slug":"大前端/面试经","permalink":"https://blog.rexhang.com/categories/%E5%A4%A7%E5%89%8D%E7%AB%AF/%E9%9D%A2%E8%AF%95%E7%BB%8F/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://blog.rexhang.com/tags/javascript/"},{"name":"React","slug":"React","permalink":"https://blog.rexhang.com/tags/React/"},{"name":"前端框架","slug":"前端框架","permalink":"https://blog.rexhang.com/tags/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/"}]},{"title":"数组的一些常用方法及使用区别","slug":"数组的一些常用方法及使用区别","date":"2021-05-13T16:22:22.000Z","updated":"2022-10-25T14:41:49.325Z","comments":true,"path":"2021/05/14/articles/1/","link":"","permalink":"https://blog.rexhang.com/2021/05/14/articles/1/","excerpt":"","text":"一、前言push pop unshift shift splice slice split join 方法及使用区别 二、示例1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162// push pop unshift shift splice slice split joinconst arr = [1, 2, 3, 4];// push、unshift向数组的 尾部/头部 添加若干元素，并返回 数组的 新长度const a = arr.push(&#x27;X&#x27;, &#x27;Y&#x27;, &#x27;Z&#x27;); // -&gt; new lengthconst b = arr.unshift(&#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;); // -&gt; new lengthconsole.log(a);console.log(b);console.log(arr);// pop、shift向数组的 尾部/头部 删除一个元素 并返回 数组中 被删除的元素const c = arr.pop(); // -&gt; last itemconst d = arr.shift(); // -&gt; first itemconsole.log(c);console.log(d);const e = arr.push();const f = [].pop();const g = [].shift();console.log(e);console.log(f);console.log(g);// splice 向/从数组中添加/删除项目，然后返回被删除的项目集合[?1, ?2]。 -1开始反方向删除(末尾第一个) 即便是负数 也都是从左到右删除单位const h = arr.splice(-2, 2, &#x27;rex&#x27;, &#x27;hang&#x27;, &#x27;gu&#x27;);console.log(h);// slice 只对数组范围做截取 并返回 截取的内容const i = arr.slice(1, -2); // 区间 -&gt; (?] 不包含末尾console.log(i);// split 用于 把一个有标记的字符串 分割成 标准数组const j = &#x27;a|b|c&#x27;.split(&#x27;|&#x27;);console.log(j);// join 用于 把一个标准数组 变成 固定符号分隔的 字符串const k = [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;].join(&#x27;|&#x27;);console.log(k);console.log(arr); 控制台输出内容如图所示: 看完上述例子后，我想大家都应该大致明白了这些方法的使用区别。","categories":[{"name":"大前端","slug":"大前端","permalink":"https://blog.rexhang.com/categories/%E5%A4%A7%E5%89%8D%E7%AB%AF/"},{"name":"面试经","slug":"大前端/面试经","permalink":"https://blog.rexhang.com/categories/%E5%A4%A7%E5%89%8D%E7%AB%AF/%E9%9D%A2%E8%AF%95%E7%BB%8F/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://blog.rexhang.com/tags/javascript/"},{"name":"javascript数组","slug":"javascript数组","permalink":"https://blog.rexhang.com/tags/javascript%E6%95%B0%E7%BB%84/"}]},{"title":"探讨下前端开发过程中在苹果系统下的一些兼容性小坑以及解决方案","slug":"探讨下前端开发过程中在苹果系统下的一些兼容性小坑以及解决方案","date":"2021-01-12T13:20:30.000Z","updated":"2022-10-25T14:41:49.324Z","comments":true,"path":"2021/01/12/articles/1/","link":"","permalink":"https://blog.rexhang.com/2021/01/12/articles/1/","excerpt":"","text":"导读: 本文会长期更新，目前仅写出已收集并且经过验证的案例分享🙉 大家在做前端开发过程中势必会和H5打交道&lt;这里指的H5仅表示在苹果系统下运行的H5&gt;，在原本不应该出现的异常行为经常会搞得稀里糊涂，遂去各类搜索引擎搜索结局方案，本文故此摘录各类表现在苹果环境下的开发“异常行为”，并且给出大概可行的兼容方案来帮助大家单项搜集的烦恼 可能存在兼容性问题搜集 1.Date.parse() parse() 方法可解析一个日期时间字符串，并返回 1970/1/1 午夜距离该日期时间的毫秒数。W3C参考文档 代码部分: 1Date.parse(&quot;2020-02-02 00:00:00&quot;) 可能会在苹果环境中出现NaN的返回结果 解决方案是: 不使用具体时间 =&gt; Date.parse(&quot;2020-02-02&quot;) 使用“**/”代替“-**”来分割日期 =&gt; Date.parse(&quot;2020/02/02 00:00:00&quot;) 替换字符串为第二种方案 =&gt; Date.parse(&quot;2020-02-02 00:00:00&quot;.replace(/-/g, &#39;/&#39;)) 2.window.open() open() 方法用于打开一个新的浏览器窗口或查找一个已命名的窗口。W3C参考文档 代码部分: 1window.open(&#x27;//rexhang.com&#x27;); 可能会在苹果环境中出现被阻止打开的情况，这是由于苹果安全策略进行了拦截 解决方案是: 使用window.location.href = &#39;//rexhang.com&#39;代替 使用window.location.replace(&#39;//rexhang.com&#39;)代替 3.待博主更新…结语 这样的坑还有许多许多不仅仅是ios还有android也会存在一些兼容性问题，本文会长期更新，尽可能搜集更多的兼容案例，如有更多案例本文未提到的，希望大家踊跃提出，反馈在下方评论里，多谢大家~","categories":[{"name":"大前端","slug":"大前端","permalink":"https://blog.rexhang.com/categories/%E5%A4%A7%E5%89%8D%E7%AB%AF/"},{"name":"兼容性","slug":"大前端/兼容性","permalink":"https://blog.rexhang.com/categories/%E5%A4%A7%E5%89%8D%E7%AB%AF/%E5%85%BC%E5%AE%B9%E6%80%A7/"},{"name":"心得","slug":"大前端/兼容性/心得","permalink":"https://blog.rexhang.com/categories/%E5%A4%A7%E5%89%8D%E7%AB%AF/%E5%85%BC%E5%AE%B9%E6%80%A7/%E5%BF%83%E5%BE%97/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://blog.rexhang.com/tags/javascript/"},{"name":"前端多端开发兼容性","slug":"前端多端开发兼容性","permalink":"https://blog.rexhang.com/tags/%E5%89%8D%E7%AB%AF%E5%A4%9A%E7%AB%AF%E5%BC%80%E5%8F%91%E5%85%BC%E5%AE%B9%E6%80%A7/"},{"name":"ios","slug":"ios","permalink":"https://blog.rexhang.com/tags/ios/"},{"name":"macos","slug":"macos","permalink":"https://blog.rexhang.com/tags/macos/"},{"name":"apple","slug":"apple","permalink":"https://blog.rexhang.com/tags/apple/"},{"name":"苹果","slug":"苹果","permalink":"https://blog.rexhang.com/tags/%E8%8B%B9%E6%9E%9C/"}]},{"title":"Vue双向绑定的原理","slug":"Vue双向绑定的原理","date":"2021-01-10T07:56:57.000Z","updated":"2022-10-25T14:41:49.322Z","comments":true,"path":"2021/01/10/articles/2/","link":"","permalink":"https://blog.rexhang.com/2021/01/10/articles/2/","excerpt":"","text":"双向绑定原理及简单实现Vue是采用数据劫持结合发布者-订阅者模式的方式，通过new Proxy()来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。 Vue3.x与Vue2.x的区别仅是数据劫持的方式由Object.defineProperty更改为Proxy代理，其他代码不变Vue最核心的功能有两个，一是响应式的数据绑定系统，二是组件系统。本文仅探究双向绑定是怎样实现的。以及实现一个简化版的**Vue-lite** 一、访问器属性访问器属性是对象中的一种特殊属性，它不能直接在对象中设置，而必须通过defineProperty()方法单独定义。 123456789101112const obj = &#123;&#125;;Object.defineProperty(obj, &#x27;hello&#x27;, &#123; set: newVal =&gt; &#123; console.log(&#x27;set方法被调用了&#x27;); console.log(&#x27;newVal=&#x27;+newVal); &#125;, get: () =&gt; &#123; console.log(&#x27;get方法被调用了&#x27;); &#125;&#125;);obj.hello = &#x27;xxx&#x27;; // 会触发访问器属性中的set方法 参数是xxxobj.hello // 会触发访问器属性中的get方法 其中**get(),set()**方法就是实现双向绑定的关键 二、极简双向绑定的实现html部分: 1234567891011121314&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Vue-lite&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;input type=&quot;text&quot; id=&quot;inputs&quot; /&gt; &lt;p id=&quot;tips&quot;&gt;&lt;/p&gt; &lt;button id=&quot;btn&quot;&gt;设置新值&lt;/button&gt; &lt;script src=&quot;./js/Vue-lite.js&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; Vue-lite.js: 123456789101112131415161718192021222324const inputs = document.querySelector(&#x27;#inputs&#x27;);const tips = document.querySelector(&#x27;#tips&#x27;);const btn = document.querySelector(&#x27;#btn&#x27;);const obj = &#123;&#125;;Object.defineProperty(obj, &#x27;hello&#x27;, &#123; set: newVal =&gt; &#123; inputs.value = newVal; tips.innerHTML = newVal; &#125;, get: () =&gt; &#123; console.log(&#x27;get方法被调用了&#x27;); return &#x27;123&#x27;; // 可以对值进行修改 &#125;&#125;);obj.hello = &#x27;xxx&#x27;; // 会触发访问器属性中的set方法 参数是xxxconsole.log(obj.hello); // 会触发访问器属性中的get方法inputs.addEventListener(&#x27;keyup&#x27;, e=&gt;&#123; obj.hello = e.target.value;&#125;);btn.addEventListener(&#x27;click&#x27;, e=&gt;&#123; obj.hello = &#x27;233&#x27;; // set数据&#125;);// 实现了 model =&gt; view 以及 view =&gt; model 的双向绑定。// 以上就是 Vue2.x 实现双向绑定的基本原理。 此例实现的效果是：随文本框输入文字的变化，span 中会同步显示相同的文字内容；在js或控制台显式的修改 obj.hello 的值，视图会相应更新。这样就实现了 model =&gt; view 以及 view =&gt; model 的双向绑定，就是Vue实现双向绑定的最基本原理。 三、细节优化上述示例仅仅是为了说明原理。我们最终要实现的是： 1234567&lt;div id=&quot;app&quot;&gt; &lt;div&gt; &lt;span&gt;姓名: &lt;/span&gt; &lt;input type=&quot;text&quot; name=&quot;name&quot; v-mode=&quot;name&quot; /&gt; &lt;/div&gt; &lt;p&gt;您输入的name是: &#123;&#123;name&#125;&#125;&lt;/p&gt;&lt;/div&gt; 123456const vm = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; name: &#x27;rexhang&#x27; &#125;&#125;); 首先做下需要实现功能点: 输入框以及文本节点与 data 中的数据绑定 输入框内容变化时，data 中的数据同步变化。即 view =&gt; model 的变化 data 中的数据变化时，文本节点的内容同步变化。即 model =&gt; view 的变化 html: 1234567891011121314&lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;name&quot; v-model=&quot;name&quot; /&gt; &lt;br /&gt; &#123;&#123;name&#125;&#125;&lt;/div&gt;&lt;script src=&quot;./js/Vue-lite.js&quot;&gt;&lt;/script&gt;&lt;script&gt; new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; name: &#x27;rexhang&#x27; &#125; &#125;);&lt;/script&gt; Vue-lite.js: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135function nodeToFragment(node, vm) &#123; // createDocumentFragment()方法，是用来创建一个虚拟的节点对象，或者说，是用来创建文档碎片节点。它可以包含各种类型的节点，在创建之初是空的。 let virtualDOM = document.createDocumentFragment(); let child; while( child = node.firstChild)&#123; compile(child, vm) virtualDOM.appendChild(child); &#125; return virtualDOM;&#125;function compile (node, vm)&#123; const reg = /\\&#123;\\&#123;(.*)\\&#125;\\&#125;/; console.log(node); console.log(node.nodeType); if (node.nodeType === 1)&#123; // 节点类型是元素 const attr = node.attributes; for(let i = 0; i &lt; attr.length; i++)&#123; console.log(attr[i].nodeName); if(attr[i].nodeName === &#x27;v-model&#x27;)&#123; // 提取v-model的value const name = attr[i].nodeValue; node.addEventListener(&#x27;input&#x27;, e=&gt;&#123; vm[name] = e.target.value; &#125;); // 将data的值赋给该node // node.value = vm.data[name]; node.value = vm[name]; node.removeAttribute(&#x27;v-model&#x27;); &#125; &#125; &#125; if (node.nodeType === 3)&#123; // 节点类型是text if(reg.test(node.nodeValue))&#123; // 正则来获取匹配到的字符串&#123;&#123;name&#125;&#125; =&gt; name let name = node.nodeValue.match(reg)[1].trim(); // 将data的值赋给该node // node.nodeValue = vm.data[name]; // node.nodeValue = vm[name]; console.log(vm, node, name); new Watcher(vm, node, name); &#125; &#125;&#125;function defineReactive(obj, key, val)&#123; const dep = new Dep(); Object.defineProperty(obj, key, &#123; set: newVal =&gt; &#123; if(newVal === val) return; val = newVal; console.log(val); dep.notify(); &#125;, get: () =&gt; &#123; if(Dep.target) dep.addSub(Dep.target); return val; &#125; &#125;)&#125;function observe (obj, vm) &#123; Object.keys(obj).forEach(key=&gt;&#123; defineReactive(vm, key, obj[key]); &#125;);&#125;const dep = new Dep();const pub = &#123; publish: ()=&gt;&#123; dep.notify(); &#125;&#125;const sub1 = &#123; update: function () &#123; console.log(1); &#125; &#125;const sub2 = &#123; update: function () &#123; console.log(2); &#125; &#125;const sub3 = &#123; update: function () &#123; console.log(3); &#125; &#125;function Dep () &#123; // this.subs = [sub1, sub2, sub3]; this.subs = [];&#125;// Dep.prototype.notify = function()&#123;// this.subs.forEach(sub=&gt;&#123;// sub.update();// &#125;)// &#125;Dep.prototype.addSub = function(sub)&#123; this.subs.push(sub)&#125;Dep.prototype.notify = function()&#123; this.subs.forEach(sub=&gt;&#123; sub.update(); &#125;)&#125;pub.publish();function Watcher(vm, node, name)&#123; Dep.target = this; this.name = name; this.node = node; this.vm = vm; this.update(); Dep.target = null;&#125;Watcher.prototype = &#123; update: function()&#123; this.get(); this.node.nodeValue = this.value; &#125;, get: function()&#123; this.value = this.vm[this.name]; &#125;&#125;function Vue(opt)&#123; this.data = opt.data; observe(this.data, this); const rootDom = opt.el; const dom = nodeToFragment(document.querySelector(rootDom), this); // 编译完成，将dom返回到app中 document.querySelector(rootDom).appendChild(dom);&#125; 最终实现效果: 四、总结 Object.defineProperty 来进行数据中转(劫持)，从而实现事件的发布和后续触发订阅者的监听来实现数据绑定 实现一个监听器 observe 用来劫持并监听所有属性，如有变动，就通知订阅者 实现一个订阅者 Watcher 每个Watcher都绑定一个更新函数，可以把收到的属性变化通知并执行相应的函数，更新视图 实现一个解析器 compile 可以循环解析全部节点获取相关指令，初始化数据，初始化订阅 原文参考 Vue3.x双向绑定原理的实现参考","categories":[{"name":"大前端","slug":"大前端","permalink":"https://blog.rexhang.com/categories/%E5%A4%A7%E5%89%8D%E7%AB%AF/"},{"name":"面试经","slug":"大前端/面试经","permalink":"https://blog.rexhang.com/categories/%E5%A4%A7%E5%89%8D%E7%AB%AF/%E9%9D%A2%E8%AF%95%E7%BB%8F/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://blog.rexhang.com/tags/javascript/"},{"name":"前端框架","slug":"前端框架","permalink":"https://blog.rexhang.com/tags/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/"},{"name":"Vue","slug":"Vue","permalink":"https://blog.rexhang.com/tags/Vue/"}]},{"title":"几种判断数组的方法","slug":"几种判断数组的方法","date":"2021-01-09T16:01:22.000Z","updated":"2022-10-25T14:41:49.323Z","comments":true,"path":"2021/01/10/articles/1/","link":"","permalink":"https://blog.rexhang.com/2021/01/10/articles/1/","excerpt":"","text":"一、前言众所周知，js是门“动态”、“弱类型”编程语言，这意味着在js中可以任性定义变量，同时，“任性”也意味着需常在项目开发中对变量做类型判断，曾几何时，对数组变量的类型判断是件很痛苦的事情，开发人员想出多种方案来对数组做出准确的类型判断，但效果不佳，直到ES5标准“入主中原”，判断数组类型有了标准的isArray()官方利剑，才降伏了数组类型判断这条恶龙，世间得一清，但在此之前开发者是如何判断数组类型的？判断数组类型为何会如此玄学？为何要判断数组类型？带着这些疑问，吾跋山涉水，探寻各方资料，整理消化后遂成此文，以记之。 二、判断js数组类型为何麻烦？1、语言本身的“缺陷”js是门“动态”“弱类型”编程语言，这意味着js在定义和使用变量时可以“任性”，在ES6之前，我们定义变量一般使用“var”来定义： 123var name = &#x27;jack&#x27;;name = 20;name = [&#x27;aa&#x27;]; 在上述例子中，name变量初始定义为字符串类型，而后变为数字类型，最后摇身一变成为数组类型，这种任性摇摆的特性就是其“动态”特性，在java中我们定义一个字符串变量须如此定义：String name = ‘jack’，java通过一个String前缀“显式的”、“强制的”指定name变量为字符串类型，之后不得对该name变量进行类型变换(如果执行name = 22将会报type类型转换错误)，但js采用的是弱类型定义方案，在定义变量时使用var声明了一个变量，弱化了类型前缀的限制，并没强制锁死变量类型，之后可以随意更改其类型。动态弱类型这种声明变量的方案用起来可以随性而为，无须顾虑太多，随性的代码书写如若不加管制必将招致灾难性的代码bug。 2、js类型判断的“不足”其实动态弱类型的语言特性并不是决定js判断数组类型麻烦的必然原因，js语言因为历史原因，其创造者在开发之初将其定位为简单的网页小助手语言，为了轻巧、快速的完成小任务开发选择了“动态弱类型”的语言方案，PHP亦为动态弱类型语言，但在处理类型判断时，PHP用一个gettype()方法可以轻松、精准的搞定(PHP作为世界上世界上最好的语言还是有点东西的🤣)，PHP有gettype()这枚银弹，js有吗，嗯，算有吧，js最常用的是用typeof操作符来获取数据类型，看typeof这个名字是不是感觉很厉害？感觉会跟PHP一样轻松简单？但随后你会发现：typeof操作符是个很局限的类型获取方案，用它对基本数据类型做判断还算过得去，但在涉及到引用类型判断这种细活时就显得很low了… 三、判断js数组类型的几个“方案”1.typeof ❌ typeof在判断基础数据类型时尚有问题，更别说用来判断子孙繁多的引用类型了，typeof在判断引用类型时一刀切的统统返回object, 如 1234567var obj = &#123;&#125;;var arr = [];var map = new Map();typeof obj; // objecttypeof arr; // objecttypeof map; // object 故此，不适应于判断数据，PASS 2.data instanceof Array ❌ instanceof是js用来判断继承关系的运算符（js基于原型链实现继承，故instanceof判断的就是对应的类是否存在于变量的原型链上），根据这个特性可以如此来判断数组类型： 12const arr = [1, 2, 3];console.log(arr instanceof Array); // true 控制台打印显示如下: 从打印的结果可以看到Array存在于数组[1, 2, 3]的原型链上，故[1, 2, 3] instanceof Array === true; 利用instanceof的这个特性可以判断数组类型，但是instanceof运算符有个弊端 就是arr instanceof Object也是返回true: 12const arr2 = [1, 2, 3];console.log(arr2 instanceof Object); // true 控制台打印显示如下: 故此，不适应于判断数据，PASS 3.constructor ✔ 在JavaScript中, constructor属性会返回对象的构造函数。 1234let arr = [1, 2, 3];console.log(arr.constructor === Array); // truelet arr = [1, 2, 3];console.log(arr.constructor === Object); // false 控制台打印显示如下: 从打印结果显示，是满足我们的数据类型判断的，并且没有出现第二种判断方式instanceof方法的问题，因此是可以采用的。 4.Object.prototype.toString() ✔ Object.prototype.toString()能获取到变量的“类目名”，在js中万物皆为对象，万物皆有“类目名”，每个变量、对象、数组等都有一个唯一的类目名（这个类目名类似于人类给各类动植物起的“学名”），该方案通过获取目标变量的类目名([object Array])进行判断，如果类目名一致则证明目标变量为数组类型： 12let arr = [1, 2, 3];console.log( Object.prototype.toString.call(arr) === &#x27;[object Array]&#x27; ); // [object Array]: string; 返回 true Tips: 这种方法获取各种类型数据都有与之对应的字符串匹配值 12345678Object.prototype.toString.call([]); // &quot;[object Array]&quot;Object.prototype.toString.call(&#123;&#125;); // &quot;[object Object]&quot;Object.prototype.toString.call(&#x27;&#x27;); // &quot;[object String]&quot;Object.prototype.toString.call(1); // &quot;[object Number]&quot;Object.prototype.toString.call(function f()&#123;&#125;); // &quot;[object Function]&quot;Object.prototype.toString.call(); // &quot;[object Undefined]&quot;Object.prototype.toString.call(null); // &quot;[object Null]&quot;Object.prototype.toString.call(document); // &quot;[object HTMLDocument]&quot; 从打印结果显示，是满足我们的数据类型判断的，因此是可以采用的。 5.Array.isArray() ✔ 该方法是ES5标准规定的判断数组类型的标准方法，虽然Object.prototype.toString()方法可用来判断数组类型，但未免显得有点hack，又因自家typeof类型操作符给予厚望，辱没众望，如果随便更改typeof的返回结果势必会导致天下大乱，instanceof运算符又存在不同frame的局限性难堪大任，ES5不得不亡羊补牢的设计了isArray()方法来“增量”的解决数组判断难题。 12Array.isArray([1, 2, 3]); // trueArray.isArray(&#123;&#125;); // false 从打印结果显示，是满足我们的数据类型判断的，因此是可以采用的。 四、为何要判断数组类型？前面说过js属于动态弱类型语言，可能某个变量用着用着就莫名其妙的变了类型（自己不小心更改类型，引入的第三方代码库，因为同名变量改变了类型），如果你设想的是某个变量为数组类型，但因某个逻辑变成了基本类型，这时如果调用数组的方法注定会报错，凡此种种导致的问题，数不胜数，具体的问题实践多了懂得就懂。 五、结语近几年前端项目愈发复杂庞大，为更好的构建高性能的前端项目，诞生了“react、angular、vue”等数据驱动型解决方案，大量的数据、大量的组件和类对数据类型的判断需求愈发频繁，但因为js动态弱类型语言特性，加之其类型判断的坑爹性，所以各路开发者希望完善和升级js，在ES6标准中，新的const变量定义方案能很好的应对变量动态性问题，微软开发的“typescript”能够实现强类型变量定义，可应对弱类型定义问题。这些方案极大的减少了早期js变量任性定义带来的各种问题，虽然判断数组类型在未来开发中可能会成为历史云烟，但理解其相关的基础和历史演变却是一件很【浪漫】的事情，因为在理解了它的相关坑爹性和进化史有助于我们更好的思考和优化。爱之深，责之切，希望js能在未来变得更加锋利可靠，也希望少为一些坑爹特性而想出一些hack方案(额，比如——&gt;Object.prototype.toString()方法)。","categories":[{"name":"大前端","slug":"大前端","permalink":"https://blog.rexhang.com/categories/%E5%A4%A7%E5%89%8D%E7%AB%AF/"},{"name":"面试经","slug":"大前端/面试经","permalink":"https://blog.rexhang.com/categories/%E5%A4%A7%E5%89%8D%E7%AB%AF/%E9%9D%A2%E8%AF%95%E7%BB%8F/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://blog.rexhang.com/tags/javascript/"},{"name":"javascript数组","slug":"javascript数组","permalink":"https://blog.rexhang.com/tags/javascript%E6%95%B0%E7%BB%84/"}]},{"title":"javascript函数防抖与节流","slug":"javascript函数防抖与节流","date":"2021-01-04T18:03:33.000Z","updated":"2022-10-25T14:41:49.323Z","comments":true,"path":"2021/01/05/articles/2/","link":"","permalink":"https://blog.rexhang.com/2021/01/05/articles/2/","excerpt":"","text":"概念和例子函数防抖(debounce) 在事件被触发n秒后再执行回调，如果在这n秒内又被触发，则重新计时。 12345678910// 模拟一段ajax请求function ajax(content) &#123; console.log(&#x27;ajax request &#x27; + content)&#125;let inputa = document.getElementById(&#x27;unDebounce&#x27;)inputa.addEventListener(&#x27;keyup&#x27;, function (e) &#123; ajax(e.target.value)&#125;) 运行效果如图: 可以看到，我们只要按下键盘，就会触发这次ajax请求。不仅从资源上来说是很浪费的行为，而且实际应用中，用户也是输出完整的字符后，才会请求。下面我们优化一下： 1234567891011121314151617181920212223// 模拟一段ajax请求function ajax(content) &#123; console.log(&#x27;ajax request &#x27; + content)&#125;function debounce(fun, delay) &#123; return function (args) &#123; let that = this let _args = args clearTimeout(fun.id) fun.id = setTimeout(function () &#123; fun.call(that, _args) &#125;, delay) &#125;&#125; let inputb = document.getElementById(&#x27;debounce&#x27;)let debounceAjax = debounce(ajax, 500)inputb.addEventListener(&#x27;keyup&#x27;, function (e) &#123; debounceAjax(e.target.value)&#125;) 运行效果如图: 可以看到，我们加入了防抖以后，当你在频繁的输入时，并不会发送请求，只有当你在指定间隔内没有输入时，才会执行函数。如果停止输入但是在指定间隔内又输入，会重新触发计时。 个人理解 函数防抖就是法师发技能的时候要读条，技能读条没完再按技能就会重新读条。 函数节流(throttle) 规定在一个单位时间内，只能触发一次函数。如果这个单位时间内触发多次函数，只有一次生效。 看代码: 12345678910111213141516171819202122232425function throttle(fun, delay) &#123; let last, deferTimer return function (args) &#123; let that = this let _args = arguments let now = +new Date() if (last &amp;&amp; now &lt; last + delay) &#123; clearTimeout(deferTimer) deferTimer = setTimeout(function () &#123; last = now fun.apply(that, _args) &#125;, delay) &#125;else &#123; last = now fun.apply(that,_args) &#125; &#125;&#125;let throttleAjax = throttle(ajax, 1000)let inputc = document.getElementById(&#x27;throttle&#x27;)inputc.addEventListener(&#x27;keyup&#x27;, function(e) &#123; throttleAjax(e.target.value)&#125;) 看一下运行结果: 可以看到，我们在不断输入时，ajax会按照我们设定的时间，每1s执行一次。 个人理解 函数节流就是fps游戏的射速，就算一直按着鼠标射击，也只会在规定射速内射出子弹。 总结 函数防抖和函数节流都是防止某一时间频繁触发，但是这两兄弟之间的原理却不一样。 函数防抖是某一段时间内只执行一次，而函数节流是间隔时间执行。 结合应用场景 防抖(debounce) search搜索联想，用户在不断输入值时，用防抖来节约请求资源。 window触发resize的时候，不断的调整浏览器窗口大小会不断的触发这个事件，用防抖来让其只触发一次 节流（throttle） 鼠标不断点击触发，mousedown(单位时间内只触发一次) 监听滚动事件，比如是否滑到底部自动加载更多，用throttle来判断","categories":[{"name":"大前端","slug":"大前端","permalink":"https://blog.rexhang.com/categories/%E5%A4%A7%E5%89%8D%E7%AB%AF/"},{"name":"面试经","slug":"大前端/面试经","permalink":"https://blog.rexhang.com/categories/%E5%A4%A7%E5%89%8D%E7%AB%AF/%E9%9D%A2%E8%AF%95%E7%BB%8F/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://blog.rexhang.com/tags/javascript/"}]},{"title":"如何创建一个TC的免费托管服务","slug":"如何创建一个TC的免费托管服务","date":"2021-01-04T17:06:21.000Z","updated":"2022-10-25T14:41:49.324Z","comments":true,"path":"2021/01/05/articles/1/","link":"","permalink":"https://blog.rexhang.com/2021/01/05/articles/1/","excerpt":"","text":"首先&nbsp;&nbsp;&nbsp;&nbsp;需要先全局安装cli, 本地预先安装好nodejs以及git 1$ npm i -g @cloudbase/cli hexo-cli 然后&nbsp;&nbsp;&nbsp;&nbsp;初始化一个hexo项目目录 1$ hexo init 初始化完毕后, 启动服务本地编写文章 1$ hexo s 发布&nbsp;&nbsp;&nbsp;&nbsp;发布就很简单了，获取授权，生成静态代码，使用cli推送到远程托管 123$ cloudbase login$ hexo g$ cloudbase hosting deploy public -e [EnvID] tips 环境ID(EnvID)获取方法: 链接 创建环境指引: 链接","categories":[{"name":"腾讯云","slug":"腾讯云","permalink":"https://blog.rexhang.com/categories/%E8%85%BE%E8%AE%AF%E4%BA%91/"},{"name":"操作技巧","slug":"腾讯云/操作技巧","permalink":"https://blog.rexhang.com/categories/%E8%85%BE%E8%AE%AF%E4%BA%91/%E6%93%8D%E4%BD%9C%E6%8A%80%E5%B7%A7/"}],"tags":[{"name":"腾讯云","slug":"腾讯云","permalink":"https://blog.rexhang.com/tags/%E8%85%BE%E8%AE%AF%E4%BA%91/"}]}],"categories":[{"name":"面试经","slug":"面试经","permalink":"https://blog.rexhang.com/categories/%E9%9D%A2%E8%AF%95%E7%BB%8F/"},{"name":"前端","slug":"面试经/前端","permalink":"https://blog.rexhang.com/categories/%E9%9D%A2%E8%AF%95%E7%BB%8F/%E5%89%8D%E7%AB%AF/"},{"name":"JavaScript","slug":"面试经/前端/JavaScript","permalink":"https://blog.rexhang.com/categories/%E9%9D%A2%E8%AF%95%E7%BB%8F/%E5%89%8D%E7%AB%AF/JavaScript/"},{"name":"前端","slug":"前端","permalink":"https://blog.rexhang.com/categories/%E5%89%8D%E7%AB%AF/"},{"name":"开发工具","slug":"前端/开发工具","permalink":"https://blog.rexhang.com/categories/%E5%89%8D%E7%AB%AF/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"},{"name":"node","slug":"前端/开发工具/node","permalink":"https://blog.rexhang.com/categories/%E5%89%8D%E7%AB%AF/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/node/"},{"name":"大前端","slug":"大前端","permalink":"https://blog.rexhang.com/categories/%E5%A4%A7%E5%89%8D%E7%AB%AF/"},{"name":"css3","slug":"大前端/css3","permalink":"https://blog.rexhang.com/categories/%E5%A4%A7%E5%89%8D%E7%AB%AF/css3/"},{"name":"游戏引擎","slug":"大前端/游戏引擎","permalink":"https://blog.rexhang.com/categories/%E5%A4%A7%E5%89%8D%E7%AB%AF/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"效率","slug":"大前端/效率","permalink":"https://blog.rexhang.com/categories/%E5%A4%A7%E5%89%8D%E7%AB%AF/%E6%95%88%E7%8E%87/"},{"name":"前端开发","slug":"大前端/效率/前端开发","permalink":"https://blog.rexhang.com/categories/%E5%A4%A7%E5%89%8D%E7%AB%AF/%E6%95%88%E7%8E%87/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"},{"name":"图表","slug":"大前端/图表","permalink":"https://blog.rexhang.com/categories/%E5%A4%A7%E5%89%8D%E7%AB%AF/%E5%9B%BE%E8%A1%A8/"},{"name":"G2","slug":"大前端/图表/G2","permalink":"https://blog.rexhang.com/categories/%E5%A4%A7%E5%89%8D%E7%AB%AF/%E5%9B%BE%E8%A1%A8/G2/"},{"name":"面试经","slug":"大前端/面试经","permalink":"https://blog.rexhang.com/categories/%E5%A4%A7%E5%89%8D%E7%AB%AF/%E9%9D%A2%E8%AF%95%E7%BB%8F/"},{"name":"兼容性","slug":"大前端/兼容性","permalink":"https://blog.rexhang.com/categories/%E5%A4%A7%E5%89%8D%E7%AB%AF/%E5%85%BC%E5%AE%B9%E6%80%A7/"},{"name":"心得","slug":"大前端/兼容性/心得","permalink":"https://blog.rexhang.com/categories/%E5%A4%A7%E5%89%8D%E7%AB%AF/%E5%85%BC%E5%AE%B9%E6%80%A7/%E5%BF%83%E5%BE%97/"},{"name":"腾讯云","slug":"腾讯云","permalink":"https://blog.rexhang.com/categories/%E8%85%BE%E8%AE%AF%E4%BA%91/"},{"name":"操作技巧","slug":"腾讯云/操作技巧","permalink":"https://blog.rexhang.com/categories/%E8%85%BE%E8%AE%AF%E4%BA%91/%E6%93%8D%E4%BD%9C%E6%8A%80%E5%B7%A7/"}],"tags":[{"name":"面试经","slug":"面试经","permalink":"https://blog.rexhang.com/tags/%E9%9D%A2%E8%AF%95%E7%BB%8F/"},{"name":"前端","slug":"前端","permalink":"https://blog.rexhang.com/tags/%E5%89%8D%E7%AB%AF/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://blog.rexhang.com/tags/JavaScript/"},{"name":"开发工具","slug":"开发工具","permalink":"https://blog.rexhang.com/tags/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"},{"name":"devtools","slug":"devtools","permalink":"https://blog.rexhang.com/tags/devtools/"},{"name":"node","slug":"node","permalink":"https://blog.rexhang.com/tags/node/"},{"name":"css3","slug":"css3","permalink":"https://blog.rexhang.com/tags/css3/"},{"name":"mask","slug":"mask","permalink":"https://blog.rexhang.com/tags/mask/"},{"name":"遮罩","slug":"遮罩","permalink":"https://blog.rexhang.com/tags/%E9%81%AE%E7%BD%A9/"},{"name":"cocos2d","slug":"cocos2d","permalink":"https://blog.rexhang.com/tags/cocos2d/"},{"name":"CocosCreator","slug":"CocosCreator","permalink":"https://blog.rexhang.com/tags/CocosCreator/"},{"name":"游戏引擎","slug":"游戏引擎","permalink":"https://blog.rexhang.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"javascript","slug":"javascript","permalink":"https://blog.rexhang.com/tags/javascript/"},{"name":"javascript数组","slug":"javascript数组","permalink":"https://blog.rexhang.com/tags/javascript%E6%95%B0%E7%BB%84/"},{"name":"javascript字符串","slug":"javascript字符串","permalink":"https://blog.rexhang.com/tags/javascript%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"js小tips","slug":"js小tips","permalink":"https://blog.rexhang.com/tags/js%E5%B0%8Ftips/"},{"name":"js技巧","slug":"js技巧","permalink":"https://blog.rexhang.com/tags/js%E6%8A%80%E5%B7%A7/"},{"name":"React","slug":"React","permalink":"https://blog.rexhang.com/tags/React/"},{"name":"前端框架","slug":"前端框架","permalink":"https://blog.rexhang.com/tags/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/"},{"name":"前端多端开发兼容性","slug":"前端多端开发兼容性","permalink":"https://blog.rexhang.com/tags/%E5%89%8D%E7%AB%AF%E5%A4%9A%E7%AB%AF%E5%BC%80%E5%8F%91%E5%85%BC%E5%AE%B9%E6%80%A7/"},{"name":"ios","slug":"ios","permalink":"https://blog.rexhang.com/tags/ios/"},{"name":"macos","slug":"macos","permalink":"https://blog.rexhang.com/tags/macos/"},{"name":"apple","slug":"apple","permalink":"https://blog.rexhang.com/tags/apple/"},{"name":"苹果","slug":"苹果","permalink":"https://blog.rexhang.com/tags/%E8%8B%B9%E6%9E%9C/"},{"name":"Vue","slug":"Vue","permalink":"https://blog.rexhang.com/tags/Vue/"},{"name":"腾讯云","slug":"腾讯云","permalink":"https://blog.rexhang.com/tags/%E8%85%BE%E8%AE%AF%E4%BA%91/"}]}
=======
{"meta":{"title":"Rexhang的Blog","subtitle":"blog","description":"RexHang","author":"RexHang","url":"https://blog.rexhang.com","root":"/"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2022-09-30T07:24:47.449Z","updated":"2022-08-04T01:23:43.175Z","comments":false,"path":"/404.html","permalink":"https://blog.rexhang.com/404.html","excerpt":"","text":""},{"title":"关于","date":"2021-01-04T09:06:55.000Z","updated":"2022-08-04T01:23:43.177Z","comments":false,"path":"about/index.html","permalink":"https://blog.rexhang.com/about/index.html","excerpt":"","text":"Rexhang全身心致力于Web前端开发以及Nodejs、java等编程技术的研究包括javascript脚本，Jquery，Bootstrap，react，vue，angular等前端框架的研究，并不断完善自我争取更促进互联网与现实世界的更和谐并到更贴近的交互体验！"},{"title":"友情链接","date":"2022-09-30T07:24:47.447Z","updated":"2022-08-04T01:23:43.178Z","comments":false,"path":"links/index.html","permalink":"https://blog.rexhang.com/links/index.html","excerpt":"","text":""},{"title":"书单","date":"2022-09-30T07:24:47.445Z","updated":"2022-08-04T01:23:43.177Z","comments":false,"path":"books/index.html","permalink":"https://blog.rexhang.com/books/index.html","excerpt":"","text":""},{"title":"项目","date":"2022-09-30T07:24:47.435Z","updated":"2022-08-04T01:23:43.178Z","comments":false,"path":"repository/index.html","permalink":"https://blog.rexhang.com/repository/index.html","excerpt":"","text":""},{"title":"分类","date":"2022-09-30T07:24:47.450Z","updated":"2022-08-04T01:23:43.178Z","comments":false,"path":"categories/index.html","permalink":"https://blog.rexhang.com/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2022-09-30T07:24:47.446Z","updated":"2022-08-04T01:23:43.178Z","comments":false,"path":"tags/index.html","permalink":"https://blog.rexhang.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"使用mask实现视频弹幕人物遮罩过滤，就是牛逼","slug":"使用mask实现视频弹幕人物遮罩过滤，就是牛逼","date":"2022-09-30T08:17:28.000Z","updated":"2022-09-30T08:39:20.867Z","comments":true,"path":"2022/09/30/articles/2/","link":"","permalink":"https://blog.rexhang.com/2022/09/30/articles/2/","excerpt":"","text":"经常看一些LOL比赛直播的小伙伴，肯定都知道，在一些弹幕网站（Bilibili、虎牙）中，当人物与弹幕出现在一起的时候，弹幕会“巧妙”的躲到人物的下面，看着非常的智能。 简单的一个截图例子： 其实，这里是运用了 CSS 中的 mask 属性实现的。 mask 简单用法介绍 这里只简单介绍下 mask 的基本用法： 最基本，使用 mask 的方式是借助图片，类似这样： 12345&#123; /* Image values */ mask: url(mask.png); /* 使用位图来做遮罩 */ mask: url(masks.svg#star); /* 使用 SVG 图形中的形状来做遮罩 */&#125; 当然，使用图片的方式后文会再讲。借助图片的方式其实比较繁琐，因为我们首先还得准备相应的图片素材，除了图片，mask 还可以接受一个类似 background 的参数，也就是渐变。 类似如下使用方法： 123&#123; mask: linear-gradient(#000, transparent) /* 使用渐变来做遮罩 */&#125; 那该具体怎么使用呢？一个非常简单的例子，上述我们创造了一个从黑色到透明渐变色，我们将它运用到实际中，代码类似这样： 下面这样一张图片，叠加上一个从透明到黑色的渐变， 1234&#123; background: url(image.png) ; mask: linear-gradient(90deg, transparent, #fff);&#125; 应用了 mask 之后，就会变成这样： 这个 DEMO，可以先简单了解到 mask 的基本用法。 这里得到了使用 mask 最重要结论：添加了 mask 属性的元素，其内容会与 mask 表示的渐变的 transparent 的重叠部分，并且重叠部分将会变得透明。 值得注意的是，上面的渐变使用的是 linear-gradient(90deg, transparent, #fff)，这里的 #fff 纯色部分其实换成任意颜色都可以，不影响效果。 使用 mask 实现人物遮罩过滤 了解了 mask 的用法后，接下来，我们运用 mask，简单实现视频弹幕中，弹幕碰到人物，自动被隐藏过滤的例子。 首先，我简单的模拟了一个召唤师峡谷，以及一些基本的弹幕： 方便示意，这里使用了一张静态图，表示了召唤师峡谷的地图，并非真的视频，而弹幕则是一条一条的 &lt;p&gt; 元素，和实际情况一致。伪代码大概是这样： 123456789&lt;!-- 地图 --&gt;&lt;div class=&quot;g-map&quot;&gt;&lt;/div&gt;&lt;!-- 包裹所有弹幕的容器 --&gt;&lt;div class=&quot;g-barrage-container&quot;&gt; &lt;!-- 所有弹幕 --&gt; &lt;div class=&quot;g-barrage&quot;&gt;6666&lt;/div&gt; ... &lt;div class=&quot;g-barrage&quot;&gt;6666&lt;/div&gt;&lt;/div&gt; 为了模拟实际情况，我们再用一个 div 添加一个实际的人物，如果不做任何处理，其实就是我们看视频打开弹幕的感受，人物被视频所遮挡： 注意，这里我添加了一个人物亚索，并且用 animation 模拟了简单的运动，在运动的过程中，人物是被弹幕给遮挡住的。 接下来，就可以请出 mask 了。 我们利用 mask 制作一个 radial-gradient ，使得人物附近为 transparent，并且根据人物运动的 animation，给 mask 的 mask-position 也添加上相同的 animation 即可。最终可以得到这样的效果： 1234567891011.g-barrage-container &#123; position: absolute; mask: radial-gradient(circle at 100px 100px, transparent 60px, #fff 80px, #fff 100%); animation: mask 10s infinite alternate;&#125;@keyframes mask &#123; 100% &#123; mask-position: 85vw 0; &#125;&#125; 实际上就是给放置弹幕的容器，添加一个 mask 属性，把人物所在的位置标识出来，并且根据人物的运动不断的去变换这个 mask 即可。我们把 mask 换成 background，原理一看就懂。 把 mask 替换成 background 示意图： background 透明的地方，即 mask 中为 transparent 的部分，实际就是弹幕会被隐藏遮罩的部分，而其他白色部分，弹幕不会被隐藏，正是完美的利用了 mask 的特性。 其实这项技术和视频本身是无关的，我们只需要根据视频计算需要屏蔽掉弹幕的位置，得到相应的 mask 参数即可。如果去掉背景和运动的人物，只保留弹幕和 mask，是这样的： 需要明确的是，使用 mask，不是将弹幕部分给遮挡住，而是利用 mask，指定弹幕容器之下，哪些部分正常展示，哪些部分透明隐藏。 实际生产环境中的运用 当然，上面我们简单的还原了利用 mask 实现弹幕遮罩过滤的效果。但是实际情况比上述的场景复杂的多，因为人物英雄的位置是不确定的，每一刻都在变化。所以在实际生产环境中，mask 图片的参数，其实是由后端实时对视频进行处理计算出来的，然后传给前端，前端再进行渲染。 对于运用了这项技术的直播网站，我们可以审查元素，看到包裹弹幕的容器的 mask 属性，每时每刻都在发生变化： 返回回来的其实是一个 SVG 图片，大概长这个样子： 这样，根据视频人物的实时位置变化，不断计算新的 mask，再实时作用于弹幕容器之上，实现遮罩过滤。","categories":[{"name":"大前端","slug":"大前端","permalink":"https://blog.rexhang.com/categories/%E5%A4%A7%E5%89%8D%E7%AB%AF/"},{"name":"css3","slug":"大前端/css3","permalink":"https://blog.rexhang.com/categories/%E5%A4%A7%E5%89%8D%E7%AB%AF/css3/"}],"tags":[{"name":"css3","slug":"css3","permalink":"https://blog.rexhang.com/tags/css3/"},{"name":"mask","slug":"mask","permalink":"https://blog.rexhang.com/tags/mask/"},{"name":"遮罩","slug":"遮罩","permalink":"https://blog.rexhang.com/tags/%E9%81%AE%E7%BD%A9/"}]},{"title":"CocosCreator实现不规则区域点击","slug":"CocosCreator实现不规则区域点击","date":"2022-09-30T07:36:22.000Z","updated":"2022-09-30T08:14:27.914Z","comments":true,"path":"2022/09/30/articles/1/","link":"","permalink":"https://blog.rexhang.com/2022/09/30/articles/1/","excerpt":"","text":"一、问题背景在CocosCreator中，点击图片透明区域依然触发节点的点击事件。但在web开发中，可以使用Inkscape、SvgPathEditor等矢量图编辑器转为SVG，或者直接从figma中导出SVG，然后监听不规则图形事件。 以地图边界高亮为例：html 类似地图的不规则图形事件处理 123svg &#123; height: 50vw; &#125;path &#123; fill: #d3d3d3; transition: .6s fill; opacity: 0.6;&#125;path:hover &#123; fill: #eee;opacity: 0.6; &#125; 但CocosCreator中Sprite目前支持的格式为jpg和png，未直接支持SVG。 二、方案调研图像模板(image_stencil) mask 如何控制只让图像遮罩的可视区域响应点击 图像模板可以根据设置的透明度阈值，只有当模板像素的 alpha 值大于该阈值时，才会绘制内容。 但是该方式点击透明区域，依然会触发该节点的事件。 通过查看2.4.7版本 CCMask.js 的源码 ，可以看到在碰撞检测中，图像模板类型的mask的命中方式与矩形保持一致，只有椭圆才是单独检测，故该方式并不能解决问题。 123456789101112131415161718192021222324252627282930_hitTest (cameraPt) &#123; let node = this.node; let size = node.getContentSize(), w = size.width, h = size.height, testPt = _vec2_temp; node._updateWorldMatrix(); // If scale is 0, it can&#x27;t be hit. if (!Mat4.invert(_mat4_temp, node._worldMatrix)) &#123; return false; &#125; Vec2.transformMat4(testPt, cameraPt, _mat4_temp); testPt.x += node._anchorPoint.x * w; testPt.y += node._anchorPoint.y * h; let result = false; if (this.type === MaskType.RECT || this.type === MaskType.IMAGE_STENCIL) &#123; result = testPt.x &gt;= 0 &amp;&amp; testPt.y &gt;= 0 &amp;&amp; testPt.x &lt;= w &amp;&amp; testPt.y &lt;= h; &#125; else if (this.type === MaskType.ELLIPSE) &#123; let rx = w / 2, ry = h / 2; let px = testPt.x - 0.5 * w, py = testPt.y - 0.5 * h; result = px * px / (rx * rx) + py * py / (ry * ry) &lt; 1; &#125; if (this.inverted) &#123; result = !result; &#125; return result;&#125; 多边形mask 1.Creator | 编辑器中可操作顶点的多边形遮罩2.【组件分享】使用Mask+Graphic魔改的多边形遮罩组件3.[ Mask + PolygonCollider 简易自定义多边形遮罩制作 ] 沿着mask的思路，在论坛上找到了多边形mask的实现方式。大致都是在CCMask源码的基础上，增加多边形的节点添加和碰撞检测，其中一位作者实现的组件非常吸睛，GitHub上共有400余Star，目前cocos商店已有该组件。感兴趣可阅读源码。 效果如下： 比较有意思是其碰撞检测（点是否在多边形内），采用射线法判断。 定义：从目标点出发引一条射线，看这条射线和多边形所有边的交点数目。如果有奇数个交点，则说明在内部，如果有偶数个交点，则说明在外部。 具体步骤：将测试点的Y坐标与多边形的每一个点进行比较，会得到一个测试点所在的行与多边形边的交点的列表。在下图的这个例子中有8条边与测试点所在的行相交，而有6条边没有相交。如果测试点的两边点的个数都是奇数个则该测试点在多边形内，否则在多边形外。在这个例子中测试点的左边有5个交点，右边有三个交点，它们都是奇数，所以点在多边形内。 算法实现： 12345678910111213141516171819202122232425isInPolygon(checkPoint: cc.Vec2, polygonPoints: cc.Vec2[]) &#123; let counter = 0, i: number, xinters: number; let p1: cc.Vec2, p2: cc.Vec2; let pointCount = polygonPoints.length; p1 = polygonPoints[0]; for (i = 1; i &lt;= pointCount; i++) &#123; p2 = polygonPoints[i % pointCount]; if ( checkPoint.x &gt; Math.min(p1.x, p2.x) &amp;&amp; checkPoint.x &lt;= Math.max(p1.x, p2.x) ) &#123; if (checkPoint.y &lt;= Math.max(p1.y, p2.y)) &#123; if (p1.x != p2.x) &#123; xinters = (checkPoint.x - p1.x) * (p2.y - p1.y) / (p2.x - p1.x) + p1.y; if (p1.y == p2.y || checkPoint.y &lt;= xinters) &#123; counter++; &#125; &#125; &#125; &#125; p1 = p2; &#125; return (counter &amp; 1) !== 0;&#125; 多边形mesh 多边形裁剪图片(非mask,使用mesh)，新增 gizmo 支持https://github.com/baiyuwubing/cocos-creator-examples/tree/master/meshTexture 2年前开发，已停止维护，使用不佳，节点关联顺序容易紊乱。根据作者的描述，可以解决mask过多带来性能影响。 像素点计算 creator 2.4.8中获取像素信息 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768const getPixelData = (node: cc.Node, x: number, y: number) =&gt; &#123; const pixelsData = getPixelsData(node); const startIndex = node.width * 4 * Math.floor(node.height - y) + 4 * Math.floor(x); const pixelData = pixelsData.slice(startIndex, startIndex + 4); return pixelData;&#125;;const isPixelTransparent = (node: cc.Node, x: number, y: number) =&gt; &#123; const pixelData = getPixelData(node, x, y); return pixelData[3] === 0;&#125;;const getPixelsData = (node: cc.Node) =&gt; &#123; if (!cc.isValid(node)) &#123; return null; &#125; // 节点宽度 const width = Math.floor(node.width); const height = Math.floor(node.height); // 创建临时摄像机用于渲染目标节点 const cameraNode = new cc.Node(); cameraNode.parent = node; const camera = cameraNode.addComponent(cc.Camera); // eslint-disable-next-line no-bitwise camera.clearFlags |= cc.Camera.ClearFlags.COLOR; camera.backgroundColor = cc.color(0, 0, 0, 0); camera.zoomRatio = cc.winSize.height / height; // 将节点渲染到 RenderTexture中 const renderTexture = new cc.RenderTexture(); renderTexture.initWithSize( width, height, cc.RenderTexture.DepthStencilFormat.RB_FMT_S8 ); camera.targetTexture = renderTexture; camera.render(node); const pixelData = renderTexture.readPixels(); return pixelData;&#125;;/** 点击事件是否合法，非透明像素 */ isValidTouch(e: cc.Event.EventTouch) &#123; const touchLocation = e.touch.getLocation(); /** 相对节点左下角的相对坐标，即图片内的坐标 */ const locationInNode = this.node.convertToNodeSpaceAR(touchLocation); /** 非本节点内 透传 */ if (!this.node.getBoundingBoxToWorld().contains(touchLocation)) &#123; this.setSwallowTouches(false); return false; &#125; const &#123; anchorX, anchorY, width, height &#125; = this.node; const x = locationInNode.x + anchorX * width; const y = -(locationInNode.y - anchorY * height); const isValid = !isPixelTransparent(this.node, x, y); this.setSwallowTouches(isValid); return isValid; &#125; /** 设置是否阻止点击事件透传 */ setSwallowTouches(bool: boolean) &#123; (this.node as any)._touchListener.setSwallowTouches(bool); &#125; 方案对比 方案名称 优点 缺点 图像模板mask - 适合图片快速裁剪渲染 - 不满足要求 多边形mask - 适用于多边形定制化裁剪 - 参考文章 [@]Mask组件多边形方案性影响手机Web性能。多边形mask使用过多，低端机性能下降严重（碰撞检测占主要原因） - 手动描边 多边形mesh - 根据作者描述，比mask性能更优 - 手动描边 像素点计算 - 颗粒度精细，能精确到像素点 - 无需特殊处理图片 - 图片过大时，可能带来性能问题 可能的最佳实践？在论坛中看到有个大佬在尝试svg拓展 Creator + SVG 解析渲染扩展组件 ，已上架cocos商店【价值80¥】","categories":[{"name":"大前端","slug":"大前端","permalink":"https://blog.rexhang.com/categories/%E5%A4%A7%E5%89%8D%E7%AB%AF/"},{"name":"游戏引擎","slug":"大前端/游戏引擎","permalink":"https://blog.rexhang.com/categories/%E5%A4%A7%E5%89%8D%E7%AB%AF/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"}],"tags":[{"name":"cocos2d","slug":"cocos2d","permalink":"https://blog.rexhang.com/tags/cocos2d/"},{"name":"CocosCreator","slug":"CocosCreator","permalink":"https://blog.rexhang.com/tags/CocosCreator/"},{"name":"游戏引擎","slug":"游戏引擎","permalink":"https://blog.rexhang.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"}]},{"title":"JS中非常实用的『一行代码』","slug":"JS中非常实用的『一行代码』","date":"2022-08-04T04:03:28.000Z","updated":"2022-09-30T07:11:33.541Z","comments":true,"path":"2022/08/04/articles/1/","link":"","permalink":"https://blog.rexhang.com/2022/08/04/articles/1/","excerpt":"","text":"导读: 最近在国外技术社区看到了一些关于 一行代码 的文章📄，感觉很有意思，就整理了下来并且自己额外补充了一部分分享给大家🤜，希望对各位读者们有所帮助💕。 最近一次更新时间 2022-08-21 12:00:15 这些方法使用到了一些API，简化了操作，但是有些方法写一行属实不太优雅，所以这里主要还是学习API的使用小技巧。 一、日期处理 检查日期是否有效该方法用于检测给出的日期是否有效 123const isDateValid = (...val) =&gt; !Number.isNaN( new Date(...val).valueOf() );// how to useisDateValid(&quot;December 17, 1995 03:24:00&quot;); // =&gt; true 计算两个日期之间的间隔该方法用于计算两个日期之间的间隔时间(day) 123const dayDif = (date1, date2) =&gt; Math.ceil( Math.abs( date1.getTime() - date2.getTime() ) / 86400000);// how to usedayDif(new Date(&quot;2022-08-01&quot;), new Date(&quot;2022-08-04&quot;)); // =&gt; 3 查找日期位于一年中的第几天该方法用于检测给出的日期位于今年的第几天 1234const dayOfYear = date =&gt; Math.floor( ( date - new Date(date.getFullYear(), 0, 0) ) / 1000 / 60 / 60 / 24 )// how to usedayOfYear(new Date(&quot;2022-08-01&quot;)); // =&gt; 213dayOfYear(new Date(&quot;2022-01-01&quot;)); // =&gt; 1 时间格式化该方法用于转换时间 12345const timeFromDate = date =&gt; date.toTimeString().slice(0, 8);// how to usetimeFromDate(new Date(2022, 08, 04, 12, 30, 0)); // =&gt; &#x27;12:30:00&#x27;timeFromDate(new Date(2022, 08, 04, 12, 30, 60)); // =&gt; &#x27;12:31:00&#x27;timeFromDate(new Date()); // =&gt; 此刻的时间 二、字符串处理 字符串首字母大写该方法用于将英文字符串的首字母大写处理 123const capitalize = str =&gt; str.charAt(0).toUpperCase() + str.slice(1);// how to usecapitalize(&quot;hello world&quot;); // =&gt; Hello world 翻转字符串该方法用于将一个字符串进行翻转操作并返回翻转后的内容 123const reverse = str =&gt; str.split(&#x27;&#x27;).reverse().join(&#x27;&#x27;);// how to usereverse(&quot;hello world&quot;); // =&gt; dlrow olleh 随机字符串该方法用于生成一个随机的字符串并返回 123const randomString = () =&gt; Math.random().toString(36).slice(2);// how to userandomString(); // =&gt; anyString 去除字符串中的HTML该方法用于去除字符串中的HTML元素 123const stripHtml = html =&gt; (new DOMParser().parseFromString(html, &#x27;text/html&#x27;)).body.textContent || &#x27;&#x27;;// how to usestripHtml(&quot;&lt;div&gt;Beware of the missing closing tag&lt;/div&gt;hello world&lt;i&gt;!&lt;i&gt;&quot;); // =&gt; &#x27;Beware of the missing closing taghello world!&#x27; 获取URL的search参数并json化该方法用于获取当前访问的URL中的search内容并解析成JSON键值对形式 123const urlParams = search =&gt; Object.fromEntries(new URLSearchParams(search));// how to useurlParams(location.search); // =&gt; &#123; id: &#x27;1&#x27;, name: &#x27;rexhang&#x27; &#125; 去除数字之外的所有字符该方法用于去除数字之外的所有字符 1234const toNumber = str =&gt; Number(str.replace(/\\D/g, &#x27;&#x27;));// how to useconst str = &#x27;hello 123 is god 456&#x27;;toNumber(str); // =&gt; 123456 空值(null | undefined)合并运算符该方法用于更简短的定义空值情况下的时候, null 或者 undefined 会认定为判断范围， 其余认为正常赋值 1234567891011121314const aa = isA ?? false;const bb = isB ?? &#x27;hello&#x27;;const cc = isC ?? &#x27;ok&#x27;;const dd = isD ?? &#x27;done&#x27;;// how to useconst isA = null;const isB = &#x27;&#x27;;const isC = undefined;const isD = false;const aa = isA ?? &#x27;...&#x27;;const bb = isB ?? &#x27;hello&#x27;;const cc = isC ?? &#x27;ok&#x27;;const dd = isD ?? &#x27;done&#x27;;console.log(aa, bb, cc, dd); 二、数组处理 从数组中移除重复项该方法用于从数组中移除重复项 123const removeDuplicates = arr =&gt; [...new Set(arr)];// how to useremoveDuplicates([1, 1, 3, 4, 1, 5]); // =&gt; [1, 3, 4, 5] 打乱数组顺序该方法用于打乱数组顺序，随机取random后的数组 1234const randomArr = arr =&gt; arr.sort(() =&gt; 0.5 - Math.random());// how to useconst arr = [&#x27;🙂&#x27;, &#x27;66&#x27;, true, 11, &#123;name: &#x27;rexhang&#x27;&#125;];console.log(randomArr(arr)); // random arr, eg: [&#x27;66&#x27;, 11, true, &#123;name: &#x27;rexhang&#x27;&#125;, &#x27;🙂&#x27;]; 从数组中随机去一个值该方法用于从数组中随机去一个值 1234const takeARandomItem = arr =&gt; arr[Math.floor(Math.random() * arr.length)]// how to useconst eles = [&#x27;🙂&#x27;, &#x27;66&#x27;, true, 11, &#123;name: &#x27;rexhang&#x27;&#125;];console.log(takeARandomItem(eles)); // random item of arr, eg: &#x27;🙂&#x27;; 从数组中取出最大/小值(仅限数字|字符串数字)该方法用于从数组中取出最大/小值(仅限数字|字符串数字) 1234567const getMaxMinValue = arr =&gt; (&#123; max: Math.max(...arr), min: Math.min(...arr),&#125;)// how to useconst items = [11, 12, 11, 1, &#x27;0&#x27;];console.log(getMaxMinValue(items)); // &#123; max: 12, min: 0 &#125; 判断数组是否为空该方法用于判断数组是否为空 12345const isNotEmpty = arr =&gt; Array.isArray(arr) &amp;&amp; !!arr.length;// how to useisNotEmpty([1, 3]); // =&gt; trueisNotEmpty([]); // =&gt; trueisNotEmpty(&quot;[1, 3]&quot;); // =&gt; 非数组返回false 长期且持续更新中…","categories":[{"name":"大前端","slug":"大前端","permalink":"https://blog.rexhang.com/categories/%E5%A4%A7%E5%89%8D%E7%AB%AF/"},{"name":"效率","slug":"大前端/效率","permalink":"https://blog.rexhang.com/categories/%E5%A4%A7%E5%89%8D%E7%AB%AF/%E6%95%88%E7%8E%87/"},{"name":"前端开发","slug":"大前端/效率/前端开发","permalink":"https://blog.rexhang.com/categories/%E5%A4%A7%E5%89%8D%E7%AB%AF/%E6%95%88%E7%8E%87/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://blog.rexhang.com/tags/javascript/"},{"name":"javascript数组","slug":"javascript数组","permalink":"https://blog.rexhang.com/tags/javascript%E6%95%B0%E7%BB%84/"},{"name":"javascript字符串","slug":"javascript字符串","permalink":"https://blog.rexhang.com/tags/javascript%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"js小tips","slug":"js小tips","permalink":"https://blog.rexhang.com/tags/js%E5%B0%8Ftips/"},{"name":"js技巧","slug":"js技巧","permalink":"https://blog.rexhang.com/tags/js%E6%8A%80%E5%B7%A7/"}]},{"title":"一套面向常规统计图表，以数据驱动的高交互可视化图形语法 - G2","slug":"G2","date":"2022-08-04T01:27:08.000Z","updated":"2022-08-04T07:20:40.178Z","comments":true,"path":"2022/08/04/articles/2/","link":"","permalink":"https://blog.rexhang.com/2022/08/04/articles/2/","excerpt":"","text":"G2 一套面向常规统计图表，以数据驱动的高交互可视化图形语法。 网站 • 教程文档 • 博客 • G2Plot G2 是一套基于图形语法理论的可视化底层引擎，以数据驱动，提供图形语法与交互语法，具有高度的易用性和扩展性。使用 G2，你可以无需关注图表各种繁琐的实现细节，一条语句即可使用 Canvas 或 SVG 构建出各种各样的可交互的统计图表。 📺 线上示例 ✨ 特性 💯 完善的图形语法：数据到图形的映射，能够绘制出所有的图表。 🤩 全新的交互语法：通过触发和反馈机制可以组合出各种交互行为，对数据进行探索。 🦍 强大的 View 模块：可支持开发个性化的数据多维分析图形。 👬 双引擎渲染：Canvas 或 SVG 任意切换。 💄 可视化组件体系：面向交互、体验优雅。 🛡 全面拥抱 TypeScript：提供完整的类型定义文件。 📦 安装1$ npm install @antv/g2 🔨 快速上手 在绘图前我们需要为 G2 准备一个 DOM 容器： 1&lt;div id=&quot;c1&quot;&gt;&lt;/div&gt; 12345678910111213141516171819202122232425import &#123; Chart &#125; from &#x27;@antv/g2&#x27;;const data = [ &#123; genre: &#x27;Sports&#x27;, sold: 275 &#125;, &#123; genre: &#x27;Strategy&#x27;, sold: 115 &#125;, &#123; genre: &#x27;Action&#x27;, sold: 120 &#125;, &#123; genre: &#x27;Shooter&#x27;, sold: 350 &#125;, &#123; genre: &#x27;Other&#x27;, sold: 150 &#125;,];// Step 1: 创建 Chart 对象const chart = new Chart(&#123; container: &#x27;c1&#x27;, // 指定图表容器 ID width: 600, // 指定图表宽度 height: 300, // 指定图表高度&#125;);// Step 2: 载入数据源chart.data(data);// Step 3: 创建图形语法，绘制柱状图chart.interval().position(&#x27;genre*sold&#x27;);// Step 4: 渲染图表chart.render(); ⌨️ 本地开发1234567891011121314# 安装依赖$ npm install# 运行测试用例$ npm run test# 打开 electron 运行测试用例，监听文件变化构建$ npm run test-live# 运行 CI$ npm run ci# 运行网站$ npm start 🏷️ 版本 v3.5.x: https://github.com/antvis/G2/tree/v3.5.x v4.0.x: https://github.com/antvis/G2/tree/v4.0.x 你也可以在业务中使用基于 G2 封装的常规统计图表 G2Plot ，可以使用配置的方式快速生成一个通用图表，降低开发者的使用成本。","categories":[{"name":"大前端","slug":"大前端","permalink":"https://blog.rexhang.com/categories/%E5%A4%A7%E5%89%8D%E7%AB%AF/"},{"name":"图表","slug":"大前端/图表","permalink":"https://blog.rexhang.com/categories/%E5%A4%A7%E5%89%8D%E7%AB%AF/%E5%9B%BE%E8%A1%A8/"},{"name":"G2","slug":"大前端/图表/G2","permalink":"https://blog.rexhang.com/categories/%E5%A4%A7%E5%89%8D%E7%AB%AF/%E5%9B%BE%E8%A1%A8/G2/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://blog.rexhang.com/tags/javascript/"}]},{"title":"React代码整洁优化实践","slug":"React代码整洁优化实践","date":"2022-08-02T14:16:48.000Z","updated":"2022-08-04T07:20:07.916Z","comments":true,"path":"2022/08/02/articles/1/","link":"","permalink":"https://blog.rexhang.com/2022/08/02/articles/1/","excerpt":"","text":"整洁的代码不仅仅是正常运行的代码，更是要求易于阅读、简单易懂、组织整齐。在本文中，我会们将示例几种代码整洁案例。在阅读这些建议时，要记住这些只是建议！ 如果你不同意它们中的任何一个，那也完全没关系。以下这些实践，个人觉得对我自己编写 React 代码很有帮助。1. 仅对一个条件进行渲染 如果需要在条件为true时渲染某些内容，而在条件为false时不渲染任何内容，不推荐使用三元表达式，改用与运算符&amp;&amp;，它可以方便地条件渲染一个元素。 优化前: 1234567891011import React from &quot;react&quot;;export const TopNav = (props: &#123; showSearch?: boolean &#125;) =&gt; &#123; const &#123; showSearch = false &#125; = props; return ( &lt;div className=&quot;doc-head&quot;&gt; &#123;/* 三元表达式进行条件渲染 */&#125; &#123;showSearch ? &lt;SearchBox placeholder=&quot;输入关键词搜索&quot; onSearch=&#123;(keyword) =&gt; window.location.assign(`/privatecloud/search?q=$&#123;keyword&#125;`)&#125; style=&#123;&#123; marginRight: 100 &#125;&#125; /&gt; : null&#125; &lt;/div&gt; );&#125;; 优化后: 1234567891011import React from &quot;react&quot;;export const TopNav = (props: &#123; showSearch?: boolean &#125;) =&gt; &#123; const &#123; showSearch = false &#125; = props; return ( &lt;div className=&quot;doc-head&quot;&gt; &#123;/* 与运算符&amp;&amp;进行条件渲染 */&#125; &#123;showSearch &amp;&amp; &lt;SearchBox placeholder=&quot;输入关键词搜索&quot; onSearch=&#123;(keyword) =&gt; window.location.assign(`/privatecloud/search?q=$&#123;keyword&#125;`)&#125; style=&#123;&#123; marginRight: 100 &#125;&#125; /&gt;&#125; &lt;/div&gt; );&#125;; 2. 每一个条件都可能进行渲染 如果需要在条件为 true 时渲染某些内容，而在条件为 false 时渲染其他内容。推荐使用三元表达式！ 优化前: 123&#123;/* 条件 True 和 False 都要渲染内容 */&#125;&#123; good &amp;&amp; &lt;p&gt;Good!&lt;/p&gt; &#125;&#123; !good &amp;&amp; &lt;p&gt;&lt;b&gt;Not Good!&lt;b&gt;&lt;/p&gt; &#125; 优化后: 123456789101112&#123; /* 三元表达式 */&#125;&#123; good ? ( &lt;p&gt;Good!&lt;/p&gt; ) : ( &lt;p&gt; &lt;b&gt;Not Good!&lt;/b&gt; &lt;/p&gt; );&#125; 3. 组件 Boolean props 传参 组件接收参数的属性值为布尔类型, 并且传入 true 值时，可以省略填写值，并不会影响组件内取到 true 值 优化前: 12&lt;Hello disabled=&#123;true&#125; /&gt;&lt;Hello disabled=&#123;false&#125; /&gt; 优化后: 12&lt;Hello disabled /&gt;&lt;Hello disabled=&#123;false&#125; /&gt; 4. 组件 String props 传参 组件 Props 值为 String, 推荐使用双引号包裹，不使用花括号或反引号。 优化前: 123&lt;Hello personName=&#123;&quot;Jim&quot;&#125; /&gt;&lt;Hello personName=&#123;&#x27;Tom&#x27;&#125; /&gt;&lt;Hello personName=&#123;`Ken`&#125; /&gt; 优化后: 123&lt;Hello personName=&quot;Jim&quot; /&gt;&lt;Hello personName=&quot;Tom&quot; /&gt;&lt;Hello personName=&quot;Ken&quot; /&gt; 5. Event handler functions 如果一个事件函数只接受一个参数，不需要传入匿名函数：onChange={ e =&gt; handleChange(e) }，推荐这种写法(直接等于函数)： onChange={ handleChange } 。 优化前: 1234const handleChange = (e) =&gt; &#123; console.info(e.target.value);&#125;;&lt;input id=&quot;name&quot; value=&#123;inputValue&#125; onChange=&#123;(e) =&gt; handleChange(e)&#125; /&gt;; 优化后: 1234567const handleChange = (e) =&gt; &#123; console.info(e.target.value);&#125;;&#123; /* 事件只有一个参数，不需要匿名函数*/&#125;&lt;input id=&quot;name&quot; value=&#123;inputValue&#125; onChange=&#123;handleChange&#125; /&gt;; 6. components as props 将组件作为参数传递给另一个组件时，如果该组件不接受任何参数，则无需将该传递的组件包装在函数中。 优化前: 12&lt;Hello ClockComponent=&#123;() =&gt; &lt;Clock timestamp=&#123;new Date().getTime()&#125; /&gt;&#125; /&gt;&lt;Hello ClockComponent=&#123;() =&gt; &lt;Clock /&gt;&#125; /&gt; 优化后: 12&lt;Hello ClockComponent=&#123;() =&gt; &lt;Clock timestamp=&#123;new Date().getTime()&#125; /&gt;&#125; /&gt;&lt;Hello ClockComponent=&#123;Clock&#125; /&gt; 7. 设置 state 依赖先前的 state 如果新 state 依赖于先前 state，则始终将 state 设置为先前 state 的函数。可以批处理 React 状态更新。 优化前: 1234567891011121314151617181920212223import React, &#123; useState &#125; from &quot;react&quot;;export const Hello = () =&gt; &#123; const [cout, setCount] = useState &lt; number &gt; 0; // 依赖先前/上一个的state值 (异步调用) const handleClick = (e) =&gt; setCount(cout + 1); // 期望执行2次 首次执行理应 cout = 2 const handleClickRunDouble = (e) =&gt; &#123; // 执行第二个handleClick执行的时候第一个count设置未完成(异步的)，所以还是 count = 0 = 0 + 1 = 1 因此 首次的点击得到的值 = 1 而并非2, 如果需要实现2 那么就得利用setState的批处理方式 handleClick(e); handleClick(e); &#125;; return ( &lt;div&gt; &lt;button onclick=&#123;handleClick&#125;&gt;click here&lt;/button&gt; &lt;span&gt;&#123;count&#125;&lt;/span&gt; &lt;button onclick=&#123;handleClickRunDouble&#125;&gt;click here &amp; lunch 2 times&lt;/button&gt; &lt;/div&gt; );&#125;; 优化后: 123456789101112131415161718192021222324import React, &#123; useState &#125; from &quot;react&quot;;export const Hello = () =&gt; &#123; const [cout, setCount] = useState &lt; number &gt; 0; &#123; /* 将set调用设置为批处理模式 使用set方法提供的callback内的数值 */ &#125; const handleClick = (e) =&gt; setCount((c) =&gt; c + 1); // 首次调用后会输出最新的值 count = 2; const handleClickRunDouble = (e) =&gt; &#123; handleClick(e); handleClick(e); &#125;; return ( &lt;div&gt; &lt;button onclick=&#123;handleClick&#125;&gt;click here&lt;/button&gt; &lt;span&gt;&#123;count&#125;&lt;/span&gt; &lt;button onclick=&#123;handleClickRunDouble&#125;&gt;click here &amp; lunch 2 times&lt;/button&gt; &lt;/div&gt; );&#125;; 以上 7 个就是我推荐和总结的几个React代码整洁优化实践 。 最后，祝大家开发愉快！","categories":[{"name":"大前端","slug":"大前端","permalink":"https://blog.rexhang.com/categories/%E5%A4%A7%E5%89%8D%E7%AB%AF/"},{"name":"面试经","slug":"大前端/面试经","permalink":"https://blog.rexhang.com/categories/%E5%A4%A7%E5%89%8D%E7%AB%AF/%E9%9D%A2%E8%AF%95%E7%BB%8F/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://blog.rexhang.com/tags/javascript/"},{"name":"React","slug":"React","permalink":"https://blog.rexhang.com/tags/React/"},{"name":"前端框架","slug":"前端框架","permalink":"https://blog.rexhang.com/tags/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/"}]},{"title":"数组的一些常用方法及使用区别","slug":"数组的一些常用方法及使用区别","date":"2021-05-13T16:22:22.000Z","updated":"2022-08-04T01:23:43.177Z","comments":true,"path":"2021/05/14/articles/1/","link":"","permalink":"https://blog.rexhang.com/2021/05/14/articles/1/","excerpt":"","text":"一、前言push pop unshift shift splice slice split join 方法及使用区别 二、示例1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162// push pop unshift shift splice slice split joinconst arr = [1, 2, 3, 4];// push、unshift向数组的 尾部/头部 添加若干元素，并返回 数组的 新长度const a = arr.push(&#x27;X&#x27;, &#x27;Y&#x27;, &#x27;Z&#x27;); // -&gt; new lengthconst b = arr.unshift(&#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;); // -&gt; new lengthconsole.log(a);console.log(b);console.log(arr);// pop、shift向数组的 尾部/头部 删除一个元素 并返回 数组中 被删除的元素const c = arr.pop(); // -&gt; last itemconst d = arr.shift(); // -&gt; first itemconsole.log(c);console.log(d);const e = arr.push();const f = [].pop();const g = [].shift();console.log(e);console.log(f);console.log(g);// splice 向/从数组中添加/删除项目，然后返回被删除的项目集合[?1, ?2]。 -1开始反方向删除(末尾第一个) 即便是负数 也都是从左到右删除单位const h = arr.splice(-2, 2, &#x27;rex&#x27;, &#x27;hang&#x27;, &#x27;gu&#x27;);console.log(h);// slice 只对数组范围做截取 并返回 截取的内容const i = arr.slice(1, -2); // 区间 -&gt; (?] 不包含末尾console.log(i);// split 用于 把一个有标记的字符串 分割成 标准数组const j = &#x27;a|b|c&#x27;.split(&#x27;|&#x27;);console.log(j);// join 用于 把一个标准数组 变成 固定符号分隔的 字符串const k = [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;].join(&#x27;|&#x27;);console.log(k);console.log(arr); 控制台输出内容如图所示: 看完上述例子后，我想大家都应该大致明白了这些方法的使用区别。","categories":[{"name":"大前端","slug":"大前端","permalink":"https://blog.rexhang.com/categories/%E5%A4%A7%E5%89%8D%E7%AB%AF/"},{"name":"面试经","slug":"大前端/面试经","permalink":"https://blog.rexhang.com/categories/%E5%A4%A7%E5%89%8D%E7%AB%AF/%E9%9D%A2%E8%AF%95%E7%BB%8F/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://blog.rexhang.com/tags/javascript/"},{"name":"javascript数组","slug":"javascript数组","permalink":"https://blog.rexhang.com/tags/javascript%E6%95%B0%E7%BB%84/"}]},{"title":"探讨下前端开发过程中在苹果系统下的一些兼容性小坑以及解决方案","slug":"探讨下前端开发过程中在苹果系统下的一些兼容性小坑以及解决方案","date":"2021-01-12T13:20:30.000Z","updated":"2022-08-04T01:23:43.177Z","comments":true,"path":"2021/01/12/articles/1/","link":"","permalink":"https://blog.rexhang.com/2021/01/12/articles/1/","excerpt":"","text":"导读: 本文会长期更新，目前仅写出已收集并且经过验证的案例分享🙉 大家在做前端开发过程中势必会和H5打交道&lt;这里指的H5仅表示在苹果系统下运行的H5&gt;，在原本不应该出现的异常行为经常会搞得稀里糊涂，遂去各类搜索引擎搜索结局方案，本文故此摘录各类表现在苹果环境下的开发“异常行为”，并且给出大概可行的兼容方案来帮助大家单项搜集的烦恼 可能存在兼容性问题搜集 1.Date.parse() parse() 方法可解析一个日期时间字符串，并返回 1970/1/1 午夜距离该日期时间的毫秒数。W3C参考文档 代码部分: 1Date.parse(&quot;2020-02-02 00:00:00&quot;) 可能会在苹果环境中出现NaN的返回结果 解决方案是: 不使用具体时间 =&gt; Date.parse(&quot;2020-02-02&quot;) 使用“**/”代替“-**”来分割日期 =&gt; Date.parse(&quot;2020/02/02 00:00:00&quot;) 替换字符串为第二种方案 =&gt; Date.parse(&quot;2020-02-02 00:00:00&quot;.replace(/-/g, &#39;/&#39;)) 2.window.open() open() 方法用于打开一个新的浏览器窗口或查找一个已命名的窗口。W3C参考文档 代码部分: 1window.open(&#x27;//rexhang.com&#x27;); 可能会在苹果环境中出现被阻止打开的情况，这是由于苹果安全策略进行了拦截 解决方案是: 使用window.location.href = &#39;//rexhang.com&#39;代替 使用window.location.replace(&#39;//rexhang.com&#39;)代替 3.待博主更新…结语 这样的坑还有许多许多不仅仅是ios还有android也会存在一些兼容性问题，本文会长期更新，尽可能搜集更多的兼容案例，如有更多案例本文未提到的，希望大家踊跃提出，反馈在下方评论里，多谢大家~","categories":[{"name":"大前端","slug":"大前端","permalink":"https://blog.rexhang.com/categories/%E5%A4%A7%E5%89%8D%E7%AB%AF/"},{"name":"兼容性","slug":"大前端/兼容性","permalink":"https://blog.rexhang.com/categories/%E5%A4%A7%E5%89%8D%E7%AB%AF/%E5%85%BC%E5%AE%B9%E6%80%A7/"},{"name":"心得","slug":"大前端/兼容性/心得","permalink":"https://blog.rexhang.com/categories/%E5%A4%A7%E5%89%8D%E7%AB%AF/%E5%85%BC%E5%AE%B9%E6%80%A7/%E5%BF%83%E5%BE%97/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://blog.rexhang.com/tags/javascript/"},{"name":"前端多端开发兼容性","slug":"前端多端开发兼容性","permalink":"https://blog.rexhang.com/tags/%E5%89%8D%E7%AB%AF%E5%A4%9A%E7%AB%AF%E5%BC%80%E5%8F%91%E5%85%BC%E5%AE%B9%E6%80%A7/"},{"name":"ios","slug":"ios","permalink":"https://blog.rexhang.com/tags/ios/"},{"name":"macos","slug":"macos","permalink":"https://blog.rexhang.com/tags/macos/"},{"name":"apple","slug":"apple","permalink":"https://blog.rexhang.com/tags/apple/"},{"name":"苹果","slug":"苹果","permalink":"https://blog.rexhang.com/tags/%E8%8B%B9%E6%9E%9C/"}]},{"title":"Vue双向绑定的原理","slug":"Vue双向绑定的原理","date":"2021-01-10T07:56:57.000Z","updated":"2022-08-04T01:23:43.176Z","comments":true,"path":"2021/01/10/articles/2/","link":"","permalink":"https://blog.rexhang.com/2021/01/10/articles/2/","excerpt":"","text":"双向绑定原理及简单实现Vue是采用数据劫持结合发布者-订阅者模式的方式，通过new Proxy()来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。 Vue3.x与Vue2.x的区别仅是数据劫持的方式由Object.defineProperty更改为Proxy代理，其他代码不变Vue最核心的功能有两个，一是响应式的数据绑定系统，二是组件系统。本文仅探究双向绑定是怎样实现的。以及实现一个简化版的**Vue-lite** 一、访问器属性访问器属性是对象中的一种特殊属性，它不能直接在对象中设置，而必须通过defineProperty()方法单独定义。 123456789101112const obj = &#123;&#125;;Object.defineProperty(obj, &#x27;hello&#x27;, &#123; set: newVal =&gt; &#123; console.log(&#x27;set方法被调用了&#x27;); console.log(&#x27;newVal=&#x27;+newVal); &#125;, get: () =&gt; &#123; console.log(&#x27;get方法被调用了&#x27;); &#125;&#125;);obj.hello = &#x27;xxx&#x27;; // 会触发访问器属性中的set方法 参数是xxxobj.hello // 会触发访问器属性中的get方法 其中**get(),set()**方法就是实现双向绑定的关键 二、极简双向绑定的实现html部分: 1234567891011121314&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Vue-lite&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;input type=&quot;text&quot; id=&quot;inputs&quot; /&gt; &lt;p id=&quot;tips&quot;&gt;&lt;/p&gt; &lt;button id=&quot;btn&quot;&gt;设置新值&lt;/button&gt; &lt;script src=&quot;./js/Vue-lite.js&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; Vue-lite.js: 123456789101112131415161718192021222324const inputs = document.querySelector(&#x27;#inputs&#x27;);const tips = document.querySelector(&#x27;#tips&#x27;);const btn = document.querySelector(&#x27;#btn&#x27;);const obj = &#123;&#125;;Object.defineProperty(obj, &#x27;hello&#x27;, &#123; set: newVal =&gt; &#123; inputs.value = newVal; tips.innerHTML = newVal; &#125;, get: () =&gt; &#123; console.log(&#x27;get方法被调用了&#x27;); return &#x27;123&#x27;; // 可以对值进行修改 &#125;&#125;);obj.hello = &#x27;xxx&#x27;; // 会触发访问器属性中的set方法 参数是xxxconsole.log(obj.hello); // 会触发访问器属性中的get方法inputs.addEventListener(&#x27;keyup&#x27;, e=&gt;&#123; obj.hello = e.target.value;&#125;);btn.addEventListener(&#x27;click&#x27;, e=&gt;&#123; obj.hello = &#x27;233&#x27;; // set数据&#125;);// 实现了 model =&gt; view 以及 view =&gt; model 的双向绑定。// 以上就是 Vue2.x 实现双向绑定的基本原理。 此例实现的效果是：随文本框输入文字的变化，span 中会同步显示相同的文字内容；在js或控制台显式的修改 obj.hello 的值，视图会相应更新。这样就实现了 model =&gt; view 以及 view =&gt; model 的双向绑定，就是Vue实现双向绑定的最基本原理。 三、细节优化上述示例仅仅是为了说明原理。我们最终要实现的是： 1234567&lt;div id=&quot;app&quot;&gt; &lt;div&gt; &lt;span&gt;姓名: &lt;/span&gt; &lt;input type=&quot;text&quot; name=&quot;name&quot; v-mode=&quot;name&quot; /&gt; &lt;/div&gt; &lt;p&gt;您输入的name是: &#123;&#123;name&#125;&#125;&lt;/p&gt;&lt;/div&gt; 123456const vm = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; name: &#x27;rexhang&#x27; &#125;&#125;); 首先做下需要实现功能点: 输入框以及文本节点与 data 中的数据绑定 输入框内容变化时，data 中的数据同步变化。即 view =&gt; model 的变化 data 中的数据变化时，文本节点的内容同步变化。即 model =&gt; view 的变化 html: 1234567891011121314&lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;name&quot; v-model=&quot;name&quot; /&gt; &lt;br /&gt; &#123;&#123;name&#125;&#125;&lt;/div&gt;&lt;script src=&quot;./js/Vue-lite.js&quot;&gt;&lt;/script&gt;&lt;script&gt; new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; name: &#x27;rexhang&#x27; &#125; &#125;);&lt;/script&gt; Vue-lite.js: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135function nodeToFragment(node, vm) &#123; // createDocumentFragment()方法，是用来创建一个虚拟的节点对象，或者说，是用来创建文档碎片节点。它可以包含各种类型的节点，在创建之初是空的。 let virtualDOM = document.createDocumentFragment(); let child; while( child = node.firstChild)&#123; compile(child, vm) virtualDOM.appendChild(child); &#125; return virtualDOM;&#125;function compile (node, vm)&#123; const reg = /\\&#123;\\&#123;(.*)\\&#125;\\&#125;/; console.log(node); console.log(node.nodeType); if (node.nodeType === 1)&#123; // 节点类型是元素 const attr = node.attributes; for(let i = 0; i &lt; attr.length; i++)&#123; console.log(attr[i].nodeName); if(attr[i].nodeName === &#x27;v-model&#x27;)&#123; // 提取v-model的value const name = attr[i].nodeValue; node.addEventListener(&#x27;input&#x27;, e=&gt;&#123; vm[name] = e.target.value; &#125;); // 将data的值赋给该node // node.value = vm.data[name]; node.value = vm[name]; node.removeAttribute(&#x27;v-model&#x27;); &#125; &#125; &#125; if (node.nodeType === 3)&#123; // 节点类型是text if(reg.test(node.nodeValue))&#123; // 正则来获取匹配到的字符串&#123;&#123;name&#125;&#125; =&gt; name let name = node.nodeValue.match(reg)[1].trim(); // 将data的值赋给该node // node.nodeValue = vm.data[name]; // node.nodeValue = vm[name]; console.log(vm, node, name); new Watcher(vm, node, name); &#125; &#125;&#125;function defineReactive(obj, key, val)&#123; const dep = new Dep(); Object.defineProperty(obj, key, &#123; set: newVal =&gt; &#123; if(newVal === val) return; val = newVal; console.log(val); dep.notify(); &#125;, get: () =&gt; &#123; if(Dep.target) dep.addSub(Dep.target); return val; &#125; &#125;)&#125;function observe (obj, vm) &#123; Object.keys(obj).forEach(key=&gt;&#123; defineReactive(vm, key, obj[key]); &#125;);&#125;const dep = new Dep();const pub = &#123; publish: ()=&gt;&#123; dep.notify(); &#125;&#125;const sub1 = &#123; update: function () &#123; console.log(1); &#125; &#125;const sub2 = &#123; update: function () &#123; console.log(2); &#125; &#125;const sub3 = &#123; update: function () &#123; console.log(3); &#125; &#125;function Dep () &#123; // this.subs = [sub1, sub2, sub3]; this.subs = [];&#125;// Dep.prototype.notify = function()&#123;// this.subs.forEach(sub=&gt;&#123;// sub.update();// &#125;)// &#125;Dep.prototype.addSub = function(sub)&#123; this.subs.push(sub)&#125;Dep.prototype.notify = function()&#123; this.subs.forEach(sub=&gt;&#123; sub.update(); &#125;)&#125;pub.publish();function Watcher(vm, node, name)&#123; Dep.target = this; this.name = name; this.node = node; this.vm = vm; this.update(); Dep.target = null;&#125;Watcher.prototype = &#123; update: function()&#123; this.get(); this.node.nodeValue = this.value; &#125;, get: function()&#123; this.value = this.vm[this.name]; &#125;&#125;function Vue(opt)&#123; this.data = opt.data; observe(this.data, this); const rootDom = opt.el; const dom = nodeToFragment(document.querySelector(rootDom), this); // 编译完成，将dom返回到app中 document.querySelector(rootDom).appendChild(dom);&#125; 最终实现效果: 四、总结 Object.defineProperty 来进行数据中转(劫持)，从而实现事件的发布和后续触发订阅者的监听来实现数据绑定 实现一个监听器 observe 用来劫持并监听所有属性，如有变动，就通知订阅者 实现一个订阅者 Watcher 每个Watcher都绑定一个更新函数，可以把收到的属性变化通知并执行相应的函数，更新视图 实现一个解析器 compile 可以循环解析全部节点获取相关指令，初始化数据，初始化订阅 原文参考 Vue3.x双向绑定原理的实现参考","categories":[{"name":"大前端","slug":"大前端","permalink":"https://blog.rexhang.com/categories/%E5%A4%A7%E5%89%8D%E7%AB%AF/"},{"name":"面试经","slug":"大前端/面试经","permalink":"https://blog.rexhang.com/categories/%E5%A4%A7%E5%89%8D%E7%AB%AF/%E9%9D%A2%E8%AF%95%E7%BB%8F/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://blog.rexhang.com/tags/javascript/"},{"name":"前端框架","slug":"前端框架","permalink":"https://blog.rexhang.com/tags/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/"},{"name":"Vue","slug":"Vue","permalink":"https://blog.rexhang.com/tags/Vue/"}]},{"title":"几种判断数组的方法","slug":"几种判断数组的方法","date":"2021-01-09T16:01:22.000Z","updated":"2022-08-04T01:23:43.176Z","comments":true,"path":"2021/01/10/articles/1/","link":"","permalink":"https://blog.rexhang.com/2021/01/10/articles/1/","excerpt":"","text":"一、前言众所周知，js是门“动态”、“弱类型”编程语言，这意味着在js中可以任性定义变量，同时，“任性”也意味着需常在项目开发中对变量做类型判断，曾几何时，对数组变量的类型判断是件很痛苦的事情，开发人员想出多种方案来对数组做出准确的类型判断，但效果不佳，直到ES5标准“入主中原”，判断数组类型有了标准的isArray()官方利剑，才降伏了数组类型判断这条恶龙，世间得一清，但在此之前开发者是如何判断数组类型的？判断数组类型为何会如此玄学？为何要判断数组类型？带着这些疑问，吾跋山涉水，探寻各方资料，整理消化后遂成此文，以记之。 二、判断js数组类型为何麻烦？1、语言本身的“缺陷”js是门“动态”“弱类型”编程语言，这意味着js在定义和使用变量时可以“任性”，在ES6之前，我们定义变量一般使用“var”来定义： 123var name = &#x27;jack&#x27;;name = 20;name = [&#x27;aa&#x27;]; 在上述例子中，name变量初始定义为字符串类型，而后变为数字类型，最后摇身一变成为数组类型，这种任性摇摆的特性就是其“动态”特性，在java中我们定义一个字符串变量须如此定义：String name = ‘jack’，java通过一个String前缀“显式的”、“强制的”指定name变量为字符串类型，之后不得对该name变量进行类型变换(如果执行name = 22将会报type类型转换错误)，但js采用的是弱类型定义方案，在定义变量时使用var声明了一个变量，弱化了类型前缀的限制，并没强制锁死变量类型，之后可以随意更改其类型。动态弱类型这种声明变量的方案用起来可以随性而为，无须顾虑太多，随性的代码书写如若不加管制必将招致灾难性的代码bug。 2、js类型判断的“不足”其实动态弱类型的语言特性并不是决定js判断数组类型麻烦的必然原因，js语言因为历史原因，其创造者在开发之初将其定位为简单的网页小助手语言，为了轻巧、快速的完成小任务开发选择了“动态弱类型”的语言方案，PHP亦为动态弱类型语言，但在处理类型判断时，PHP用一个gettype()方法可以轻松、精准的搞定(PHP作为世界上世界上最好的语言还是有点东西的🤣)，PHP有gettype()这枚银弹，js有吗，嗯，算有吧，js最常用的是用typeof操作符来获取数据类型，看typeof这个名字是不是感觉很厉害？感觉会跟PHP一样轻松简单？但随后你会发现：typeof操作符是个很局限的类型获取方案，用它对基本数据类型做判断还算过得去，但在涉及到引用类型判断这种细活时就显得很low了… 三、判断js数组类型的几个“方案”1.typeof ❌ typeof在判断基础数据类型时尚有问题，更别说用来判断子孙繁多的引用类型了，typeof在判断引用类型时一刀切的统统返回object, 如 1234567var obj = &#123;&#125;;var arr = [];var map = new Map();typeof obj; // objecttypeof arr; // objecttypeof map; // object 故此，不适应于判断数据，PASS 2.data instanceof Array ❌ instanceof是js用来判断继承关系的运算符（js基于原型链实现继承，故instanceof判断的就是对应的类是否存在于变量的原型链上），根据这个特性可以如此来判断数组类型： 12const arr = [1, 2, 3];console.log(arr instanceof Array); // true 控制台打印显示如下: 从打印的结果可以看到Array存在于数组[1, 2, 3]的原型链上，故[1, 2, 3] instanceof Array === true; 利用instanceof的这个特性可以判断数组类型，但是instanceof运算符有个弊端 就是arr instanceof Object也是返回true: 12const arr2 = [1, 2, 3];console.log(arr2 instanceof Object); // true 控制台打印显示如下: 故此，不适应于判断数据，PASS 3.constructor ✔ 在JavaScript中, constructor属性会返回对象的构造函数。 1234let arr = [1, 2, 3];console.log(arr.constructor === Array); // truelet arr = [1, 2, 3];console.log(arr.constructor === Object); // false 控制台打印显示如下: 从打印结果显示，是满足我们的数据类型判断的，并且没有出现第二种判断方式instanceof方法的问题，因此是可以采用的。 4.Object.prototype.toString() ✔ Object.prototype.toString()能获取到变量的“类目名”，在js中万物皆为对象，万物皆有“类目名”，每个变量、对象、数组等都有一个唯一的类目名（这个类目名类似于人类给各类动植物起的“学名”），该方案通过获取目标变量的类目名([object Array])进行判断，如果类目名一致则证明目标变量为数组类型： 12let arr = [1, 2, 3];console.log( Object.prototype.toString.call(arr) === &#x27;[object Array]&#x27; ); // [object Array]: string; 返回 true Tips: 这种方法获取各种类型数据都有与之对应的字符串匹配值 12345678Object.prototype.toString.call([]); // &quot;[object Array]&quot;Object.prototype.toString.call(&#123;&#125;); // &quot;[object Object]&quot;Object.prototype.toString.call(&#x27;&#x27;); // &quot;[object String]&quot;Object.prototype.toString.call(1); // &quot;[object Number]&quot;Object.prototype.toString.call(function f()&#123;&#125;); // &quot;[object Function]&quot;Object.prototype.toString.call(); // &quot;[object Undefined]&quot;Object.prototype.toString.call(null); // &quot;[object Null]&quot;Object.prototype.toString.call(document); // &quot;[object HTMLDocument]&quot; 从打印结果显示，是满足我们的数据类型判断的，因此是可以采用的。 5.Array.isArray() ✔ 该方法是ES5标准规定的判断数组类型的标准方法，虽然Object.prototype.toString()方法可用来判断数组类型，但未免显得有点hack，又因自家typeof类型操作符给予厚望，辱没众望，如果随便更改typeof的返回结果势必会导致天下大乱，instanceof运算符又存在不同frame的局限性难堪大任，ES5不得不亡羊补牢的设计了isArray()方法来“增量”的解决数组判断难题。 12Array.isArray([1, 2, 3]); // trueArray.isArray(&#123;&#125;); // false 从打印结果显示，是满足我们的数据类型判断的，因此是可以采用的。 四、为何要判断数组类型？前面说过js属于动态弱类型语言，可能某个变量用着用着就莫名其妙的变了类型（自己不小心更改类型，引入的第三方代码库，因为同名变量改变了类型），如果你设想的是某个变量为数组类型，但因某个逻辑变成了基本类型，这时如果调用数组的方法注定会报错，凡此种种导致的问题，数不胜数，具体的问题实践多了懂得就懂。 五、结语近几年前端项目愈发复杂庞大，为更好的构建高性能的前端项目，诞生了“react、angular、vue”等数据驱动型解决方案，大量的数据、大量的组件和类对数据类型的判断需求愈发频繁，但因为js动态弱类型语言特性，加之其类型判断的坑爹性，所以各路开发者希望完善和升级js，在ES6标准中，新的const变量定义方案能很好的应对变量动态性问题，微软开发的“typescript”能够实现强类型变量定义，可应对弱类型定义问题。这些方案极大的减少了早期js变量任性定义带来的各种问题，虽然判断数组类型在未来开发中可能会成为历史云烟，但理解其相关的基础和历史演变却是一件很【浪漫】的事情，因为在理解了它的相关坑爹性和进化史有助于我们更好的思考和优化。爱之深，责之切，希望js能在未来变得更加锋利可靠，也希望少为一些坑爹特性而想出一些hack方案(额，比如——&gt;Object.prototype.toString()方法)。","categories":[{"name":"大前端","slug":"大前端","permalink":"https://blog.rexhang.com/categories/%E5%A4%A7%E5%89%8D%E7%AB%AF/"},{"name":"面试经","slug":"大前端/面试经","permalink":"https://blog.rexhang.com/categories/%E5%A4%A7%E5%89%8D%E7%AB%AF/%E9%9D%A2%E8%AF%95%E7%BB%8F/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://blog.rexhang.com/tags/javascript/"},{"name":"javascript数组","slug":"javascript数组","permalink":"https://blog.rexhang.com/tags/javascript%E6%95%B0%E7%BB%84/"}]},{"title":"javascript函数防抖与节流","slug":"javascript函数防抖与节流","date":"2021-01-04T18:03:33.000Z","updated":"2022-08-04T01:23:43.176Z","comments":true,"path":"2021/01/05/articles/2/","link":"","permalink":"https://blog.rexhang.com/2021/01/05/articles/2/","excerpt":"","text":"概念和例子函数防抖(debounce) 在事件被触发n秒后再执行回调，如果在这n秒内又被触发，则重新计时。 12345678910// 模拟一段ajax请求function ajax(content) &#123; console.log(&#x27;ajax request &#x27; + content)&#125;let inputa = document.getElementById(&#x27;unDebounce&#x27;)inputa.addEventListener(&#x27;keyup&#x27;, function (e) &#123; ajax(e.target.value)&#125;) 运行效果如图: 可以看到，我们只要按下键盘，就会触发这次ajax请求。不仅从资源上来说是很浪费的行为，而且实际应用中，用户也是输出完整的字符后，才会请求。下面我们优化一下： 1234567891011121314151617181920212223// 模拟一段ajax请求function ajax(content) &#123; console.log(&#x27;ajax request &#x27; + content)&#125;function debounce(fun, delay) &#123; return function (args) &#123; let that = this let _args = args clearTimeout(fun.id) fun.id = setTimeout(function () &#123; fun.call(that, _args) &#125;, delay) &#125;&#125; let inputb = document.getElementById(&#x27;debounce&#x27;)let debounceAjax = debounce(ajax, 500)inputb.addEventListener(&#x27;keyup&#x27;, function (e) &#123; debounceAjax(e.target.value)&#125;) 运行效果如图: 可以看到，我们加入了防抖以后，当你在频繁的输入时，并不会发送请求，只有当你在指定间隔内没有输入时，才会执行函数。如果停止输入但是在指定间隔内又输入，会重新触发计时。 个人理解 函数防抖就是法师发技能的时候要读条，技能读条没完再按技能就会重新读条。 函数节流(throttle) 规定在一个单位时间内，只能触发一次函数。如果这个单位时间内触发多次函数，只有一次生效。 看代码: 12345678910111213141516171819202122232425function throttle(fun, delay) &#123; let last, deferTimer return function (args) &#123; let that = this let _args = arguments let now = +new Date() if (last &amp;&amp; now &lt; last + delay) &#123; clearTimeout(deferTimer) deferTimer = setTimeout(function () &#123; last = now fun.apply(that, _args) &#125;, delay) &#125;else &#123; last = now fun.apply(that,_args) &#125; &#125;&#125;let throttleAjax = throttle(ajax, 1000)let inputc = document.getElementById(&#x27;throttle&#x27;)inputc.addEventListener(&#x27;keyup&#x27;, function(e) &#123; throttleAjax(e.target.value)&#125;) 看一下运行结果: 可以看到，我们在不断输入时，ajax会按照我们设定的时间，每1s执行一次。 个人理解 函数节流就是fps游戏的射速，就算一直按着鼠标射击，也只会在规定射速内射出子弹。 总结 函数防抖和函数节流都是防止某一时间频繁触发，但是这两兄弟之间的原理却不一样。 函数防抖是某一段时间内只执行一次，而函数节流是间隔时间执行。 结合应用场景 防抖(debounce) search搜索联想，用户在不断输入值时，用防抖来节约请求资源。 window触发resize的时候，不断的调整浏览器窗口大小会不断的触发这个事件，用防抖来让其只触发一次 节流（throttle） 鼠标不断点击触发，mousedown(单位时间内只触发一次) 监听滚动事件，比如是否滑到底部自动加载更多，用throttle来判断","categories":[{"name":"大前端","slug":"大前端","permalink":"https://blog.rexhang.com/categories/%E5%A4%A7%E5%89%8D%E7%AB%AF/"},{"name":"面试经","slug":"大前端/面试经","permalink":"https://blog.rexhang.com/categories/%E5%A4%A7%E5%89%8D%E7%AB%AF/%E9%9D%A2%E8%AF%95%E7%BB%8F/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://blog.rexhang.com/tags/javascript/"}]},{"title":"如何创建一个TC的免费托管服务","slug":"如何创建一个TC的免费托管服务","date":"2021-01-04T17:06:21.000Z","updated":"2022-08-04T01:23:43.177Z","comments":true,"path":"2021/01/05/articles/1/","link":"","permalink":"https://blog.rexhang.com/2021/01/05/articles/1/","excerpt":"","text":"首先&nbsp;&nbsp;&nbsp;&nbsp;需要先全局安装cli, 本地预先安装好nodejs以及git 1$ npm i -g @cloudbase/cli hexo-cli 然后&nbsp;&nbsp;&nbsp;&nbsp;初始化一个hexo项目目录 1$ hexo init 初始化完毕后, 启动服务本地编写文章 1$ hexo s 发布&nbsp;&nbsp;&nbsp;&nbsp;发布就很简单了，获取授权，生成静态代码，使用cli推送到远程托管 123$ cloudbase login$ hexo g$ cloudbase hosting deploy public -e [EnvID] tips 环境ID(EnvID)获取方法: 链接 创建环境指引: 链接","categories":[{"name":"腾讯云","slug":"腾讯云","permalink":"https://blog.rexhang.com/categories/%E8%85%BE%E8%AE%AF%E4%BA%91/"},{"name":"操作技巧","slug":"腾讯云/操作技巧","permalink":"https://blog.rexhang.com/categories/%E8%85%BE%E8%AE%AF%E4%BA%91/%E6%93%8D%E4%BD%9C%E6%8A%80%E5%B7%A7/"}],"tags":[{"name":"腾讯云","slug":"腾讯云","permalink":"https://blog.rexhang.com/tags/%E8%85%BE%E8%AE%AF%E4%BA%91/"}]}],"categories":[{"name":"大前端","slug":"大前端","permalink":"https://blog.rexhang.com/categories/%E5%A4%A7%E5%89%8D%E7%AB%AF/"},{"name":"css3","slug":"大前端/css3","permalink":"https://blog.rexhang.com/categories/%E5%A4%A7%E5%89%8D%E7%AB%AF/css3/"},{"name":"游戏引擎","slug":"大前端/游戏引擎","permalink":"https://blog.rexhang.com/categories/%E5%A4%A7%E5%89%8D%E7%AB%AF/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"效率","slug":"大前端/效率","permalink":"https://blog.rexhang.com/categories/%E5%A4%A7%E5%89%8D%E7%AB%AF/%E6%95%88%E7%8E%87/"},{"name":"前端开发","slug":"大前端/效率/前端开发","permalink":"https://blog.rexhang.com/categories/%E5%A4%A7%E5%89%8D%E7%AB%AF/%E6%95%88%E7%8E%87/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"},{"name":"图表","slug":"大前端/图表","permalink":"https://blog.rexhang.com/categories/%E5%A4%A7%E5%89%8D%E7%AB%AF/%E5%9B%BE%E8%A1%A8/"},{"name":"G2","slug":"大前端/图表/G2","permalink":"https://blog.rexhang.com/categories/%E5%A4%A7%E5%89%8D%E7%AB%AF/%E5%9B%BE%E8%A1%A8/G2/"},{"name":"面试经","slug":"大前端/面试经","permalink":"https://blog.rexhang.com/categories/%E5%A4%A7%E5%89%8D%E7%AB%AF/%E9%9D%A2%E8%AF%95%E7%BB%8F/"},{"name":"兼容性","slug":"大前端/兼容性","permalink":"https://blog.rexhang.com/categories/%E5%A4%A7%E5%89%8D%E7%AB%AF/%E5%85%BC%E5%AE%B9%E6%80%A7/"},{"name":"心得","slug":"大前端/兼容性/心得","permalink":"https://blog.rexhang.com/categories/%E5%A4%A7%E5%89%8D%E7%AB%AF/%E5%85%BC%E5%AE%B9%E6%80%A7/%E5%BF%83%E5%BE%97/"},{"name":"腾讯云","slug":"腾讯云","permalink":"https://blog.rexhang.com/categories/%E8%85%BE%E8%AE%AF%E4%BA%91/"},{"name":"操作技巧","slug":"腾讯云/操作技巧","permalink":"https://blog.rexhang.com/categories/%E8%85%BE%E8%AE%AF%E4%BA%91/%E6%93%8D%E4%BD%9C%E6%8A%80%E5%B7%A7/"}],"tags":[{"name":"css3","slug":"css3","permalink":"https://blog.rexhang.com/tags/css3/"},{"name":"mask","slug":"mask","permalink":"https://blog.rexhang.com/tags/mask/"},{"name":"遮罩","slug":"遮罩","permalink":"https://blog.rexhang.com/tags/%E9%81%AE%E7%BD%A9/"},{"name":"cocos2d","slug":"cocos2d","permalink":"https://blog.rexhang.com/tags/cocos2d/"},{"name":"CocosCreator","slug":"CocosCreator","permalink":"https://blog.rexhang.com/tags/CocosCreator/"},{"name":"游戏引擎","slug":"游戏引擎","permalink":"https://blog.rexhang.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"javascript","slug":"javascript","permalink":"https://blog.rexhang.com/tags/javascript/"},{"name":"javascript数组","slug":"javascript数组","permalink":"https://blog.rexhang.com/tags/javascript%E6%95%B0%E7%BB%84/"},{"name":"javascript字符串","slug":"javascript字符串","permalink":"https://blog.rexhang.com/tags/javascript%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"js小tips","slug":"js小tips","permalink":"https://blog.rexhang.com/tags/js%E5%B0%8Ftips/"},{"name":"js技巧","slug":"js技巧","permalink":"https://blog.rexhang.com/tags/js%E6%8A%80%E5%B7%A7/"},{"name":"React","slug":"React","permalink":"https://blog.rexhang.com/tags/React/"},{"name":"前端框架","slug":"前端框架","permalink":"https://blog.rexhang.com/tags/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/"},{"name":"前端多端开发兼容性","slug":"前端多端开发兼容性","permalink":"https://blog.rexhang.com/tags/%E5%89%8D%E7%AB%AF%E5%A4%9A%E7%AB%AF%E5%BC%80%E5%8F%91%E5%85%BC%E5%AE%B9%E6%80%A7/"},{"name":"ios","slug":"ios","permalink":"https://blog.rexhang.com/tags/ios/"},{"name":"macos","slug":"macos","permalink":"https://blog.rexhang.com/tags/macos/"},{"name":"apple","slug":"apple","permalink":"https://blog.rexhang.com/tags/apple/"},{"name":"苹果","slug":"苹果","permalink":"https://blog.rexhang.com/tags/%E8%8B%B9%E6%9E%9C/"},{"name":"Vue","slug":"Vue","permalink":"https://blog.rexhang.com/tags/Vue/"},{"name":"腾讯云","slug":"腾讯云","permalink":"https://blog.rexhang.com/tags/%E8%85%BE%E8%AE%AF%E4%BA%91/"}]}
>>>>>>> 75d1ae7c020d8e047635cc36c89e9a0d5668fc00
