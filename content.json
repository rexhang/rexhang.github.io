{"meta":{"title":"Rexhang的Blog","subtitle":"blog","description":"RexHang","author":"RexHang","url":"https://blog.rexhang.com","root":"/"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2022-11-23T16:49:22.678Z","updated":"2022-10-25T14:41:49.320Z","comments":false,"path":"/404.html","permalink":"https://blog.rexhang.com/404.html","excerpt":"","text":""},{"title":"关于","date":"2021-01-04T09:06:55.000Z","updated":"2022-10-25T14:41:49.325Z","comments":false,"path":"about/index.html","permalink":"https://blog.rexhang.com/about/index.html","excerpt":"","text":"Rexhang全身心致力于Web前端开发以及Nodejs、java等编程技术的研究包括javascript脚本，Jquery，Bootstrap，react，vue，angular等前端框架的研究，并不断完善自我争取更促进互联网与现实世界的更和谐并到更贴近的交互体验！"},{"title":"书单","date":"2022-11-23T16:49:22.678Z","updated":"2022-10-25T14:41:49.325Z","comments":false,"path":"books/index.html","permalink":"https://blog.rexhang.com/books/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2022-11-23T16:49:22.678Z","updated":"2022-10-25T14:41:49.325Z","comments":false,"path":"links/index.html","permalink":"https://blog.rexhang.com/links/index.html","excerpt":"","text":""},{"title":"项目","date":"2022-11-23T16:49:22.678Z","updated":"2022-10-25T14:41:49.326Z","comments":false,"path":"repository/index.html","permalink":"https://blog.rexhang.com/repository/index.html","excerpt":"","text":""},{"title":"分类","date":"2022-11-23T16:49:22.678Z","updated":"2022-10-25T14:41:49.325Z","comments":false,"path":"categories/index.html","permalink":"https://blog.rexhang.com/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2022-11-23T16:49:22.678Z","updated":"2022-10-25T14:41:49.326Z","comments":false,"path":"tags/index.html","permalink":"https://blog.rexhang.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"前端技术摘要","slug":"前端技术摘要","date":"2023-07-01T14:22:22.000Z","updated":"2023-07-21T06:20:08.611Z","comments":true,"path":"2023/07/01/articles/1/","link":"","permalink":"https://blog.rexhang.com/2023/07/01/articles/1/","excerpt":"","text":"前端技术总结罗列(持续更新中…)1、localStorage、sessionStorage、cookie、session、indexDB… 跨页面共享策略？机制各有不同之处？如何跨页面通信？ postMessage、iframe、跨域策略、时效性… session: 存于服务器端，安全，前端不可改，大小几乎不限制, 可存在于redis、SQL数据库中 可用于登录cookie 4kb 不安全 默认20分钟 到期后会被清除 前后端都可设置 不设置的话自然会失效消失 可存储登录token 可被浏览器请求携带(默认携带跨域不携带)，请求的时候带上凭证配置(credentials)&lt;omit(不发送)、same-orgin(同源才发送 cookies)、include(必定全部发送)&gt;: true server端也需要接受Access-Control-Allow-Credentials才可sessionStorage 5MB+- 仅存在于当前会话页面 关闭后 会清除localStorage 5MB+- 持久化存储 不主动清除不会消失indexDB 大小默认50MB 不主动清除 除非手动 可以扩容 kv形式存储 2、React路由鉴权 包装组件后if return 3、策略模式 使用js策略模式优化代码 4、前端跨域问题解决 浏览器的一种在前端客户端进行的防护策略，规定必须同源同端口&lt;协议、域名、端口&gt;解决&lt;参考: 链接&gt;： jsonp Script、jQuery、Axios 跨域资源共享（CORS）前后端共同实现 简单请求和非简单请求 nginx反向代理接口跨域 nodejs中间件代理跨域 使用node + express + http-proxy-middleware搭建一个proxy服务器 node + vue|react + webpack + webpack-dev-server 进行proxy配置解决跨域访问资源 因为渲染和代理都在同一处不在跨域 document.domain + iframe跨域 主域相同，子域不同的跨域应用场景 eg: weixin.qq.com和im.qq.com 2边都强制设置 document.domain = qq.com 即可，iframe子窗口则可以通过window.parent.xx获取主页面中的全局变量内容了 location.hash + iframe跨域 不展开叙述 window.name + iframe跨域 不展开叙述 postMessage(data, origin) 主页面通过 iframeDom.contentWindow.postMessage(&#39;xx&#39;, &#39;*&#39;)发送数据，子页面(iframe)通过window.onMessage监听即可, 也可以再发给父级页面 window.parent.postMessage, 父级页面再window.onMessage监听 webSocket本身不存在跨域问题，所以我们可以利用webSocket来进行非同源之间的通信 socket.io前后端搭建ws服务实现跨页面数据传输 本质还是搭建服务器 使用chrome扩展插件解决跨域问题 针对特定浏览器内 解决跨域问题 因为本身扩展插件是不会被跨域策略拦截的 利用这一特性实现 chrome版本号49之前的跨域设置 启动目标框里加上 --disable-web-security 前端chrome插件配置代理 + 后端接口代理请求服务实现 5、Js instanceof 用于检测构造函数的 prototype 属性是否出现在某个实例对象的原型链上 参考URLa instanceof A 用于检测 a是一个实例化对象 它的__proto__是否指向或者说是等于A的prototype 6、事件循环 任务队列 宏任务 微任务 同步任务 放入主线程中 eg: console.log(‘’); 异步任务 放入任务队列中(延迟性任务) 宏任务 setTimeout、setInterval等(优先级低于微任务) 微任务 Promise await async Object.observe MutationObserver process.nextTick(优先级最高)等 主线程先执行，然后微任务 7、http请求过程 浏览器输入网址DNS解析得到服务器IP，进行三次握手，建立TCP协议 客户端web浏览器向服务器发起请求，发送http请求和头信息发送 服务端应答客户端请求，响应头信息和浏览器所需内容 根据请求头信息是否包含keep-alive，决定是关闭TCP或保持TCP 最后客户端web浏览器得到服务端响应的结果 8、JSBridge原理 &lt;参考: 链接&gt;： 注入API 注入API，是通过WebView，向JavaScript的Context(window)上注入对象或方法，js直接调用注入的方法，即可执行Native的功能 拦截URL Scheme wx://ht/xxx?data=aa JS发送URL Scheme请求 重写 prompt 等原生 JS 方法 9、Vue、React优缺点比较 渲染执行机制 生命周期 xxx 10、Vue2和Vue3区别 vue2的双向数据绑定是利用了es5 的一个API Object.defineProperty() 对数据进行劫持 结合发布订阅模式来实现的。vue3中使用了es6的proxyAPI对数据进行劫持后处理。 Vue2是Vue.js的早期版本，已经经过多年实践检验，是稳定的版本。Vue3是Vue.js的最新版本，在保留Vue2的优点的同时，提供了更多的新特性和改进。 Vue2使用虚拟DOM来提高渲染性能，并提供了组件化的开发模式。Vue3在此基础上进一步优化了虚拟DOM的实现，并引入了编译器和运行时编译，使得渲染性能更高、代码更小、更灵活。 Vue2提供了响应式系统和组件化的开发模式，支持使用插件扩展功能。Vue3在此基础上提供了更多的开发工具，如可观察对象和组件代码分离等，使得开发更快捷、更灵活。 总的来说，Vue3在保留Vue2的优点的同时，提供了更快的运行速度、更小的体积和更多的灵活性，可以更好地满足开发人员的需求。 11、React Fiber原理和作用 概念: React Fiber是React执行渲染时的一种新的调度策略，因JavaScript是单线程的，一旦组件开始更新，主线程就一直被React控制，这个时候如果再次执行交互操作，就会容易导致卡顿，React Fiber就是来解决这个问题的 React Fiber就是通过对象的形式来记录组件上需要做或者已经完成的更新等详细信息，一个组件可以对应多个Fiber React Element树在第一次渲染的时候会创建一颗结构一模一样的的Fiber节点树（Fiber是个链表，有child和sibing属性FiberTree）。不同的React Element类型对应不同的Fiber节点类型。一个React Element的工作就由它对应的Fiber节点来负责。 React Fiber这种方式，渲染过程采用切片的方式，每执行一会儿，就歇一会儿。如果有优先级更高的任务到来以后呢，就会先去执行，降低页面发生卡顿的可能性，使得React对动画等实时性要求较高的场景体验更好。 参考: 链接 12、React高版本(v.18)新增的方法及作用 React18 通过其改进的渲染系统带来了并发能力，严格模式更新(更严格) flushSync函数来强制立即刷新更改(异步变同步)1234567891011import &#123; flushSync &#125; from &quot;react-dom&quot;;const handleClick = () =&gt; &#123; flushSync(() =&gt; &#123; setA(a =&gt; a + 1); &#125;); // Re-render flushSync(() =&gt; &#123; setB(b =&gt; b - 1); &#125;); // Re-render&#125;; 并发的React, useTransition, 可以使用 useTransition() 钩子来创建一个 transition。这个钩子返回一个函数来启动一个 transition，还有一个挂起的指示器来通知你 transition 的进度。12345678910111213141516import &#123; useTransition, useState &#125; from &quot;react&quot;;const App = () =&gt; &#123; const [isPending, startTransition] = useTransition(); const [value, setValue] = useState(0); function handleClick() &#123; startTransition(() =&gt; &#123; setValue((value) =&gt; value + 1); &#125;); &#125; return ( &lt;div&gt; &#123;isPending &amp;&amp; &lt;Loader /&gt;&#125; &lt;button onClick=&#123;handleClick&#125;&gt;&#123;value&#125;&lt;/button&gt; &lt;/div&gt; );&#125;; Suspense组件等 13、React Redux 原理 action 事件处理函数，有多个 action 是一个事件处理器，结构可以是switch case的模式 定义数据合成 store.dispatch() 将 action 传到 store12345678910111213import &#123; USER_INFO &#125; from &quot;../constants/actionTypes&quot;;import store from &#x27;../store/store&#x27;export const switchUser = (data) =&gt; &#123; return dispatch =&gt; &#123; // do somethings... dispatch(&#123; type: USER_INFO, payload: &#123; ...data, &#125; &#125;); &#125;&#125; reducer Reducers 指定了应用状态的变化如何响应 actions并发送到 store 的 reducer函数主要接收2个参数,state和action switch action.type 做出state数据合成并返回处理后的12345678910111213141516171819202122232425import &#123; USER_INFO &#125; from &quot;../constants/actionTypes&quot;;const redUserInfo = (state = &#123; userId: 1, userName: &#x27;&#x27;&#125;, action) =&gt; &#123; if (action === undefined) &#123; return state &#125; switch (action.type) &#123; case USER_INFO: return &#123; ...state, ...action.payload, &#125; case USER_SET: return &#123; ...state, ...action.payload, set: true, &#125; default: return state &#125;&#125; store redux 提供一个 createStore方法 传入 reducers 并返回新的store对象 code: 1234import &#123; createStore &#125; from &#x27;redux&#x27;import reducers from &#x27;../reducers/index&#x27;let store = createStore(reducers, ...initState)export default store Provider Provider 其实就只是一个外层容器，它的作用就是通过配合 connect 来达到跨层级跨组件共享传递数据。123456import store from &#x27;../store/store&#x27;&lt;Provider store=&#123;store&#125;&gt; &lt;PersistGate loading=&#123;null&#125; persistor=&#123;persistor&#125;&gt; &lt;About&gt;&lt;/About&gt; &lt;/PersistGate&gt;&lt;/Provider&gt; connect connect 的作用是连接React组件与 Redux store 它接收上面 Provider 提供的 store 里面的 state 和 dispatch，并返回一个对象，以属性形式传给我们的容器组件的props对象内1234567891011121314151617181920212223242526272829import &#123; connect &#125; from &#x27;react-redux&#x27;;import &#123; add, del, switchUser &#125; from &#x27;../../store/action/numAction&#x27;;function About(props) &#123; const &#123; add, del, item, switchUser &#125; = props const test = () =&gt; &#123; add(item) &#125; const test1 = () =&gt; &#123; del(item) &#125; return ( &lt;div&gt; &lt;h3&gt;我是About的内容&lt;/h3&gt; &lt;div&gt;&#123;item&#125;&lt;/div&gt; &lt;button onClick=&#123;() =&gt; test()&#125;&gt; 增加 &lt;/button&gt; &lt;button onClick=&#123;() =&gt; test1()&#125;&gt; 减少 &lt;/button&gt; &lt;/div&gt; )&#125;const mapStateToProps = state =&gt; &#123; return &#123; userInfo: &#123; ...state.userInfo &#125; &#125;&#125;const mapDispatchToProps = dispatch =&gt; &#123; return &#123; add(data)&#123; dispatch(add(data)); &#125;, switchUser: data =&gt; dispatch(switchUser(data));, &#125;&#125;export default connect(mapStateToProps, mapDispatchToProps)(About); 14、发布订阅 new event() on emit … 15、ES6新增内容 解构赋值，展开运算符（形参剩余量…rest），默认值定义，Promise异步方案，symbol数据类型，箭头函数 ES6新增了数组操作方法includes、map、forEach、findIndex、filter、some、every、reduce、 16、判断当前web环境是否支持某个css属性 例如 判断是否支持css { position: sticky }CSS.supports(&quot;position&quot;, &quot;sticky&quot;): boolean … 17、Map和Object区别 键的区别(Map可以是任意数据类型，Object只能string，或者symbol) … 18、Map和Set区别 共同点 它们的内容都是可迭代对象 都有delete、has、clear等方法 不同点 Map值是双元数组，key可以为任何数据，这点区别于普通Object只能是数字或字符串(Symbol) Set值是单个可迭代对象，key = value，因此可以直接add而不需要set(k, v)的方法 19、Js链式调用概念: 所谓的链式调用，简单粗暴的讲，就是在一个实例对象调用完一个方法后，在后边可以一直去调用其他方法，例如，Promise.then()的方法就是一个很好的例子，他可以在后边一直的.then下去。 1234567891011121314151617181920212223242526272829303132333435/* 简单的链式调用 */class Person &#123; constructor(name, age) &#123; this.name = name this.age = age &#125; info() &#123; console.log(`$&#123;this.age&#125;的$&#123;this.name&#125;`); return this &#125; start() &#123; console.log(&#x27;开始起床！&#x27;); return this &#125; eat() &#123; console.log(&#x27;开始吃饭&#x27;); return this &#125; school() &#123; console.log(&#x27;开始上学！&#x27;); return this &#125; sleep() &#123; console.log(&#x27;开始睡觉&#x27;); return this &#125; &#125; const person = new Person(&#x27;小红&#x27;, 36); person.info().start().eat().school().sleep(); // 36的小红 // 开始起床！ // 开始吃饭 // 开始上学！ // 开始睡觉 第二种，异步任务的处理方式 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354/* 如果加上异步代码那该如何实现 */function People(name) &#123; this.name = name; // 创建一个数组模拟任务队列 this.queue = []; // 用延迟器开启一个事件的总线 setTimeout(() =&gt; &#123; // 首次会调用next console.log(&#x27;首次会调用next&#x27;) this.next(); &#125;, 0); // 将this返回 return this;&#125;People.prototype.next = function() &#123; // 将队列中的第一个任务找出 const fn = this.queue.shift(); // 如果有任务的话就进行调用 fn &amp;&amp; fn();&#125;People.prototype.sayHello = function() &#123; const fn = () =&gt; &#123; console.log(&#x27;您好，我叫&#x27; + &quot; &quot; + this.name); this.next(); &#125; // 将该任务添加到队列当中 this.queue.push(fn); return this;&#125;People.prototype.eat = function(time) &#123; const that = this; const fn = () =&gt; &#123; setTimeout(function() &#123; console.log(`吃饭花费了 $&#123;time&#125;s`); that.next(); &#125;, time * 1000); &#125; that.queue.push(fn); return that;&#125;People.prototype.taskList = function() &#123; const fn = () =&gt; &#123; console.log(this.queue); &#125; this.queue.push(fn); return this;&#125;const people = new People(&#x27;rex&#x27;);people.sayHello().eat(2).taskList().queue; 20、Set集合forEach遍历会导致无限循环问题 在调用forEach遍历Set集合的时候，如果其中1个值被删除后又被重新添加到集合,那么该访问会重新再来1次, 形成无限循环 12345678910111213141516const set = new Set([1, 2])const newSet = new Set(set);console.log(set);console.log(newSet);newSet.forEach((item: key值, index: &lt;索引不是从0开始 而是 === item(key值)&gt;, s: Set) =&gt; &#123; console.log(set); console.log(item, index, s) newSet.delete(2); // newSet.add(2); newSet.add(new Date().getTime()); console.log(&#x27;我在遍历&#x27;);&#125;)；console.log(newSet);console.log(set); 21、Js柯里化 柯里化是一种函数的转换。是指将一个函数从可调用的 f(a, b, c) 转换为 f(a)(b)(c)。 解决&lt;参考: 链接&gt;： 12345678910111213141516171819202122function sum(num) &#123; //function s(innerVar)&#123; //num += innerVar; // arguments.callee 是一个指向正在执行的函数的指针，因此可以用它来实现对函数的调用，使用 arguments.callee 代替函数名，可以确保无论怎样调用函数都不会出问题。 // 注意点: &quot;use strict&quot; 下 不可用 使用下面写的第二种 //return arguments.callee; //&#125; // 不过，可以使用命名函数表达式来达成相同的结果 // 以上代码创建了一个名为 f()的命名函数表达式，然后将它赋值给变量 s。即便把函数赋值给了另一个变量，作用域内函数的名字 f 仍然有效 const s = (function f(innerVar)&#123; num += innerVar; return f; &#125;); s.toString = function()&#123; return num; &#125; return s;&#125;console.log( sum(3)(2)(1)(4) );alert(sum(3)(2)(1)(4));console.log( sum(1) )console.log( sum(1) * 1 ) 解析:s function 主要用来保存数据的累加 并 返回函数 让其能够继续被调用s.toString 主要用来实现静态方法，能够访问函数内部作用域内的变量(闭包特性)最后返回s方法sum(1) ===&gt; 会把num = 1放到toString中返回，没有调用到ssum(1)(2) ===&gt; 运行了s函数(会把2放到s函数的位参innerVar位置)，然后对num进行累加处理, num = num + innerVar, 且继续返回成可调用的s方法，接着s.toString会返回闭包中的最新num结果，以供静态调用(例如当函数进行比较时运算会调用toString方法，&lt;数据基本类型比较时可能会发生转换, 具体可参考资料&gt;)，例如alert，或者console.log( sum(1)(2) * 1 ) 使之发生数据转换得到静态化的结果值，实现功能 22、Js函数的指针(this) 普通函数、箭头函数&lt;()=&gt;{}&gt;的指针 1、只有一个参数的时候，参数可以不加小括号，没有参数或2个及以上参数的，必须加上小括号2、返回语句只有一条的时候可以不写{}和return，会自动加上return的，返回多条语句时必须加上{}和return3、箭头函数在返回对象的时候必须在对象外面加上小括号 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253// &#x27;use strict&#x27;;// 1、普通函数this指向：// 指向它的调用者，如果没有调用者则默认指向Window// 2、箭头函数指向：// 指向箭头函数定义的时候所处的对象，而不是其所使用的时候所处的对象，默认指向父级的this// 综上：箭头函数没有自己的this，它的this是继承来的，默认指向它定义的时候所处的对象const fMap = &#123; name() &#123; // this = 对象本身fMap console.log(this); &#125;, age: (e) =&gt; &#123; // this = window console.log(this); &#125;, sex: function() &#123; // this =&gt; fMap this.xx = &#x27;xx&#x27;; function the4() &#123; // this =&gt; window console.log(this); &#125;; const the5 = () =&gt; &#123; // this =&gt; sex的this = fMap console.log(this); &#125; the4(); the5(); &#125;&#125;fMap.name();fMap.age();fMap.sex();// 定义构造函数 如果函数是构造函数，那this将指的新的对象function Persion() &#123; // this指向p this.age = 0; console.log(this); setInterval(function () &#123; // this 指向Window this.age++; console.log(this); &#125;, 1000); setInterval(() =&gt; &#123; // ★ 箭头函数从自己的作用域链上一层继承的this，所以这个this也指向p this.age++; console.log(this); &#125;, 1000);&#125;// Persion();// this -&gt; windowconst p = new Persion(); // this =&gt; p;p.name = &#x27;rex&#x27;;console.log(p); 总结: 普通function函数this指向: 指向它的调用者，如果没有调用者则默认指向Window 箭头函数this指向: 指向箭头函数定义的时候所处的对象(默认指向父级的this) 如果没有父级程序 或者 父级程序没有指向 箭头函数的this指向是window 箭头函数没有自己的this，它的this是继承来的 箭头函数和普通函数的区别 箭头函数是匿名函数，普通函数可以是匿名函数也可以是具名函数 箭头函数不能作为构造函数使用，不能使用new关键字 箭头函数没有原型，所以没有prototype属性 call、apply、和bind无法改变箭头函数的this指向，但可以改变普通函数的this指向 箭头函数没有arguments对象，如果有外层函数，则继承外层函数的arguments，没有外层函数则会报错，箭头函数用的是rest参数（形式为: …rest） 箭头函数没有Generator，不能使用yield关键字 箭头函数没有自己的this 23、Vue3 composition API(组合式API) 类似于React的HOC高阶组件、Hooks 将组件的功能抽象为函数或对象的形式, 提高组件的可复用性和可维护性 24、函数式编程 xxx … 25、CI/CD 代码-编译-多环境测试部署-生产-回滚&lt;参考: 链接&gt;： 持续集成(CI) 持续部署(CD) 26、DevOps DevOps是一种思想，是一种文化，主要强调软件开发测试运维的一体化，目标是减少各个部门之间的沟通成本从而实现软件的快速高质量的发布。CI/CD是指持续集成发布部署，是一套流程实现软件的构建测试部署的自动化。DevOps与CICD紧密相关，是理论与实践的结合，DevOps要实现人员一体化，必须要借助CICD工具来自动化整个流程。 xxx … 27、ES6 Class的get set get set static 不要和this.xx重名 get vars(): string|xx —&gt; 只读 类似于 computed 返回值 set vars(value): void —&gt; 同computed 可以监听数据变动做出适当的相应 static method(): void —&gt; 定义静态方法, 不能在类的实例上调用静态方法, 而应该通过类本身调用。 28、Object.defineProperty Object.defineProperty(对象, &#39;某成员属性&#39;, &#123; ...配置项 &#125;) 主要配置 12345678910111213&#123; writable： 是否可重写 value： 当前值 get： 读取时内部调用的函数 set： 写入时内部调用的函数 enumerable： 是否可以遍历 configurable： 是否可再次修改配置项&#125; 29、前端性能优化(多角度) 加载优化 CSS优化 图片优化 脚本优化 渲染优化 … 30、SSR(NEXT.js、NUXT.js) Vue、React服务端渲染 Server Side Rendering … 31、算法: 冒泡排序 xxx … 32、求2个数组之间的【交集】【并集】【差集】 xxx … 33、Webpack、Vite、Rollup工作原理 Webpack 需要查找依赖，打包所有的模块，然后才能提供服务，更新速度会随着代码体积增加越来越慢 解析入口文件搜集依赖形成抽象语法关系树AST 接着解析AST加载模块，根据不同模块使用加载器进行处理 编译模块，变成可执行的js代码 打包输出(1或者多个文件 可以是css、js、等) 优化和插件系统(混淆、加密等) Vite 使用原生 ESModule 通过 script 标签动态导入，访问页面的时候加载到对应模块编译并响应 项目打包的时候最终还是需要打包成静态资源的，打包工具 Rollup 34、React组件重新渲染(刷新) &lt;参考: 链接&gt;： 类组件 this.forceUpdate(); 功能组件 函数组件: 调用App.render 用自己的新实例替换状态对象setUser(&#123; ...user &#125;); 让一个空的状态变量触发更新 12const [, updateState] = React.useState();const forceUpdate = React.useCallback(() =&gt; updateState(&#123;&#125;), []); 35、Keep-alive 缓存组件的一种解决方案 &lt;参考: 链接&gt;： vue 内置组件 keep-alive动态缓存方案 在组件切换过程中将状态保留在内存中，防止重复渲染DOM，减少加载时间及性能消耗，提高用户体验性 keep-alive包裹动态组件时，会缓存不活动的组件实例，而不是销毁它们。一般用法为下 例如路由，按需设置，性能达到最为均衡的状态 可以结合router来处理路由页面的缓存，在router中设置router的元信息meta : keepAlive: true &lt;keep-alive&gt; 包裹组件(路由) 进行缓存12345&lt;keep-alive&gt; &lt;router-view v-if=&quot;$route.meta.keepAlive&quot;&gt;&lt;/router-view&gt;&lt;/keep-alive&gt;// 这里不需要缓存&lt;router-view v-if=&quot;!$route.meta.keepAlive&quot;&gt;&lt;/router-view&gt; 路由配置1234567&#123; path:&quot;/list&quot;, component:HomeBookList, meta: &#123; keepAlive: true // 需要缓存 &#125;&#125; keep-alive支持三个属性，分别是 include - 字符串或正则表达式。只有名称匹配的组件会被缓存。 exclude - 字符串或正则表达式。任何名称匹配的组件都不会被缓存。 max - 数字。最多可以缓存多少组件实例。 通过设置: include = 变量数组, 然后监听路由 watch(to, from)，判断去到指定的路由的时候，改变这个变量数组，去掉缓存即可， keep-alive 中创建的组件，会多出两个生命周期的钩子: activated 与 deactivated activated在缓存组件激活时调用 deactivated在缓存组件失活时调用，取代原本的destroyed 36、路由守卫 全局守卫 router/index.js router.beforeEach(to, from, next) 全局前置路由守卫，每次路由切换之前被调用，可以做**权限拦截 **需要调用next() router.afterEach(to, from) 全局后置路由守卫，每次路由切换之后调用,注意没有next 可用于切换document.title router.beforeResolve 和 beforeEach类似 也属于全局守卫 区别是 在所有组件内守卫和异步路由组件被解析之后 导航确认之前 会调用 独享守卫 router/index.js router.beforeEnter(to, from, next)针对某个路由单独设置的守卫 独享路由守卫，只有前置，没有后置，写在routes配置项里，路由进入之前会调用 组件内守卫 Demo.vue router.beforeRouteEnter(to, from, next) 在渲染该组件的对应路由被 confirm 前调用 不可以访问本组件this对象 但是可以在next回调首个形参里面得到vm来访问this, 然后可以return false 来做拦截 router.beforeRouteUpdate(to, from, next) 在当前路由改变，且该组件被复用时调用 eg: /item/:id 之间跳转的时候 会被调用 切换路由动态参数的时候 router.beforeRouteLeave(to, from, next) 导航离开该组件的对应路由时调用 37、闭包 什么是「闭包」。 「函数」和「函数内部能访问到的变量」的总和，就是一个闭包。 「闭包」的作用是什么。 可以用来封装插件、柯里化… 闭包副作用 内存泄漏 -&gt; 坑没空着的了 内存溢出(扩展内容非闭包导致) -&gt; 一个坑2个人爆炸了 38、JavaScript中window.onload和document.onload有什么区别？&lt;参考: 链接&gt;： document.onload 在加载图像和其他外部内容之前将其触发。文件。在window.onload之前触发onload事件。 window.onload 加载整个页面（包括图像，脚本，css等）完成时，它将被触发。 $(document).ready() || DOMContentLoaded 当页面 DOM 加载完成后，ready() 里的函数便会立即执行 document.onload 和 document.ready onload 文档元素加载完毕后执行 只能执行一次 会覆盖 需要等待所有资源全部加载完成， ready 或者 DOMContentLoaded 不会覆盖 都会执行 执行顺序在load之前，只需等待DOM树结构完成 即可触发 document.body.onload 需要在body标签内引用才有效，body内容加载完成 总结: 使用window.onload 和 DOMContentLoaded 即可 DOMContentLoaded - load - beforeunload - unload DOMContentLoaded 只能用 addEventListener 39、JavaScript中事件委托(代理)的作用 JQ bind和on的区别 addEventListener和普通on区别 捕获顺序 冒泡顺序 怎么取消冒泡 事件委托是利用事件冒泡，只指定一个事件处理程序来管理某一类型的所有事件 delegate 执行事件委托 指定元素类型 ul.delegate(li, clickFunc) bind不能给不存在的元素绑定例如click事件 on可以代理也可以给未来的元素添加 bind只能给符合条件的元素本身添加事件 捕获行为是由上往下，而冒泡阶段是自下往上 事件流的三个阶段：冒泡阶段、捕获阶段、目标阶段 on会被覆盖 addEventListener(&gt;=IE9) 不会被覆盖 40、Webpack、Vite 工作流程 xxx … 41、Js call apply bind 区别 xxx … 42、Vue代码优化(下文续有性能优化) Object.freeze() 减少ES6代码，降低webpack编译的代码量 43、flex布局、多端兼容、响应式布局 rem原理 计算方法 1234const b = window.devicePixelRatio//dprconst c = &#x27;某个自己设置的值，我们公司为375px&#x27; //切图稿的统一宽度const d = document.documentElement.clientWidth//视口宽度const e = &#x27;某个自己设置的值，我们公司为37.5px&#x27; //根元素font-size大小 第一种方法是将px转化成rem再除以e 第二种方法非要用px作单位的话就把值除以c再乘以d webpack 插件 npm install px2rem-loader lib-flexible --save-dev 123456789101112131415module.exports = &#123; // ... module: &#123; rules: [&#123; test: /\\.less$/, use: [&#x27;style-loader&#x27;, &#x27;css-loader&#x27;, &#x27;less-loader&#x27;, &#123; loader: &#x27;px2rem-loader&#x27;, options: &#123; remUni: 75, // 适合750的设计稿 1rem = 75px remPrecision: 8 // px转rem小数点保留的位置 &#125; &#125;] &#125;] &#125;&#125; 在项目中引入lib-flexible &lt;script src=&quot;lib-flexible/flexible.js&quot;&gt;&lt;/script&gt; lib-flexible应最早执行 这样就可以实现PX到REM单位的自动转化了~ rem 计算原理: const w = 计算当前视口宽度(document.documentElement.clientWidth) eg: 375px const designWidth = 750px const dzr = w / designWidth eg: 0.5 // 设备缩放比 给html设置font-size = dzr =&gt; // 0.5 设计图 10px =&gt; 10px * dzr = 5px 设计图 12px =&gt; 12px * dzr = 6px dzr = 0.3 设计图 *12px =&gt; 12px * 0.3 = 3.6px* 非常不好计算, 因此可以在初始的时候 放大100倍 利于计算 给html设置font-size = dzr * 100 = 30px 设计图 12px =&gt; 12px * 0.3 * 100 = 360px 1rem = 0.3 x 100 x 1px = 300px 12px = (1rem / 100) * 12 0.12rem 总结: 先计算1个单位像素的比例 html: 1个单位 = 缩放比，1rem = 缩放比 x 单位量 但是方便计算 会倍率 否则rem: 0.3 x 12px，不利于计算 因此先x100 html set 缩放比*100 再除100 就是 rem: 1个html x 12 相当于12个单位的量 rem = 12 / 100 = 0.12rem 因为整体x了100倍 所以直接除以100即可 44、created、mounted和this.$nextTick()的区别 created: 页面渲染成htlm之前运行 可以做一些初始化操作 生命周期运行1次 mounted: 页面渲染成html后运行 可以操作一些静态dom元素 生命周期运行1次 this.$nextTick(fn) fn中可以对动态dom进行操作 生命周期运行多次 45、浏览器垃圾回收的基本算法 引用计数法，为0时，释放 有缺陷: 互为引用 标记清除法，先标记 后 回收, 从根部[globalThis]找有无使用处，无则回收 46、vue2性能优化 解决&lt;参考: 链接&gt;： Deferred 延迟 分批渲染 xxx 47、websocket soket.io xxx 48、Web Worker 浏览器提供的一种通信方式(API)，由主线程main script 和 worker script进行通信的 有利于性能提升 xxx 49、算法 二分法排序 冒泡排序 xxx 50、原型链的理解 原型链的理解prototype xxx 51、Vue组件重新渲染(刷新) :key 更改会刷新 v-if 会刷新 main.js 使用 Vue.forceUpdate()后 组件中使用this.$forceUpdate 刷新页面有路由的话 刷当前 this.$router.go(0)、 返回上一页 go(-1) 去另外的路由页 push(‘/login’) 或 push({ name: ‘login’ }) 52、在多个文件中import同一个文件，webpack会多次打包吗 不会 不同文件中多次import同一个文件，webpack并不会多次打包，只会在打包后的文件中会多次引用打包后的该文件对应的函数。 参考 53、React高阶组件HOC 实际上就是一个函数或者一个类 接收一个组件作为参数 然后生成新的组件 其中包含了参数组件体 … 54、TypeScript中type与interface的区别 interface用于定义一个新的对象的结构跟类型type用于给一个已存在的对象取名或者赋予别名 interface可以重复定义一个对象，最终的结果是合集的状态 1234567891011121314151617interface Person &#123; name: string age: number&#125;interface Person &#123; address: string&#125;type Person2 = &#123; name: string age: number&#125;type Person3 = Person2 &amp; &#123; address: string&#125; type可以定义联合类型，比如: 1type language = &#x27;cn&#x27;|&#x27;en&#x27;|&#x27;jp&#x27; 55、JWT是什么? 是一种用于在前端web端进行认证和授权的令牌机制、在前端存储传递 json web tokens 来实现用户身份校验和访问控制 header、payload、signature，三段式.隔开 http请求头可带上、cookie也可以带上、?token也可带上 56、简述HTTP 主要分为以下7步骤：DNF-&gt;IP 建立TCP、发起请求、服务端接收处理请求、服务端返回结果、客户端接收结果、客户端处理结果、关闭连接，复杂情况还需要加上重定向等 三次握手 1客户端发给服务端带有一把确认的钥匙，2服务端收到了你的钥匙并给你客户端发起一个确认，3.客户端从服务端得到了钥匙的确认信息","categories":[{"name":"大前端","slug":"大前端","permalink":"https://blog.rexhang.com/categories/%E5%A4%A7%E5%89%8D%E7%AB%AF/"},{"name":"面试经","slug":"大前端/面试经","permalink":"https://blog.rexhang.com/categories/%E5%A4%A7%E5%89%8D%E7%AB%AF/%E9%9D%A2%E8%AF%95%E7%BB%8F/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://blog.rexhang.com/tags/javascript/"},{"name":"前端技术","slug":"前端技术","permalink":"https://blog.rexhang.com/tags/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/"}]},{"title":"如何编写web前端开发岗简历","slug":"如何编写web前端开发岗简历","date":"2022-12-15T04:10:01.000Z","updated":"2022-12-15T03:16:34.572Z","comments":true,"path":"2022/12/15/articles/2/","link":"","permalink":"https://blog.rexhang.com/2022/12/15/articles/2/","excerpt":"","text":"如何编写web前端开发岗简历 编写简历时，首先要包括你的个人信息，包括姓名、联系方式、电子邮箱和地址。接下来，你可以简要介绍你的教育背景和工作经验。 在简历中提及你对 Web 前端开发的经验。你可以提到你掌握的主要技术，例如 HTML、CSS 和 JavaScript，并列出你的项目经验。此外，你还可以提到你对用户体验和交互设计的兴趣和经验。 另外，你可以在简历中提到你的专业技能和特长，例如掌握的其他编程语言和框架，或者对数据分析和可视化的经验。这些内容可以帮助雇主了解你的能力，并决定是否与你进一步沟通。 最后，你可以在简历中列出你的证书和荣誉，以及参加过的培训和活动。这些内容有助于雇主了解你的专业知识和技能水平，并评估你是否符合他们的招聘标准。 总之，在编写简历时，要注意清晰、简洁、准确地展示你的个人信息和专业技能，以便雇主能够快速了解你，并决定是否与你进一步沟通 个人信息，包括姓名、电话号码、电子邮件地址和社交媒体链接。 教育经历，包括毕业院校、学位和专业。 工作经历，包括公司名称、职位名称和工作描述。 技能清单，包括掌握的语言、框架和工具。 项目经验，包括项目名称、描述和贡献。 证书或其他资格证明。 编写简历时，要尽量详细且简洁，将你的能力和经验介绍给招聘方。为了让你的简历更加出色，还可以添加下列内容： 个人简介，包括你的专业方向、兴趣爱好和个人特点。 其他语言能力，如果你会一种或多种外语，可以在简历中提及。 兴趣爱好或个人项目，如果你有一些有趣的兴趣爱好或个人项目，可以在简历中提及。 总之，编写简历时要注意交代清楚你的能力和经验，并以简洁易读的方式展现出来。 编写一份web前端开发岗简历，首先应该包含您的个人信息，包括姓名、联系方式和电子邮件地址。接下来，应该概述您的专业技能和工作经验，并突出您在web前端开发方面的专业知识和经验。 在描述您的专业技能时，应该清楚地说明您掌握的技术和工具，例如HTML、CSS、JavaScript、jQuery、Bootstrap等。此外，还应该简要说明您了解的开发框架和库，例如React、Vue、Angular等。 在描述您的工作经验时，应该简要介绍您曾经参与的项目，包括项目的主要功能、您负责的工作内容和您贡献的主要技术。此外，还应该提及您的工作态度和工作能力，例如认真负责、注重团队合作、熟练掌握代码调试等。 在编写完简历之后，应该仔细检查语法和拼写错误，并确保简历内容简洁明了，表达出您的专业知识和工作经验。此外，还应该考虑简历的整体布局和设计，以确保简历能够吸引招聘方的眼球。 在简历开头写明自己的个人信息，包括姓名、电话号码、电子邮件地址、个人网站等。 接下来，写出自己的教育背景，包括所就读的大学和专业。如果有相关的证书或培训课程，也可以在这一部分提及。 在工作经验部分，按照时间倒序列出自己的工作经历。对于每个工作经历，可以描述工作内容、工作职责和所取得的成就。 在技能部分，列出自己在web前端开发方面的技能，包括熟悉的编程语言、框架和工具。还可以提及自己对用户体验和可用性的关注程度。 在简历末尾，可以附上作品集，展示自己在web前端开发方面的能力。这一部分可以包括项目链接、设计稿和截图等。 在简历最后，可以写一段自荐信，介绍自己的工作理念和为公司所做的贡献。 总的来说，编写web前端开发岗简历时，应该注重个人信息的准确性、工作经历的详实性","categories":[{"name":"面试经","slug":"面试经","permalink":"https://blog.rexhang.com/categories/%E9%9D%A2%E8%AF%95%E7%BB%8F/"},{"name":"前端","slug":"面试经/前端","permalink":"https://blog.rexhang.com/categories/%E9%9D%A2%E8%AF%95%E7%BB%8F/%E5%89%8D%E7%AB%AF/"},{"name":"JavaScript","slug":"面试经/前端/JavaScript","permalink":"https://blog.rexhang.com/categories/%E9%9D%A2%E8%AF%95%E7%BB%8F/%E5%89%8D%E7%AB%AF/JavaScript/"}],"tags":[{"name":"面试经","slug":"面试经","permalink":"https://blog.rexhang.com/tags/%E9%9D%A2%E8%AF%95%E7%BB%8F/"},{"name":"前端","slug":"前端","permalink":"https://blog.rexhang.com/tags/%E5%89%8D%E7%AB%AF/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://blog.rexhang.com/tags/JavaScript/"}]},{"title":"json-server的使用(接口数据mock好帮手)","slug":"json-server","date":"2022-12-15T04:00:20.000Z","updated":"2022-12-15T03:16:34.572Z","comments":true,"path":"2022/12/15/articles/1/","link":"","permalink":"https://blog.rexhang.com/2022/12/15/articles/1/","excerpt":"","text":"简介 json-server: 接口数据mock好帮手 新建文件&lt;db.json&gt;, 内容如下: 123456789101112131415161718192021222324252627&#123; &quot;posts&quot;: [ &#123; &quot;id&quot;: 1, &quot;title&quot;: &quot;json-server&quot;, &quot;author&quot;: &quot;typicode&quot; &#125; ], &quot;comments&quot;: [ &#123; &quot;id&quot;: 1, &quot;body&quot;: &quot;some comment&quot;, &quot;postId&quot;: 1 &#125; ], &quot;profile&quot;: &#123; &quot;name&quot;: &quot;typicode&quot; &#125;, &quot;users&quot;: [ &#123; &quot;id&quot;: 1, &quot;name&quot;: &quot;rexhang&quot;, &quot;guid&quot;: &quot;ee7a6768-bb2c-423c-ac06-5c7905c035b5&quot;, &quot;time&quot;: &quot;Wed, 14 Dec 1970 13:20:02 GMT&quot; &#125; ]&#125; 安装&amp;启动 npm install -g json-server 默认启动在localhost:3000端口，参数: 可以监听文件变化 –watch, 可以指定端口号 –port, 可以指定host –host json-server --watch db.json --port 8111 --host 127.0.0.1 然后会以JSON成员为键名，生成若干个请求地址，http://127.0.0.1:8111/JSON_KEY 请求方法(实现CURD) with REST Client(Ext) -&gt; 直达官网 Create 123456789###POST http://127.0.0.1:8111/userscontent-type: application/json &#123; &quot;name&quot;: &quot;rexhang&quot;, &quot;guid&quot;: &quot;&#123;&#123;$guid&#125;&#125;&quot;, &quot;time&quot;: &quot;&#123;&#123;$datetime rfc1123|iso8601&#125;&#125;&quot;&#125; Update 1234567###PATCH http://127.0.0.1:8111/users/1content-type: application/json &#123; &quot;name&quot;: &quot;rexhang&quot;&#125; Read 12###GET http://127.0.0.1:8111/profile 1234###GET http://127.0.0.1:8111/users?id=1&amp;name=rexhang Delete 12###DELETE http://127.0.0.1:8111/users/1","categories":[{"name":"前端","slug":"前端","permalink":"https://blog.rexhang.com/categories/%E5%89%8D%E7%AB%AF/"},{"name":"开发工具","slug":"前端/开发工具","permalink":"https://blog.rexhang.com/categories/%E5%89%8D%E7%AB%AF/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"},{"name":"node","slug":"前端/开发工具/node","permalink":"https://blog.rexhang.com/categories/%E5%89%8D%E7%AB%AF/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/node/"}],"tags":[{"name":"开发工具","slug":"开发工具","permalink":"https://blog.rexhang.com/tags/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"},{"name":"devtools","slug":"devtools","permalink":"https://blog.rexhang.com/tags/devtools/"},{"name":"node","slug":"node","permalink":"https://blog.rexhang.com/tags/node/"}]},{"title":"使用mask实现视频弹幕人物遮罩过滤，就是牛逼","slug":"使用mask实现视频弹幕人物遮罩过滤，就是牛逼","date":"2022-09-30T08:17:28.000Z","updated":"2022-10-25T14:41:49.323Z","comments":true,"path":"2022/09/30/articles/2/","link":"","permalink":"https://blog.rexhang.com/2022/09/30/articles/2/","excerpt":"","text":"经常看一些LOL比赛直播的小伙伴，肯定都知道，在一些弹幕网站（Bilibili、虎牙）中，当人物与弹幕出现在一起的时候，弹幕会“巧妙”的躲到人物的下面，看着非常的智能。 简单的一个截图例子： 其实，这里是运用了 CSS 中的 mask 属性实现的。 mask 简单用法介绍 这里只简单介绍下 mask 的基本用法： 最基本，使用 mask 的方式是借助图片，类似这样： 12345&#123; /* Image values */ mask: url(mask.png); /* 使用位图来做遮罩 */ mask: url(masks.svg#star); /* 使用 SVG 图形中的形状来做遮罩 */&#125; 当然，使用图片的方式后文会再讲。借助图片的方式其实比较繁琐，因为我们首先还得准备相应的图片素材，除了图片，mask 还可以接受一个类似 background 的参数，也就是渐变。 类似如下使用方法： 123&#123; mask: linear-gradient(#000, transparent) /* 使用渐变来做遮罩 */&#125; 那该具体怎么使用呢？一个非常简单的例子，上述我们创造了一个从黑色到透明渐变色，我们将它运用到实际中，代码类似这样： 下面这样一张图片，叠加上一个从透明到黑色的渐变， 1234&#123; background: url(image.png) ; mask: linear-gradient(90deg, transparent, #fff);&#125; 应用了 mask 之后，就会变成这样： 这个 DEMO，可以先简单了解到 mask 的基本用法。 这里得到了使用 mask 最重要结论：添加了 mask 属性的元素，其内容会与 mask 表示的渐变的 transparent 的重叠部分，并且重叠部分将会变得透明。 值得注意的是，上面的渐变使用的是 linear-gradient(90deg, transparent, #fff)，这里的 #fff 纯色部分其实换成任意颜色都可以，不影响效果。 使用 mask 实现人物遮罩过滤 了解了 mask 的用法后，接下来，我们运用 mask，简单实现视频弹幕中，弹幕碰到人物，自动被隐藏过滤的例子。 首先，我简单的模拟了一个召唤师峡谷，以及一些基本的弹幕： 方便示意，这里使用了一张静态图，表示了召唤师峡谷的地图，并非真的视频，而弹幕则是一条一条的 &lt;p&gt; 元素，和实际情况一致。伪代码大概是这样： 123456789&lt;!-- 地图 --&gt;&lt;div class=&quot;g-map&quot;&gt;&lt;/div&gt;&lt;!-- 包裹所有弹幕的容器 --&gt;&lt;div class=&quot;g-barrage-container&quot;&gt; &lt;!-- 所有弹幕 --&gt; &lt;div class=&quot;g-barrage&quot;&gt;6666&lt;/div&gt; ... &lt;div class=&quot;g-barrage&quot;&gt;6666&lt;/div&gt;&lt;/div&gt; 为了模拟实际情况，我们再用一个 div 添加一个实际的人物，如果不做任何处理，其实就是我们看视频打开弹幕的感受，人物被视频所遮挡： 注意，这里我添加了一个人物亚索，并且用 animation 模拟了简单的运动，在运动的过程中，人物是被弹幕给遮挡住的。 接下来，就可以请出 mask 了。 我们利用 mask 制作一个 radial-gradient ，使得人物附近为 transparent，并且根据人物运动的 animation，给 mask 的 mask-position 也添加上相同的 animation 即可。最终可以得到这样的效果： 1234567891011.g-barrage-container &#123; position: absolute; mask: radial-gradient(circle at 100px 100px, transparent 60px, #fff 80px, #fff 100%); animation: mask 10s infinite alternate;&#125;@keyframes mask &#123; 100% &#123; mask-position: 85vw 0; &#125;&#125; 实际上就是给放置弹幕的容器，添加一个 mask 属性，把人物所在的位置标识出来，并且根据人物的运动不断的去变换这个 mask 即可。我们把 mask 换成 background，原理一看就懂。 把 mask 替换成 background 示意图： background 透明的地方，即 mask 中为 transparent 的部分，实际就是弹幕会被隐藏遮罩的部分，而其他白色部分，弹幕不会被隐藏，正是完美的利用了 mask 的特性。 其实这项技术和视频本身是无关的，我们只需要根据视频计算需要屏蔽掉弹幕的位置，得到相应的 mask 参数即可。如果去掉背景和运动的人物，只保留弹幕和 mask，是这样的： 需要明确的是，使用 mask，不是将弹幕部分给遮挡住，而是利用 mask，指定弹幕容器之下，哪些部分正常展示，哪些部分透明隐藏。 实际生产环境中的运用 当然，上面我们简单的还原了利用 mask 实现弹幕遮罩过滤的效果。但是实际情况比上述的场景复杂的多，因为人物英雄的位置是不确定的，每一刻都在变化。所以在实际生产环境中，mask 图片的参数，其实是由后端实时对视频进行处理计算出来的，然后传给前端，前端再进行渲染。 对于运用了这项技术的直播网站，我们可以审查元素，看到包裹弹幕的容器的 mask 属性，每时每刻都在发生变化： 返回回来的其实是一个 SVG 图片，大概长这个样子： 这样，根据视频人物的实时位置变化，不断计算新的 mask，再实时作用于弹幕容器之上，实现遮罩过滤。","categories":[{"name":"大前端","slug":"大前端","permalink":"https://blog.rexhang.com/categories/%E5%A4%A7%E5%89%8D%E7%AB%AF/"},{"name":"css3","slug":"大前端/css3","permalink":"https://blog.rexhang.com/categories/%E5%A4%A7%E5%89%8D%E7%AB%AF/css3/"}],"tags":[{"name":"css3","slug":"css3","permalink":"https://blog.rexhang.com/tags/css3/"},{"name":"mask","slug":"mask","permalink":"https://blog.rexhang.com/tags/mask/"},{"name":"遮罩","slug":"遮罩","permalink":"https://blog.rexhang.com/tags/%E9%81%AE%E7%BD%A9/"}]},{"title":"CocosCreator实现不规则区域点击","slug":"CocosCreator实现不规则区域点击","date":"2022-09-30T07:36:22.000Z","updated":"2022-10-25T14:41:49.321Z","comments":true,"path":"2022/09/30/articles/1/","link":"","permalink":"https://blog.rexhang.com/2022/09/30/articles/1/","excerpt":"","text":"一、问题背景在CocosCreator中，点击图片透明区域依然触发节点的点击事件。但在web开发中，可以使用Inkscape、SvgPathEditor等矢量图编辑器转为SVG，或者直接从figma中导出SVG，然后监听不规则图形事件。 以地图边界高亮为例：html 类似地图的不规则图形事件处理 123svg &#123; height: 50vw; &#125;path &#123; fill: #d3d3d3; transition: .6s fill; opacity: 0.6;&#125;path:hover &#123; fill: #eee;opacity: 0.6; &#125; 但CocosCreator中Sprite目前支持的格式为jpg和png，未直接支持SVG。 二、方案调研图像模板(image_stencil) mask 如何控制只让图像遮罩的可视区域响应点击 图像模板可以根据设置的透明度阈值，只有当模板像素的 alpha 值大于该阈值时，才会绘制内容。 但是该方式点击透明区域，依然会触发该节点的事件。 通过查看2.4.7版本 CCMask.js 的源码 ，可以看到在碰撞检测中，图像模板类型的mask的命中方式与矩形保持一致，只有椭圆才是单独检测，故该方式并不能解决问题。 123456789101112131415161718192021222324252627282930_hitTest (cameraPt) &#123; let node = this.node; let size = node.getContentSize(), w = size.width, h = size.height, testPt = _vec2_temp; node._updateWorldMatrix(); // If scale is 0, it can&#x27;t be hit. if (!Mat4.invert(_mat4_temp, node._worldMatrix)) &#123; return false; &#125; Vec2.transformMat4(testPt, cameraPt, _mat4_temp); testPt.x += node._anchorPoint.x * w; testPt.y += node._anchorPoint.y * h; let result = false; if (this.type === MaskType.RECT || this.type === MaskType.IMAGE_STENCIL) &#123; result = testPt.x &gt;= 0 &amp;&amp; testPt.y &gt;= 0 &amp;&amp; testPt.x &lt;= w &amp;&amp; testPt.y &lt;= h; &#125; else if (this.type === MaskType.ELLIPSE) &#123; let rx = w / 2, ry = h / 2; let px = testPt.x - 0.5 * w, py = testPt.y - 0.5 * h; result = px * px / (rx * rx) + py * py / (ry * ry) &lt; 1; &#125; if (this.inverted) &#123; result = !result; &#125; return result;&#125; 多边形mask 1.Creator | 编辑器中可操作顶点的多边形遮罩2.【组件分享】使用Mask+Graphic魔改的多边形遮罩组件3.[ Mask + PolygonCollider 简易自定义多边形遮罩制作 ] 沿着mask的思路，在论坛上找到了多边形mask的实现方式。大致都是在CCMask源码的基础上，增加多边形的节点添加和碰撞检测，其中一位作者实现的组件非常吸睛，GitHub上共有400余Star，目前cocos商店已有该组件。感兴趣可阅读源码。 效果如下： 比较有意思是其碰撞检测（点是否在多边形内），采用射线法判断。 定义：从目标点出发引一条射线，看这条射线和多边形所有边的交点数目。如果有奇数个交点，则说明在内部，如果有偶数个交点，则说明在外部。 具体步骤：将测试点的Y坐标与多边形的每一个点进行比较，会得到一个测试点所在的行与多边形边的交点的列表。在下图的这个例子中有8条边与测试点所在的行相交，而有6条边没有相交。如果测试点的两边点的个数都是奇数个则该测试点在多边形内，否则在多边形外。在这个例子中测试点的左边有5个交点，右边有三个交点，它们都是奇数，所以点在多边形内。 算法实现： 12345678910111213141516171819202122232425isInPolygon(checkPoint: cc.Vec2, polygonPoints: cc.Vec2[]) &#123; let counter = 0, i: number, xinters: number; let p1: cc.Vec2, p2: cc.Vec2; let pointCount = polygonPoints.length; p1 = polygonPoints[0]; for (i = 1; i &lt;= pointCount; i++) &#123; p2 = polygonPoints[i % pointCount]; if ( checkPoint.x &gt; Math.min(p1.x, p2.x) &amp;&amp; checkPoint.x &lt;= Math.max(p1.x, p2.x) ) &#123; if (checkPoint.y &lt;= Math.max(p1.y, p2.y)) &#123; if (p1.x != p2.x) &#123; xinters = (checkPoint.x - p1.x) * (p2.y - p1.y) / (p2.x - p1.x) + p1.y; if (p1.y == p2.y || checkPoint.y &lt;= xinters) &#123; counter++; &#125; &#125; &#125; &#125; p1 = p2; &#125; return (counter &amp; 1) !== 0;&#125; 多边形mesh 多边形裁剪图片(非mask,使用mesh)，新增 gizmo 支持https://github.com/baiyuwubing/cocos-creator-examples/tree/master/meshTexture 2年前开发，已停止维护，使用不佳，节点关联顺序容易紊乱。根据作者的描述，可以解决mask过多带来性能影响。 像素点计算 creator 2.4.8中获取像素信息 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768const getPixelData = (node: cc.Node, x: number, y: number) =&gt; &#123; const pixelsData = getPixelsData(node); const startIndex = node.width * 4 * Math.floor(node.height - y) + 4 * Math.floor(x); const pixelData = pixelsData.slice(startIndex, startIndex + 4); return pixelData;&#125;;const isPixelTransparent = (node: cc.Node, x: number, y: number) =&gt; &#123; const pixelData = getPixelData(node, x, y); return pixelData[3] === 0;&#125;;const getPixelsData = (node: cc.Node) =&gt; &#123; if (!cc.isValid(node)) &#123; return null; &#125; // 节点宽度 const width = Math.floor(node.width); const height = Math.floor(node.height); // 创建临时摄像机用于渲染目标节点 const cameraNode = new cc.Node(); cameraNode.parent = node; const camera = cameraNode.addComponent(cc.Camera); // eslint-disable-next-line no-bitwise camera.clearFlags |= cc.Camera.ClearFlags.COLOR; camera.backgroundColor = cc.color(0, 0, 0, 0); camera.zoomRatio = cc.winSize.height / height; // 将节点渲染到 RenderTexture中 const renderTexture = new cc.RenderTexture(); renderTexture.initWithSize( width, height, cc.RenderTexture.DepthStencilFormat.RB_FMT_S8 ); camera.targetTexture = renderTexture; camera.render(node); const pixelData = renderTexture.readPixels(); return pixelData;&#125;;/** 点击事件是否合法，非透明像素 */ isValidTouch(e: cc.Event.EventTouch) &#123; const touchLocation = e.touch.getLocation(); /** 相对节点左下角的相对坐标，即图片内的坐标 */ const locationInNode = this.node.convertToNodeSpaceAR(touchLocation); /** 非本节点内 透传 */ if (!this.node.getBoundingBoxToWorld().contains(touchLocation)) &#123; this.setSwallowTouches(false); return false; &#125; const &#123; anchorX, anchorY, width, height &#125; = this.node; const x = locationInNode.x + anchorX * width; const y = -(locationInNode.y - anchorY * height); const isValid = !isPixelTransparent(this.node, x, y); this.setSwallowTouches(isValid); return isValid; &#125; /** 设置是否阻止点击事件透传 */ setSwallowTouches(bool: boolean) &#123; (this.node as any)._touchListener.setSwallowTouches(bool); &#125; 方案对比 方案名称 优点 缺点 图像模板mask - 适合图片快速裁剪渲染 - 不满足要求 多边形mask - 适用于多边形定制化裁剪 - 参考文章 [@]Mask组件多边形方案性影响手机Web性能。多边形mask使用过多，低端机性能下降严重（碰撞检测占主要原因） - 手动描边 多边形mesh - 根据作者描述，比mask性能更优 - 手动描边 像素点计算 - 颗粒度精细，能精确到像素点 - 无需特殊处理图片 - 图片过大时，可能带来性能问题 可能的最佳实践？在论坛中看到有个大佬在尝试svg拓展 Creator + SVG 解析渲染扩展组件 ，已上架cocos商店【价值80¥】","categories":[{"name":"大前端","slug":"大前端","permalink":"https://blog.rexhang.com/categories/%E5%A4%A7%E5%89%8D%E7%AB%AF/"},{"name":"游戏引擎","slug":"大前端/游戏引擎","permalink":"https://blog.rexhang.com/categories/%E5%A4%A7%E5%89%8D%E7%AB%AF/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"}],"tags":[{"name":"cocos2d","slug":"cocos2d","permalink":"https://blog.rexhang.com/tags/cocos2d/"},{"name":"CocosCreator","slug":"CocosCreator","permalink":"https://blog.rexhang.com/tags/CocosCreator/"},{"name":"游戏引擎","slug":"游戏引擎","permalink":"https://blog.rexhang.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"}]},{"title":"JS中非常实用的『一行代码』","slug":"JS中非常实用的『一行代码』","date":"2022-08-04T04:03:28.000Z","updated":"2022-12-27T07:28:27.417Z","comments":true,"path":"2022/08/04/articles/1/","link":"","permalink":"https://blog.rexhang.com/2022/08/04/articles/1/","excerpt":"","text":"导读: 最近在国外技术社区看到了一些关于 一行代码 的文章📄，感觉很有意思，就整理了下来并且自己额外补充了一部分分享给大家🤜，希望对各位读者们有所帮助💕。 最近一次更新时间 2022-08-21 12:00:15 这些方法使用到了一些API，简化了操作，但是有些方法写一行属实不太优雅，所以这里主要还是学习API的使用小技巧。 一、日期处理 检查日期是否有效该方法用于检测给出的日期是否有效 123const isDateValid = (...val) =&gt; !Number.isNaN( new Date(...val).valueOf() );// how to useisDateValid(&quot;December 17, 1995 03:24:00&quot;); // =&gt; true 计算两个日期之间的间隔该方法用于计算两个日期之间的间隔时间(day) 123const dayDif = (date1, date2) =&gt; Math.ceil( Math.abs( date1.getTime() - date2.getTime() ) / 86400000);// how to usedayDif(new Date(&quot;2022-08-01&quot;), new Date(&quot;2022-08-04&quot;)); // =&gt; 3 查找日期位于一年中的第几天该方法用于检测给出的日期位于今年的第几天 1234const dayOfYear = date =&gt; Math.floor( ( date - new Date(date.getFullYear(), 0, 0) ) / 1000 / 60 / 60 / 24 )// how to usedayOfYear(new Date(&quot;2022-08-01&quot;)); // =&gt; 213dayOfYear(new Date(&quot;2022-01-01&quot;)); // =&gt; 1 时间格式化该方法用于转换时间 12345const timeFromDate = date =&gt; date.toTimeString().slice(0, 8);// how to usetimeFromDate(new Date(2022, 08, 04, 12, 30, 0)); // =&gt; &#x27;12:30:00&#x27;timeFromDate(new Date(2022, 08, 04, 12, 30, 60)); // =&gt; &#x27;12:31:00&#x27;timeFromDate(new Date()); // =&gt; 此刻的时间 二、字符串处理 字符串首字母大写该方法用于将英文字符串的首字母大写处理 123const capitalize = str =&gt; str.charAt(0).toUpperCase() + str.slice(1);// how to usecapitalize(&quot;hello world&quot;); // =&gt; Hello world 翻转字符串该方法用于将一个字符串进行翻转操作并返回翻转后的内容 123const reverse = str =&gt; str.split(&#x27;&#x27;).reverse().join(&#x27;&#x27;);// how to usereverse(&quot;hello world&quot;); // =&gt; dlrow olleh 随机字符串该方法用于生成一个随机的字符串并返回 123const randomString = () =&gt; Math.random().toString(36).slice(2);// how to userandomString(); // =&gt; anyString 去除字符串中的HTML该方法用于去除字符串中的HTML元素 123const stripHtml = html =&gt; (new DOMParser().parseFromString(html, &#x27;text/html&#x27;)).body.textContent || &#x27;&#x27;;// how to usestripHtml(&quot;&lt;div&gt;Beware of the missing closing tag&lt;/div&gt;hello world&lt;i&gt;!&lt;i&gt;&quot;); // =&gt; &#x27;Beware of the missing closing taghello world!&#x27; 获取URL的search参数并json化该方法用于获取当前访问的URL中的search内容并解析成JSON键值对形式 123const urlParams = search =&gt; Object.fromEntries(new URLSearchParams(search));// how to useurlParams(location.search); // =&gt; &#123; id: &#x27;1&#x27;, name: &#x27;rexhang&#x27; &#125; 去除数字之外的所有字符该方法用于去除数字之外的所有字符 1234const toNumber = str =&gt; Number(str.replace(/\\D/g, &#x27;&#x27;));// how to useconst str = &#x27;hello 123 is god 456&#x27;;toNumber(str); // =&gt; 123456 空值(null | undefined)合并运算符该方法用于更简短的定义空值情况下的时候, null 或者 undefined 会认定为判断范围， 其余认为正常赋值 1234567891011121314const aa = isA ?? false;const bb = isB ?? &#x27;hello&#x27;;const cc = isC ?? &#x27;ok&#x27;;const dd = isD ?? &#x27;done&#x27;;// how to useconst isA = null;const isB = &#x27;&#x27;;const isC = undefined;const isD = false;const aa = isA ?? &#x27;...&#x27;;const bb = isB ?? &#x27;hello&#x27;;const cc = isC ?? &#x27;ok&#x27;;const dd = isD ?? &#x27;done&#x27;;console.log(aa, bb, cc, dd); 二、数组处理 从数组中移除重复项该方法用于从数组中移除重复项 123const removeDuplicates = arr =&gt; [...new Set(arr)];// how to useremoveDuplicates([1, 1, 3, 4, 1, 5]); // =&gt; [1, 3, 4, 5] 打乱数组顺序该方法用于打乱数组顺序，随机取random后的数组 1234const randomArr = arr =&gt; arr.sort(() =&gt; 0.5 - Math.random());// how to useconst arr = [&#x27;🙂&#x27;, &#x27;66&#x27;, true, 11, &#123;name: &#x27;rexhang&#x27;&#125;];console.log(randomArr(arr)); // random arr, eg: [&#x27;66&#x27;, 11, true, &#123;name: &#x27;rexhang&#x27;&#125;, &#x27;🙂&#x27;]; 从数组中随机去一个值该方法用于从数组中随机去一个值 1234const takeARandomItem = arr =&gt; arr[Math.floor(Math.random() * arr.length)]// how to useconst eles = [&#x27;🙂&#x27;, &#x27;66&#x27;, true, 11, &#123;name: &#x27;rexhang&#x27;&#125;];console.log(takeARandomItem(eles)); // random item of arr, eg: &#x27;🙂&#x27;; 从数组中取出最大/小值(仅限数字|字符串数字)该方法用于从数组中取出最大/小值(仅限数字|字符串数字) 1234567const getMaxMinValue = arr =&gt; (&#123; max: Math.max(...arr), min: Math.min(...arr),&#125;)// how to useconst items = [11, 12, 11, 1, &#x27;0&#x27;];console.log(getMaxMinValue(items)); // &#123; max: 12, min: 0 &#125; 判断数组是否为空该方法用于判断数组是否为空 12345const isNotEmpty = arr =&gt; Array.isArray(arr) &amp;&amp; !!arr.length;// how to useisNotEmpty([1, 3]); // =&gt; trueisNotEmpty([]); // =&gt; trueisNotEmpty(&quot;[1, 3]&quot;); // =&gt; 非数组返回false 长期且持续更新中…","categories":[{"name":"大前端","slug":"大前端","permalink":"https://blog.rexhang.com/categories/%E5%A4%A7%E5%89%8D%E7%AB%AF/"},{"name":"效率","slug":"大前端/效率","permalink":"https://blog.rexhang.com/categories/%E5%A4%A7%E5%89%8D%E7%AB%AF/%E6%95%88%E7%8E%87/"},{"name":"前端开发","slug":"大前端/效率/前端开发","permalink":"https://blog.rexhang.com/categories/%E5%A4%A7%E5%89%8D%E7%AB%AF/%E6%95%88%E7%8E%87/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://blog.rexhang.com/tags/javascript/"},{"name":"javascript数组","slug":"javascript数组","permalink":"https://blog.rexhang.com/tags/javascript%E6%95%B0%E7%BB%84/"},{"name":"javascript字符串","slug":"javascript字符串","permalink":"https://blog.rexhang.com/tags/javascript%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"js小tips","slug":"js小tips","permalink":"https://blog.rexhang.com/tags/js%E5%B0%8Ftips/"},{"name":"js技巧","slug":"js技巧","permalink":"https://blog.rexhang.com/tags/js%E6%8A%80%E5%B7%A7/"}]},{"title":"一套面向常规统计图表，以数据驱动的高交互可视化图形语法 - G2","slug":"G2","date":"2022-08-04T01:27:08.000Z","updated":"2022-10-25T14:41:49.322Z","comments":true,"path":"2022/08/04/articles/2/","link":"","permalink":"https://blog.rexhang.com/2022/08/04/articles/2/","excerpt":"","text":"G2 一套面向常规统计图表，以数据驱动的高交互可视化图形语法。 网站 • 教程文档 • 博客 • G2Plot G2 是一套基于图形语法理论的可视化底层引擎，以数据驱动，提供图形语法与交互语法，具有高度的易用性和扩展性。使用 G2，你可以无需关注图表各种繁琐的实现细节，一条语句即可使用 Canvas 或 SVG 构建出各种各样的可交互的统计图表。 📺 线上示例 ✨ 特性 💯 完善的图形语法：数据到图形的映射，能够绘制出所有的图表。 🤩 全新的交互语法：通过触发和反馈机制可以组合出各种交互行为，对数据进行探索。 🦍 强大的 View 模块：可支持开发个性化的数据多维分析图形。 👬 双引擎渲染：Canvas 或 SVG 任意切换。 💄 可视化组件体系：面向交互、体验优雅。 🛡 全面拥抱 TypeScript：提供完整的类型定义文件。 📦 安装1$ npm install @antv/g2 🔨 快速上手 在绘图前我们需要为 G2 准备一个 DOM 容器： 1&lt;div id=&quot;c1&quot;&gt;&lt;/div&gt; 12345678910111213141516171819202122232425import &#123; Chart &#125; from &#x27;@antv/g2&#x27;;const data = [ &#123; genre: &#x27;Sports&#x27;, sold: 275 &#125;, &#123; genre: &#x27;Strategy&#x27;, sold: 115 &#125;, &#123; genre: &#x27;Action&#x27;, sold: 120 &#125;, &#123; genre: &#x27;Shooter&#x27;, sold: 350 &#125;, &#123; genre: &#x27;Other&#x27;, sold: 150 &#125;,];// Step 1: 创建 Chart 对象const chart = new Chart(&#123; container: &#x27;c1&#x27;, // 指定图表容器 ID width: 600, // 指定图表宽度 height: 300, // 指定图表高度&#125;);// Step 2: 载入数据源chart.data(data);// Step 3: 创建图形语法，绘制柱状图chart.interval().position(&#x27;genre*sold&#x27;);// Step 4: 渲染图表chart.render(); ⌨️ 本地开发1234567891011121314# 安装依赖$ npm install# 运行测试用例$ npm run test# 打开 electron 运行测试用例，监听文件变化构建$ npm run test-live# 运行 CI$ npm run ci# 运行网站$ npm start 🏷️ 版本 v3.5.x: https://github.com/antvis/G2/tree/v3.5.x v4.0.x: https://github.com/antvis/G2/tree/v4.0.x 你也可以在业务中使用基于 G2 封装的常规统计图表 G2Plot ，可以使用配置的方式快速生成一个通用图表，降低开发者的使用成本。","categories":[{"name":"大前端","slug":"大前端","permalink":"https://blog.rexhang.com/categories/%E5%A4%A7%E5%89%8D%E7%AB%AF/"},{"name":"图表","slug":"大前端/图表","permalink":"https://blog.rexhang.com/categories/%E5%A4%A7%E5%89%8D%E7%AB%AF/%E5%9B%BE%E8%A1%A8/"},{"name":"G2","slug":"大前端/图表/G2","permalink":"https://blog.rexhang.com/categories/%E5%A4%A7%E5%89%8D%E7%AB%AF/%E5%9B%BE%E8%A1%A8/G2/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://blog.rexhang.com/tags/javascript/"}]},{"title":"React代码整洁优化实践","slug":"React代码整洁优化实践","date":"2022-08-02T14:16:48.000Z","updated":"2022-10-25T14:41:49.322Z","comments":true,"path":"2022/08/02/articles/1/","link":"","permalink":"https://blog.rexhang.com/2022/08/02/articles/1/","excerpt":"","text":"整洁的代码不仅仅是正常运行的代码，更是要求易于阅读、简单易懂、组织整齐。在本文中，我会们将示例几种代码整洁案例。在阅读这些建议时，要记住这些只是建议！ 如果你不同意它们中的任何一个，那也完全没关系。以下这些实践，个人觉得对我自己编写 React 代码很有帮助。1. 仅对一个条件进行渲染 如果需要在条件为true时渲染某些内容，而在条件为false时不渲染任何内容，不推荐使用三元表达式，改用与运算符&amp;&amp;，它可以方便地条件渲染一个元素。 优化前: 1234567891011import React from &quot;react&quot;;export const TopNav = (props: &#123; showSearch?: boolean &#125;) =&gt; &#123; const &#123; showSearch = false &#125; = props; return ( &lt;div className=&quot;doc-head&quot;&gt; &#123;/* 三元表达式进行条件渲染 */&#125; &#123;showSearch ? &lt;SearchBox placeholder=&quot;输入关键词搜索&quot; onSearch=&#123;(keyword) =&gt; window.location.assign(`/privatecloud/search?q=$&#123;keyword&#125;`)&#125; style=&#123;&#123; marginRight: 100 &#125;&#125; /&gt; : null&#125; &lt;/div&gt; );&#125;; 优化后: 1234567891011import React from &quot;react&quot;;export const TopNav = (props: &#123; showSearch?: boolean &#125;) =&gt; &#123; const &#123; showSearch = false &#125; = props; return ( &lt;div className=&quot;doc-head&quot;&gt; &#123;/* 与运算符&amp;&amp;进行条件渲染 */&#125; &#123;showSearch &amp;&amp; &lt;SearchBox placeholder=&quot;输入关键词搜索&quot; onSearch=&#123;(keyword) =&gt; window.location.assign(`/privatecloud/search?q=$&#123;keyword&#125;`)&#125; style=&#123;&#123; marginRight: 100 &#125;&#125; /&gt;&#125; &lt;/div&gt; );&#125;; 2. 每一个条件都可能进行渲染 如果需要在条件为 true 时渲染某些内容，而在条件为 false 时渲染其他内容。推荐使用三元表达式！ 优化前: 123&#123;/* 条件 True 和 False 都要渲染内容 */&#125;&#123; good &amp;&amp; &lt;p&gt;Good!&lt;/p&gt; &#125;&#123; !good &amp;&amp; &lt;p&gt;&lt;b&gt;Not Good!&lt;b&gt;&lt;/p&gt; &#125; 优化后: 123456789101112&#123; /* 三元表达式 */&#125;&#123; good ? ( &lt;p&gt;Good!&lt;/p&gt; ) : ( &lt;p&gt; &lt;b&gt;Not Good!&lt;/b&gt; &lt;/p&gt; );&#125; 3. 组件 Boolean props 传参 组件接收参数的属性值为布尔类型, 并且传入 true 值时，可以省略填写值，并不会影响组件内取到 true 值 优化前: 12&lt;Hello disabled=&#123;true&#125; /&gt;&lt;Hello disabled=&#123;false&#125; /&gt; 优化后: 12&lt;Hello disabled /&gt;&lt;Hello disabled=&#123;false&#125; /&gt; 4. 组件 String props 传参 组件 Props 值为 String, 推荐使用双引号包裹，不使用花括号或反引号。 优化前: 123&lt;Hello personName=&#123;&quot;Jim&quot;&#125; /&gt;&lt;Hello personName=&#123;&#x27;Tom&#x27;&#125; /&gt;&lt;Hello personName=&#123;`Ken`&#125; /&gt; 优化后: 123&lt;Hello personName=&quot;Jim&quot; /&gt;&lt;Hello personName=&quot;Tom&quot; /&gt;&lt;Hello personName=&quot;Ken&quot; /&gt; 5. Event handler functions 如果一个事件函数只接受一个参数，不需要传入匿名函数：onChange={ e =&gt; handleChange(e) }，推荐这种写法(直接等于函数)： onChange={ handleChange } 。 优化前: 1234const handleChange = (e) =&gt; &#123; console.info(e.target.value);&#125;;&lt;input id=&quot;name&quot; value=&#123;inputValue&#125; onChange=&#123;(e) =&gt; handleChange(e)&#125; /&gt;; 优化后: 1234567const handleChange = (e) =&gt; &#123; console.info(e.target.value);&#125;;&#123; /* 事件只有一个参数，不需要匿名函数*/&#125;&lt;input id=&quot;name&quot; value=&#123;inputValue&#125; onChange=&#123;handleChange&#125; /&gt;; 6. components as props 将组件作为参数传递给另一个组件时，如果该组件不接受任何参数，则无需将该传递的组件包装在函数中。 优化前: 12&lt;Hello ClockComponent=&#123;() =&gt; &lt;Clock timestamp=&#123;new Date().getTime()&#125; /&gt;&#125; /&gt;&lt;Hello ClockComponent=&#123;() =&gt; &lt;Clock /&gt;&#125; /&gt; 优化后: 12&lt;Hello ClockComponent=&#123;() =&gt; &lt;Clock timestamp=&#123;new Date().getTime()&#125; /&gt;&#125; /&gt;&lt;Hello ClockComponent=&#123;Clock&#125; /&gt; 7. 设置 state 依赖先前的 state 如果新 state 依赖于先前 state，则始终将 state 设置为先前 state 的函数。可以批处理 React 状态更新。 优化前: 1234567891011121314151617181920212223import React, &#123; useState &#125; from &quot;react&quot;;export const Hello = () =&gt; &#123; const [cout, setCount] = useState &lt; number &gt; 0; // 依赖先前/上一个的state值 (异步调用) const handleClick = (e) =&gt; setCount(cout + 1); // 期望执行2次 首次执行理应 cout = 2 const handleClickRunDouble = (e) =&gt; &#123; // 执行第二个handleClick执行的时候第一个count设置未完成(异步的)，所以还是 count = 0 = 0 + 1 = 1 因此 首次的点击得到的值 = 1 而并非2, 如果需要实现2 那么就得利用setState的批处理方式 handleClick(e); handleClick(e); &#125;; return ( &lt;div&gt; &lt;button onclick=&#123;handleClick&#125;&gt;click here&lt;/button&gt; &lt;span&gt;&#123;count&#125;&lt;/span&gt; &lt;button onclick=&#123;handleClickRunDouble&#125;&gt;click here &amp; lunch 2 times&lt;/button&gt; &lt;/div&gt; );&#125;; 优化后: 123456789101112131415161718192021222324import React, &#123; useState &#125; from &quot;react&quot;;export const Hello = () =&gt; &#123; const [cout, setCount] = useState &lt; number &gt; 0; &#123; /* 将set调用设置为批处理模式 使用set方法提供的callback内的数值 */ &#125; const handleClick = (e) =&gt; setCount((c) =&gt; c + 1); // 首次调用后会输出最新的值 count = 2; const handleClickRunDouble = (e) =&gt; &#123; handleClick(e); handleClick(e); &#125;; return ( &lt;div&gt; &lt;button onclick=&#123;handleClick&#125;&gt;click here&lt;/button&gt; &lt;span&gt;&#123;count&#125;&lt;/span&gt; &lt;button onclick=&#123;handleClickRunDouble&#125;&gt;click here &amp; lunch 2 times&lt;/button&gt; &lt;/div&gt; );&#125;; 以上 7 个就是我推荐和总结的几个React代码整洁优化实践 。 最后，祝大家开发愉快！","categories":[{"name":"大前端","slug":"大前端","permalink":"https://blog.rexhang.com/categories/%E5%A4%A7%E5%89%8D%E7%AB%AF/"},{"name":"面试经","slug":"大前端/面试经","permalink":"https://blog.rexhang.com/categories/%E5%A4%A7%E5%89%8D%E7%AB%AF/%E9%9D%A2%E8%AF%95%E7%BB%8F/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://blog.rexhang.com/tags/javascript/"},{"name":"React","slug":"React","permalink":"https://blog.rexhang.com/tags/React/"},{"name":"前端框架","slug":"前端框架","permalink":"https://blog.rexhang.com/tags/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/"}]},{"title":"数组的一些常用方法及使用区别","slug":"数组的一些常用方法及使用区别","date":"2021-05-13T16:22:22.000Z","updated":"2022-10-25T14:41:49.325Z","comments":true,"path":"2021/05/14/articles/1/","link":"","permalink":"https://blog.rexhang.com/2021/05/14/articles/1/","excerpt":"","text":"一、前言push pop unshift shift splice slice split join 方法及使用区别 二、示例1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162// push pop unshift shift splice slice split joinconst arr = [1, 2, 3, 4];// push、unshift向数组的 尾部/头部 添加若干元素，并返回 数组的 新长度const a = arr.push(&#x27;X&#x27;, &#x27;Y&#x27;, &#x27;Z&#x27;); // -&gt; new lengthconst b = arr.unshift(&#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;); // -&gt; new lengthconsole.log(a);console.log(b);console.log(arr);// pop、shift向数组的 尾部/头部 删除一个元素 并返回 数组中 被删除的元素const c = arr.pop(); // -&gt; last itemconst d = arr.shift(); // -&gt; first itemconsole.log(c);console.log(d);const e = arr.push();const f = [].pop();const g = [].shift();console.log(e);console.log(f);console.log(g);// splice 向/从数组中添加/删除项目，然后返回被删除的项目集合[?1, ?2]。 -1开始反方向删除(末尾第一个) 即便是负数 也都是从左到右删除单位const h = arr.splice(-2, 2, &#x27;rex&#x27;, &#x27;hang&#x27;, &#x27;gu&#x27;);console.log(h);// slice 只对数组范围做截取 并返回 截取的内容const i = arr.slice(1, -2); // 区间 -&gt; (?] 不包含末尾console.log(i);// split 用于 把一个有标记的字符串 分割成 标准数组const j = &#x27;a|b|c&#x27;.split(&#x27;|&#x27;);console.log(j);// join 用于 把一个标准数组 变成 固定符号分隔的 字符串const k = [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;].join(&#x27;|&#x27;);console.log(k);console.log(arr); 控制台输出内容如图所示: 看完上述例子后，我想大家都应该大致明白了这些方法的使用区别。","categories":[{"name":"大前端","slug":"大前端","permalink":"https://blog.rexhang.com/categories/%E5%A4%A7%E5%89%8D%E7%AB%AF/"},{"name":"面试经","slug":"大前端/面试经","permalink":"https://blog.rexhang.com/categories/%E5%A4%A7%E5%89%8D%E7%AB%AF/%E9%9D%A2%E8%AF%95%E7%BB%8F/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://blog.rexhang.com/tags/javascript/"},{"name":"javascript数组","slug":"javascript数组","permalink":"https://blog.rexhang.com/tags/javascript%E6%95%B0%E7%BB%84/"}]},{"title":"探讨下前端开发过程中在苹果系统下的一些兼容性小坑以及解决方案","slug":"探讨下前端开发过程中在苹果系统下的一些兼容性小坑以及解决方案","date":"2021-01-12T13:20:30.000Z","updated":"2022-10-25T14:41:49.324Z","comments":true,"path":"2021/01/12/articles/1/","link":"","permalink":"https://blog.rexhang.com/2021/01/12/articles/1/","excerpt":"","text":"导读: 本文会长期更新，目前仅写出已收集并且经过验证的案例分享🙉 大家在做前端开发过程中势必会和H5打交道&lt;这里指的H5仅表示在苹果系统下运行的H5&gt;，在原本不应该出现的异常行为经常会搞得稀里糊涂，遂去各类搜索引擎搜索结局方案，本文故此摘录各类表现在苹果环境下的开发“异常行为”，并且给出大概可行的兼容方案来帮助大家单项搜集的烦恼 可能存在兼容性问题搜集 1.Date.parse() parse() 方法可解析一个日期时间字符串，并返回 1970/1/1 午夜距离该日期时间的毫秒数。W3C参考文档 代码部分: 1Date.parse(&quot;2020-02-02 00:00:00&quot;) 可能会在苹果环境中出现NaN的返回结果 解决方案是: 不使用具体时间 =&gt; Date.parse(&quot;2020-02-02&quot;) 使用“**/”代替“-**”来分割日期 =&gt; Date.parse(&quot;2020/02/02 00:00:00&quot;) 替换字符串为第二种方案 =&gt; Date.parse(&quot;2020-02-02 00:00:00&quot;.replace(/-/g, &#39;/&#39;)) 2.window.open() open() 方法用于打开一个新的浏览器窗口或查找一个已命名的窗口。W3C参考文档 代码部分: 1window.open(&#x27;//rexhang.com&#x27;); 可能会在苹果环境中出现被阻止打开的情况，这是由于苹果安全策略进行了拦截 解决方案是: 使用window.location.href = &#39;//rexhang.com&#39;代替 使用window.location.replace(&#39;//rexhang.com&#39;)代替 3.待博主更新…结语 这样的坑还有许多许多不仅仅是ios还有android也会存在一些兼容性问题，本文会长期更新，尽可能搜集更多的兼容案例，如有更多案例本文未提到的，希望大家踊跃提出，反馈在下方评论里，多谢大家~","categories":[{"name":"大前端","slug":"大前端","permalink":"https://blog.rexhang.com/categories/%E5%A4%A7%E5%89%8D%E7%AB%AF/"},{"name":"兼容性","slug":"大前端/兼容性","permalink":"https://blog.rexhang.com/categories/%E5%A4%A7%E5%89%8D%E7%AB%AF/%E5%85%BC%E5%AE%B9%E6%80%A7/"},{"name":"心得","slug":"大前端/兼容性/心得","permalink":"https://blog.rexhang.com/categories/%E5%A4%A7%E5%89%8D%E7%AB%AF/%E5%85%BC%E5%AE%B9%E6%80%A7/%E5%BF%83%E5%BE%97/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://blog.rexhang.com/tags/javascript/"},{"name":"前端多端开发兼容性","slug":"前端多端开发兼容性","permalink":"https://blog.rexhang.com/tags/%E5%89%8D%E7%AB%AF%E5%A4%9A%E7%AB%AF%E5%BC%80%E5%8F%91%E5%85%BC%E5%AE%B9%E6%80%A7/"},{"name":"ios","slug":"ios","permalink":"https://blog.rexhang.com/tags/ios/"},{"name":"macos","slug":"macos","permalink":"https://blog.rexhang.com/tags/macos/"},{"name":"apple","slug":"apple","permalink":"https://blog.rexhang.com/tags/apple/"},{"name":"苹果","slug":"苹果","permalink":"https://blog.rexhang.com/tags/%E8%8B%B9%E6%9E%9C/"}]},{"title":"Vue双向绑定的原理","slug":"Vue双向绑定的原理","date":"2021-01-10T07:56:57.000Z","updated":"2022-10-25T14:41:49.322Z","comments":true,"path":"2021/01/10/articles/2/","link":"","permalink":"https://blog.rexhang.com/2021/01/10/articles/2/","excerpt":"","text":"双向绑定原理及简单实现Vue是采用数据劫持结合发布者-订阅者模式的方式，通过new Proxy()来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。 Vue3.x与Vue2.x的区别仅是数据劫持的方式由Object.defineProperty更改为Proxy代理，其他代码不变Vue最核心的功能有两个，一是响应式的数据绑定系统，二是组件系统。本文仅探究双向绑定是怎样实现的。以及实现一个简化版的**Vue-lite** 一、访问器属性访问器属性是对象中的一种特殊属性，它不能直接在对象中设置，而必须通过defineProperty()方法单独定义。 123456789101112const obj = &#123;&#125;;Object.defineProperty(obj, &#x27;hello&#x27;, &#123; set: newVal =&gt; &#123; console.log(&#x27;set方法被调用了&#x27;); console.log(&#x27;newVal=&#x27;+newVal); &#125;, get: () =&gt; &#123; console.log(&#x27;get方法被调用了&#x27;); &#125;&#125;);obj.hello = &#x27;xxx&#x27;; // 会触发访问器属性中的set方法 参数是xxxobj.hello // 会触发访问器属性中的get方法 其中**get(),set()**方法就是实现双向绑定的关键 二、极简双向绑定的实现html部分: 1234567891011121314&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Vue-lite&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;input type=&quot;text&quot; id=&quot;inputs&quot; /&gt; &lt;p id=&quot;tips&quot;&gt;&lt;/p&gt; &lt;button id=&quot;btn&quot;&gt;设置新值&lt;/button&gt; &lt;script src=&quot;./js/Vue-lite.js&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; Vue-lite.js: 123456789101112131415161718192021222324const inputs = document.querySelector(&#x27;#inputs&#x27;);const tips = document.querySelector(&#x27;#tips&#x27;);const btn = document.querySelector(&#x27;#btn&#x27;);const obj = &#123;&#125;;Object.defineProperty(obj, &#x27;hello&#x27;, &#123; set: newVal =&gt; &#123; inputs.value = newVal; tips.innerHTML = newVal; &#125;, get: () =&gt; &#123; console.log(&#x27;get方法被调用了&#x27;); return &#x27;123&#x27;; // 可以对值进行修改 &#125;&#125;);obj.hello = &#x27;xxx&#x27;; // 会触发访问器属性中的set方法 参数是xxxconsole.log(obj.hello); // 会触发访问器属性中的get方法inputs.addEventListener(&#x27;keyup&#x27;, e=&gt;&#123; obj.hello = e.target.value;&#125;);btn.addEventListener(&#x27;click&#x27;, e=&gt;&#123; obj.hello = &#x27;233&#x27;; // set数据&#125;);// 实现了 model =&gt; view 以及 view =&gt; model 的双向绑定。// 以上就是 Vue2.x 实现双向绑定的基本原理。 此例实现的效果是：随文本框输入文字的变化，span 中会同步显示相同的文字内容；在js或控制台显式的修改 obj.hello 的值，视图会相应更新。这样就实现了 model =&gt; view 以及 view =&gt; model 的双向绑定，就是Vue实现双向绑定的最基本原理。 三、细节优化上述示例仅仅是为了说明原理。我们最终要实现的是： 1234567&lt;div id=&quot;app&quot;&gt; &lt;div&gt; &lt;span&gt;姓名: &lt;/span&gt; &lt;input type=&quot;text&quot; name=&quot;name&quot; v-mode=&quot;name&quot; /&gt; &lt;/div&gt; &lt;p&gt;您输入的name是: &#123;&#123;name&#125;&#125;&lt;/p&gt;&lt;/div&gt; 123456const vm = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; name: &#x27;rexhang&#x27; &#125;&#125;); 首先做下需要实现功能点: 输入框以及文本节点与 data 中的数据绑定 输入框内容变化时，data 中的数据同步变化。即 view =&gt; model 的变化 data 中的数据变化时，文本节点的内容同步变化。即 model =&gt; view 的变化 html: 1234567891011121314&lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;name&quot; v-model=&quot;name&quot; /&gt; &lt;br /&gt; &#123;&#123;name&#125;&#125;&lt;/div&gt;&lt;script src=&quot;./js/Vue-lite.js&quot;&gt;&lt;/script&gt;&lt;script&gt; new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; name: &#x27;rexhang&#x27; &#125; &#125;);&lt;/script&gt; Vue-lite.js: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135function nodeToFragment(node, vm) &#123; // createDocumentFragment()方法，是用来创建一个虚拟的节点对象，或者说，是用来创建文档碎片节点。它可以包含各种类型的节点，在创建之初是空的。 let virtualDOM = document.createDocumentFragment(); let child; while( child = node.firstChild)&#123; compile(child, vm) virtualDOM.appendChild(child); &#125; return virtualDOM;&#125;function compile (node, vm)&#123; const reg = /\\&#123;\\&#123;(.*)\\&#125;\\&#125;/; console.log(node); console.log(node.nodeType); if (node.nodeType === 1)&#123; // 节点类型是元素 const attr = node.attributes; for(let i = 0; i &lt; attr.length; i++)&#123; console.log(attr[i].nodeName); if(attr[i].nodeName === &#x27;v-model&#x27;)&#123; // 提取v-model的value const name = attr[i].nodeValue; node.addEventListener(&#x27;input&#x27;, e=&gt;&#123; vm[name] = e.target.value; &#125;); // 将data的值赋给该node // node.value = vm.data[name]; node.value = vm[name]; node.removeAttribute(&#x27;v-model&#x27;); &#125; &#125; &#125; if (node.nodeType === 3)&#123; // 节点类型是text if(reg.test(node.nodeValue))&#123; // 正则来获取匹配到的字符串&#123;&#123;name&#125;&#125; =&gt; name let name = node.nodeValue.match(reg)[1].trim(); // 将data的值赋给该node // node.nodeValue = vm.data[name]; // node.nodeValue = vm[name]; console.log(vm, node, name); new Watcher(vm, node, name); &#125; &#125;&#125;function defineReactive(obj, key, val)&#123; const dep = new Dep(); Object.defineProperty(obj, key, &#123; set: newVal =&gt; &#123; if(newVal === val) return; val = newVal; console.log(val); dep.notify(); &#125;, get: () =&gt; &#123; if(Dep.target) dep.addSub(Dep.target); return val; &#125; &#125;)&#125;function observe (obj, vm) &#123; Object.keys(obj).forEach(key=&gt;&#123; defineReactive(vm, key, obj[key]); &#125;);&#125;const dep = new Dep();const pub = &#123; publish: ()=&gt;&#123; dep.notify(); &#125;&#125;const sub1 = &#123; update: function () &#123; console.log(1); &#125; &#125;const sub2 = &#123; update: function () &#123; console.log(2); &#125; &#125;const sub3 = &#123; update: function () &#123; console.log(3); &#125; &#125;function Dep () &#123; // this.subs = [sub1, sub2, sub3]; this.subs = [];&#125;// Dep.prototype.notify = function()&#123;// this.subs.forEach(sub=&gt;&#123;// sub.update();// &#125;)// &#125;Dep.prototype.addSub = function(sub)&#123; this.subs.push(sub)&#125;Dep.prototype.notify = function()&#123; this.subs.forEach(sub=&gt;&#123; sub.update(); &#125;)&#125;pub.publish();function Watcher(vm, node, name)&#123; Dep.target = this; this.name = name; this.node = node; this.vm = vm; this.update(); Dep.target = null;&#125;Watcher.prototype = &#123; update: function()&#123; this.get(); this.node.nodeValue = this.value; &#125;, get: function()&#123; this.value = this.vm[this.name]; &#125;&#125;function Vue(opt)&#123; this.data = opt.data; observe(this.data, this); const rootDom = opt.el; const dom = nodeToFragment(document.querySelector(rootDom), this); // 编译完成，将dom返回到app中 document.querySelector(rootDom).appendChild(dom);&#125; 最终实现效果: 四、总结 Object.defineProperty 来进行数据中转(劫持)，从而实现事件的发布和后续触发订阅者的监听来实现数据绑定 实现一个监听器 observe 用来劫持并监听所有属性，如有变动，就通知订阅者 实现一个订阅者 Watcher 每个Watcher都绑定一个更新函数，可以把收到的属性变化通知并执行相应的函数，更新视图 实现一个解析器 compile 可以循环解析全部节点获取相关指令，初始化数据，初始化订阅 原文参考 Vue3.x双向绑定原理的实现参考","categories":[{"name":"大前端","slug":"大前端","permalink":"https://blog.rexhang.com/categories/%E5%A4%A7%E5%89%8D%E7%AB%AF/"},{"name":"面试经","slug":"大前端/面试经","permalink":"https://blog.rexhang.com/categories/%E5%A4%A7%E5%89%8D%E7%AB%AF/%E9%9D%A2%E8%AF%95%E7%BB%8F/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://blog.rexhang.com/tags/javascript/"},{"name":"前端框架","slug":"前端框架","permalink":"https://blog.rexhang.com/tags/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/"},{"name":"Vue","slug":"Vue","permalink":"https://blog.rexhang.com/tags/Vue/"}]},{"title":"几种判断数组的方法","slug":"几种判断数组的方法","date":"2021-01-09T16:01:22.000Z","updated":"2022-10-25T14:41:49.323Z","comments":true,"path":"2021/01/10/articles/1/","link":"","permalink":"https://blog.rexhang.com/2021/01/10/articles/1/","excerpt":"","text":"一、前言众所周知，js是门“动态”、“弱类型”编程语言，这意味着在js中可以任性定义变量，同时，“任性”也意味着需常在项目开发中对变量做类型判断，曾几何时，对数组变量的类型判断是件很痛苦的事情，开发人员想出多种方案来对数组做出准确的类型判断，但效果不佳，直到ES5标准“入主中原”，判断数组类型有了标准的isArray()官方利剑，才降伏了数组类型判断这条恶龙，世间得一清，但在此之前开发者是如何判断数组类型的？判断数组类型为何会如此玄学？为何要判断数组类型？带着这些疑问，吾跋山涉水，探寻各方资料，整理消化后遂成此文，以记之。 二、判断js数组类型为何麻烦？1、语言本身的“缺陷”js是门“动态”“弱类型”编程语言，这意味着js在定义和使用变量时可以“任性”，在ES6之前，我们定义变量一般使用“var”来定义： 123var name = &#x27;jack&#x27;;name = 20;name = [&#x27;aa&#x27;]; 在上述例子中，name变量初始定义为字符串类型，而后变为数字类型，最后摇身一变成为数组类型，这种任性摇摆的特性就是其“动态”特性，在java中我们定义一个字符串变量须如此定义：String name = ‘jack’，java通过一个String前缀“显式的”、“强制的”指定name变量为字符串类型，之后不得对该name变量进行类型变换(如果执行name = 22将会报type类型转换错误)，但js采用的是弱类型定义方案，在定义变量时使用var声明了一个变量，弱化了类型前缀的限制，并没强制锁死变量类型，之后可以随意更改其类型。动态弱类型这种声明变量的方案用起来可以随性而为，无须顾虑太多，随性的代码书写如若不加管制必将招致灾难性的代码bug。 2、js类型判断的“不足”其实动态弱类型的语言特性并不是决定js判断数组类型麻烦的必然原因，js语言因为历史原因，其创造者在开发之初将其定位为简单的网页小助手语言，为了轻巧、快速的完成小任务开发选择了“动态弱类型”的语言方案，PHP亦为动态弱类型语言，但在处理类型判断时，PHP用一个gettype()方法可以轻松、精准的搞定(PHP作为世界上世界上最好的语言还是有点东西的🤣)，PHP有gettype()这枚银弹，js有吗，嗯，算有吧，js最常用的是用typeof操作符来获取数据类型，看typeof这个名字是不是感觉很厉害？感觉会跟PHP一样轻松简单？但随后你会发现：typeof操作符是个很局限的类型获取方案，用它对基本数据类型做判断还算过得去，但在涉及到引用类型判断这种细活时就显得很low了… 三、判断js数组类型的几个“方案”1.typeof ❌ typeof在判断基础数据类型时尚有问题，更别说用来判断子孙繁多的引用类型了，typeof在判断引用类型时一刀切的统统返回object, 如 1234567var obj = &#123;&#125;;var arr = [];var map = new Map();typeof obj; // objecttypeof arr; // objecttypeof map; // object 故此，不适应于判断数据，PASS 2.data instanceof Array ❌ instanceof是js用来判断继承关系的运算符（js基于原型链实现继承，故instanceof判断的就是对应的类是否存在于变量的原型链上），根据这个特性可以如此来判断数组类型： 12const arr = [1, 2, 3];console.log(arr instanceof Array); // true 控制台打印显示如下: 从打印的结果可以看到Array存在于数组[1, 2, 3]的原型链上，故[1, 2, 3] instanceof Array === true; 利用instanceof的这个特性可以判断数组类型，但是instanceof运算符有个弊端 就是arr instanceof Object也是返回true: 12const arr2 = [1, 2, 3];console.log(arr2 instanceof Object); // true 控制台打印显示如下: 故此，不适应于判断数据，PASS 3.constructor ✔ 在JavaScript中, constructor属性会返回对象的构造函数。 1234let arr = [1, 2, 3];console.log(arr.constructor === Array); // truelet arr = [1, 2, 3];console.log(arr.constructor === Object); // false 控制台打印显示如下: 从打印结果显示，是满足我们的数据类型判断的，并且没有出现第二种判断方式instanceof方法的问题，因此是可以采用的。 4.Object.prototype.toString() ✔ Object.prototype.toString()能获取到变量的“类目名”，在js中万物皆为对象，万物皆有“类目名”，每个变量、对象、数组等都有一个唯一的类目名（这个类目名类似于人类给各类动植物起的“学名”），该方案通过获取目标变量的类目名([object Array])进行判断，如果类目名一致则证明目标变量为数组类型： 12let arr = [1, 2, 3];console.log( Object.prototype.toString.call(arr) === &#x27;[object Array]&#x27; ); // [object Array]: string; 返回 true Tips: 这种方法获取各种类型数据都有与之对应的字符串匹配值 12345678Object.prototype.toString.call([]); // &quot;[object Array]&quot;Object.prototype.toString.call(&#123;&#125;); // &quot;[object Object]&quot;Object.prototype.toString.call(&#x27;&#x27;); // &quot;[object String]&quot;Object.prototype.toString.call(1); // &quot;[object Number]&quot;Object.prototype.toString.call(function f()&#123;&#125;); // &quot;[object Function]&quot;Object.prototype.toString.call(); // &quot;[object Undefined]&quot;Object.prototype.toString.call(null); // &quot;[object Null]&quot;Object.prototype.toString.call(document); // &quot;[object HTMLDocument]&quot; 从打印结果显示，是满足我们的数据类型判断的，因此是可以采用的。 5.Array.isArray() ✔ 该方法是ES5标准规定的判断数组类型的标准方法，虽然Object.prototype.toString()方法可用来判断数组类型，但未免显得有点hack，又因自家typeof类型操作符给予厚望，辱没众望，如果随便更改typeof的返回结果势必会导致天下大乱，instanceof运算符又存在不同frame的局限性难堪大任，ES5不得不亡羊补牢的设计了isArray()方法来“增量”的解决数组判断难题。 12Array.isArray([1, 2, 3]); // trueArray.isArray(&#123;&#125;); // false 从打印结果显示，是满足我们的数据类型判断的，因此是可以采用的。 四、为何要判断数组类型？前面说过js属于动态弱类型语言，可能某个变量用着用着就莫名其妙的变了类型（自己不小心更改类型，引入的第三方代码库，因为同名变量改变了类型），如果你设想的是某个变量为数组类型，但因某个逻辑变成了基本类型，这时如果调用数组的方法注定会报错，凡此种种导致的问题，数不胜数，具体的问题实践多了懂得就懂。 五、结语近几年前端项目愈发复杂庞大，为更好的构建高性能的前端项目，诞生了“react、angular、vue”等数据驱动型解决方案，大量的数据、大量的组件和类对数据类型的判断需求愈发频繁，但因为js动态弱类型语言特性，加之其类型判断的坑爹性，所以各路开发者希望完善和升级js，在ES6标准中，新的const变量定义方案能很好的应对变量动态性问题，微软开发的“typescript”能够实现强类型变量定义，可应对弱类型定义问题。这些方案极大的减少了早期js变量任性定义带来的各种问题，虽然判断数组类型在未来开发中可能会成为历史云烟，但理解其相关的基础和历史演变却是一件很【浪漫】的事情，因为在理解了它的相关坑爹性和进化史有助于我们更好的思考和优化。爱之深，责之切，希望js能在未来变得更加锋利可靠，也希望少为一些坑爹特性而想出一些hack方案(额，比如——&gt;Object.prototype.toString()方法)。","categories":[{"name":"大前端","slug":"大前端","permalink":"https://blog.rexhang.com/categories/%E5%A4%A7%E5%89%8D%E7%AB%AF/"},{"name":"面试经","slug":"大前端/面试经","permalink":"https://blog.rexhang.com/categories/%E5%A4%A7%E5%89%8D%E7%AB%AF/%E9%9D%A2%E8%AF%95%E7%BB%8F/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://blog.rexhang.com/tags/javascript/"},{"name":"javascript数组","slug":"javascript数组","permalink":"https://blog.rexhang.com/tags/javascript%E6%95%B0%E7%BB%84/"}]},{"title":"javascript函数防抖与节流","slug":"javascript函数防抖与节流","date":"2021-01-04T18:03:33.000Z","updated":"2022-10-25T14:41:49.323Z","comments":true,"path":"2021/01/05/articles/2/","link":"","permalink":"https://blog.rexhang.com/2021/01/05/articles/2/","excerpt":"","text":"概念和例子函数防抖(debounce) 在事件被触发n秒后再执行回调，如果在这n秒内又被触发，则重新计时。 12345678910// 模拟一段ajax请求function ajax(content) &#123; console.log(&#x27;ajax request &#x27; + content)&#125;let inputa = document.getElementById(&#x27;unDebounce&#x27;)inputa.addEventListener(&#x27;keyup&#x27;, function (e) &#123; ajax(e.target.value)&#125;) 运行效果如图: 可以看到，我们只要按下键盘，就会触发这次ajax请求。不仅从资源上来说是很浪费的行为，而且实际应用中，用户也是输出完整的字符后，才会请求。下面我们优化一下： 1234567891011121314151617181920212223// 模拟一段ajax请求function ajax(content) &#123; console.log(&#x27;ajax request &#x27; + content)&#125;function debounce(fun, delay) &#123; return function (args) &#123; let that = this let _args = args clearTimeout(fun.id) fun.id = setTimeout(function () &#123; fun.call(that, _args) &#125;, delay) &#125;&#125; let inputb = document.getElementById(&#x27;debounce&#x27;)let debounceAjax = debounce(ajax, 500)inputb.addEventListener(&#x27;keyup&#x27;, function (e) &#123; debounceAjax(e.target.value)&#125;) 运行效果如图: 可以看到，我们加入了防抖以后，当你在频繁的输入时，并不会发送请求，只有当你在指定间隔内没有输入时，才会执行函数。如果停止输入但是在指定间隔内又输入，会重新触发计时。 个人理解 函数防抖就是法师发技能的时候要读条，技能读条没完再按技能就会重新读条。 函数节流(throttle) 规定在一个单位时间内，只能触发一次函数。如果这个单位时间内触发多次函数，只有一次生效。 看代码: 12345678910111213141516171819202122232425function throttle(fun, delay) &#123; let last, deferTimer return function (args) &#123; let that = this let _args = arguments let now = +new Date() if (last &amp;&amp; now &lt; last + delay) &#123; clearTimeout(deferTimer) deferTimer = setTimeout(function () &#123; last = now fun.apply(that, _args) &#125;, delay) &#125;else &#123; last = now fun.apply(that,_args) &#125; &#125;&#125;let throttleAjax = throttle(ajax, 1000)let inputc = document.getElementById(&#x27;throttle&#x27;)inputc.addEventListener(&#x27;keyup&#x27;, function(e) &#123; throttleAjax(e.target.value)&#125;) 看一下运行结果: 可以看到，我们在不断输入时，ajax会按照我们设定的时间，每1s执行一次。 个人理解 函数节流就是fps游戏的射速，就算一直按着鼠标射击，也只会在规定射速内射出子弹。 总结 函数防抖和函数节流都是防止某一时间频繁触发，但是这两兄弟之间的原理却不一样。 函数防抖是某一段时间内只执行一次，而函数节流是间隔时间执行。 结合应用场景 防抖(debounce) search搜索联想，用户在不断输入值时，用防抖来节约请求资源。 window触发resize的时候，不断的调整浏览器窗口大小会不断的触发这个事件，用防抖来让其只触发一次 节流（throttle） 鼠标不断点击触发，mousedown(单位时间内只触发一次) 监听滚动事件，比如是否滑到底部自动加载更多，用throttle来判断","categories":[{"name":"大前端","slug":"大前端","permalink":"https://blog.rexhang.com/categories/%E5%A4%A7%E5%89%8D%E7%AB%AF/"},{"name":"面试经","slug":"大前端/面试经","permalink":"https://blog.rexhang.com/categories/%E5%A4%A7%E5%89%8D%E7%AB%AF/%E9%9D%A2%E8%AF%95%E7%BB%8F/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://blog.rexhang.com/tags/javascript/"}]},{"title":"如何创建一个TC的免费托管服务","slug":"如何创建一个TC的免费托管服务","date":"2021-01-04T17:06:21.000Z","updated":"2022-10-25T14:41:49.324Z","comments":true,"path":"2021/01/05/articles/1/","link":"","permalink":"https://blog.rexhang.com/2021/01/05/articles/1/","excerpt":"","text":"首先&nbsp;&nbsp;&nbsp;&nbsp;需要先全局安装cli, 本地预先安装好nodejs以及git 1$ npm i -g @cloudbase/cli hexo-cli 然后&nbsp;&nbsp;&nbsp;&nbsp;初始化一个hexo项目目录 1$ hexo init 初始化完毕后, 启动服务本地编写文章 1$ hexo s 发布&nbsp;&nbsp;&nbsp;&nbsp;发布就很简单了，获取授权，生成静态代码，使用cli推送到远程托管 123$ cloudbase login$ hexo g$ cloudbase hosting deploy public -e [EnvID] tips 环境ID(EnvID)获取方法: 链接 创建环境指引: 链接","categories":[{"name":"腾讯云","slug":"腾讯云","permalink":"https://blog.rexhang.com/categories/%E8%85%BE%E8%AE%AF%E4%BA%91/"},{"name":"操作技巧","slug":"腾讯云/操作技巧","permalink":"https://blog.rexhang.com/categories/%E8%85%BE%E8%AE%AF%E4%BA%91/%E6%93%8D%E4%BD%9C%E6%8A%80%E5%B7%A7/"}],"tags":[{"name":"腾讯云","slug":"腾讯云","permalink":"https://blog.rexhang.com/tags/%E8%85%BE%E8%AE%AF%E4%BA%91/"}]}],"categories":[{"name":"大前端","slug":"大前端","permalink":"https://blog.rexhang.com/categories/%E5%A4%A7%E5%89%8D%E7%AB%AF/"},{"name":"面试经","slug":"大前端/面试经","permalink":"https://blog.rexhang.com/categories/%E5%A4%A7%E5%89%8D%E7%AB%AF/%E9%9D%A2%E8%AF%95%E7%BB%8F/"},{"name":"面试经","slug":"面试经","permalink":"https://blog.rexhang.com/categories/%E9%9D%A2%E8%AF%95%E7%BB%8F/"},{"name":"前端","slug":"面试经/前端","permalink":"https://blog.rexhang.com/categories/%E9%9D%A2%E8%AF%95%E7%BB%8F/%E5%89%8D%E7%AB%AF/"},{"name":"JavaScript","slug":"面试经/前端/JavaScript","permalink":"https://blog.rexhang.com/categories/%E9%9D%A2%E8%AF%95%E7%BB%8F/%E5%89%8D%E7%AB%AF/JavaScript/"},{"name":"前端","slug":"前端","permalink":"https://blog.rexhang.com/categories/%E5%89%8D%E7%AB%AF/"},{"name":"开发工具","slug":"前端/开发工具","permalink":"https://blog.rexhang.com/categories/%E5%89%8D%E7%AB%AF/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"},{"name":"node","slug":"前端/开发工具/node","permalink":"https://blog.rexhang.com/categories/%E5%89%8D%E7%AB%AF/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/node/"},{"name":"css3","slug":"大前端/css3","permalink":"https://blog.rexhang.com/categories/%E5%A4%A7%E5%89%8D%E7%AB%AF/css3/"},{"name":"游戏引擎","slug":"大前端/游戏引擎","permalink":"https://blog.rexhang.com/categories/%E5%A4%A7%E5%89%8D%E7%AB%AF/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"效率","slug":"大前端/效率","permalink":"https://blog.rexhang.com/categories/%E5%A4%A7%E5%89%8D%E7%AB%AF/%E6%95%88%E7%8E%87/"},{"name":"前端开发","slug":"大前端/效率/前端开发","permalink":"https://blog.rexhang.com/categories/%E5%A4%A7%E5%89%8D%E7%AB%AF/%E6%95%88%E7%8E%87/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"},{"name":"图表","slug":"大前端/图表","permalink":"https://blog.rexhang.com/categories/%E5%A4%A7%E5%89%8D%E7%AB%AF/%E5%9B%BE%E8%A1%A8/"},{"name":"G2","slug":"大前端/图表/G2","permalink":"https://blog.rexhang.com/categories/%E5%A4%A7%E5%89%8D%E7%AB%AF/%E5%9B%BE%E8%A1%A8/G2/"},{"name":"兼容性","slug":"大前端/兼容性","permalink":"https://blog.rexhang.com/categories/%E5%A4%A7%E5%89%8D%E7%AB%AF/%E5%85%BC%E5%AE%B9%E6%80%A7/"},{"name":"心得","slug":"大前端/兼容性/心得","permalink":"https://blog.rexhang.com/categories/%E5%A4%A7%E5%89%8D%E7%AB%AF/%E5%85%BC%E5%AE%B9%E6%80%A7/%E5%BF%83%E5%BE%97/"},{"name":"腾讯云","slug":"腾讯云","permalink":"https://blog.rexhang.com/categories/%E8%85%BE%E8%AE%AF%E4%BA%91/"},{"name":"操作技巧","slug":"腾讯云/操作技巧","permalink":"https://blog.rexhang.com/categories/%E8%85%BE%E8%AE%AF%E4%BA%91/%E6%93%8D%E4%BD%9C%E6%8A%80%E5%B7%A7/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://blog.rexhang.com/tags/javascript/"},{"name":"前端技术","slug":"前端技术","permalink":"https://blog.rexhang.com/tags/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/"},{"name":"面试经","slug":"面试经","permalink":"https://blog.rexhang.com/tags/%E9%9D%A2%E8%AF%95%E7%BB%8F/"},{"name":"前端","slug":"前端","permalink":"https://blog.rexhang.com/tags/%E5%89%8D%E7%AB%AF/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://blog.rexhang.com/tags/JavaScript/"},{"name":"开发工具","slug":"开发工具","permalink":"https://blog.rexhang.com/tags/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"},{"name":"devtools","slug":"devtools","permalink":"https://blog.rexhang.com/tags/devtools/"},{"name":"node","slug":"node","permalink":"https://blog.rexhang.com/tags/node/"},{"name":"css3","slug":"css3","permalink":"https://blog.rexhang.com/tags/css3/"},{"name":"mask","slug":"mask","permalink":"https://blog.rexhang.com/tags/mask/"},{"name":"遮罩","slug":"遮罩","permalink":"https://blog.rexhang.com/tags/%E9%81%AE%E7%BD%A9/"},{"name":"cocos2d","slug":"cocos2d","permalink":"https://blog.rexhang.com/tags/cocos2d/"},{"name":"CocosCreator","slug":"CocosCreator","permalink":"https://blog.rexhang.com/tags/CocosCreator/"},{"name":"游戏引擎","slug":"游戏引擎","permalink":"https://blog.rexhang.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"javascript数组","slug":"javascript数组","permalink":"https://blog.rexhang.com/tags/javascript%E6%95%B0%E7%BB%84/"},{"name":"javascript字符串","slug":"javascript字符串","permalink":"https://blog.rexhang.com/tags/javascript%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"js小tips","slug":"js小tips","permalink":"https://blog.rexhang.com/tags/js%E5%B0%8Ftips/"},{"name":"js技巧","slug":"js技巧","permalink":"https://blog.rexhang.com/tags/js%E6%8A%80%E5%B7%A7/"},{"name":"React","slug":"React","permalink":"https://blog.rexhang.com/tags/React/"},{"name":"前端框架","slug":"前端框架","permalink":"https://blog.rexhang.com/tags/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/"},{"name":"前端多端开发兼容性","slug":"前端多端开发兼容性","permalink":"https://blog.rexhang.com/tags/%E5%89%8D%E7%AB%AF%E5%A4%9A%E7%AB%AF%E5%BC%80%E5%8F%91%E5%85%BC%E5%AE%B9%E6%80%A7/"},{"name":"ios","slug":"ios","permalink":"https://blog.rexhang.com/tags/ios/"},{"name":"macos","slug":"macos","permalink":"https://blog.rexhang.com/tags/macos/"},{"name":"apple","slug":"apple","permalink":"https://blog.rexhang.com/tags/apple/"},{"name":"苹果","slug":"苹果","permalink":"https://blog.rexhang.com/tags/%E8%8B%B9%E6%9E%9C/"},{"name":"Vue","slug":"Vue","permalink":"https://blog.rexhang.com/tags/Vue/"},{"name":"腾讯云","slug":"腾讯云","permalink":"https://blog.rexhang.com/tags/%E8%85%BE%E8%AE%AF%E4%BA%91/"}]}