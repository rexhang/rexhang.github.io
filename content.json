{"meta":{"title":"Rexhang的Blog","subtitle":"blog","description":"RexHang","author":"RexHang","url":"https://blog.rexhang.com","root":"/"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2024-09-05T08:02:13.544Z","updated":"2022-10-25T14:41:49.320Z","comments":false,"path":"/404.html","permalink":"https://blog.rexhang.com/404.html","excerpt":"","text":""},{"title":"关于","date":"2021-01-04T09:06:55.000Z","updated":"2022-10-25T14:41:49.325Z","comments":false,"path":"about/index.html","permalink":"https://blog.rexhang.com/about/index.html","excerpt":"","text":"Rexhang全身心致力于Web前端开发以及Nodejs、java等编程技术的研究包括javascript脚本，Jquery，Bootstrap，react，vue，angular等前端框架的研究，并不断完善自我争取更促进互联网与现实世界的更和谐并到更贴近的交互体验！"},{"title":"友情链接","date":"2024-09-05T08:02:13.544Z","updated":"2022-10-25T14:41:49.325Z","comments":false,"path":"links/index.html","permalink":"https://blog.rexhang.com/links/index.html","excerpt":"","text":""},{"title":"书单","date":"2024-09-05T08:02:13.544Z","updated":"2022-10-25T14:41:49.325Z","comments":false,"path":"books/index.html","permalink":"https://blog.rexhang.com/books/index.html","excerpt":"","text":""},{"title":"分类","date":"2024-09-05T08:02:13.544Z","updated":"2022-10-25T14:41:49.325Z","comments":false,"path":"categories/index.html","permalink":"https://blog.rexhang.com/categories/index.html","excerpt":"","text":""},{"title":"项目","date":"2024-09-05T08:02:13.544Z","updated":"2022-10-25T14:41:49.326Z","comments":false,"path":"repository/index.html","permalink":"https://blog.rexhang.com/repository/index.html","excerpt":"","text":""},{"title":"标签","date":"2024-09-05T08:02:13.544Z","updated":"2022-10-25T14:41:49.326Z","comments":false,"path":"tags/index.html","permalink":"https://blog.rexhang.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"编程相关书籍的阅读推荐","slug":"编程相关书籍的阅读推荐","date":"2025-03-04T06:30:02.000Z","updated":"2025-03-04T06:57:52.355Z","comments":true,"path":"2025/03/04/articles/1/","link":"","permalink":"https://blog.rexhang.com/2025/03/04/articles/1/","excerpt":"","text":"本篇博文主要是来推荐学习 JavaScript TypeScript Node.js Python 编程语言相关的书籍。 评价、口碑、ISBN等书籍相关信息查阅: 豆瓣读书 购买前，切记一定要先看评价！自己究竟适不适合阅读，然后再决定是否进行购买。 一、JavaScript 《JavaScript 高级程序设计 第4版》 ISBN: 9787115545381 出版年: 2020 《JavaScript 高级程序设计 第5版》 ISBN: 9787115655851 出版年: 2024 《JavaScript 权威指南 第7版》 ISBN: 9787111677222 出版年: 2021 《你不知道的 JavaScript 上》 ISBN: 9787115385734 出版年: 2015 《你不知道的 JavaScript 中》 ISBN: 9787115431165 出版年: 2016 《你不知道的 JavaScript 下》 ISBN: 9787115471659 出版年: 2018 《JavaScript DOM编程艺术 第2版》 ISBN: 9787115249999 出版年: 2011 二、TypeScript 《TypeScript编程》 ISBN: 9787519845964 出版年: 2020 《TypeScript 入门与实战》 ISBN: 9787111669722 出版年: 2020 《TypeScript 实战指南》 ISBN: 9787111626701 出版年: 2019 《深入理解TypeScript》 ISBN: 9787121376511 出版年: 2020 三、Node.js 《深入浅出 Node.js》 ISBN: 9787115335500 出版年: 2013 《Node.js 实战》 ISBN: 9787115352460 出版年: 2014 四、Python 《Python编程 第3版 从入门到实践》 ISBN: 9787115613639 出版年: 2023 《笨办法学 Python 3》 ISBN: 9787115478818 出版年: 2018 《“笨办法”学Python 第3版》 ISBN: 9787115350541 出版年: 2014 《Python Cookbook 第3版》 ISBN: 9787115379597 出版年: 2015 《流畅的Python》 ISBN: 9787115454157 出版年: 2017 《流畅的Python 第2版》 ISBN: 9787115612366 出版年: 2023 —END— ❤ enjoy it.","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://blog.rexhang.com/categories/JavaScript/"},{"name":"TypeScript","slug":"JavaScript/TypeScript","permalink":"https://blog.rexhang.com/categories/JavaScript/TypeScript/"},{"name":"Node.js","slug":"JavaScript/TypeScript/Node-js","permalink":"https://blog.rexhang.com/categories/JavaScript/TypeScript/Node-js/"},{"name":"Python","slug":"JavaScript/TypeScript/Node-js/Python","permalink":"https://blog.rexhang.com/categories/JavaScript/TypeScript/Node-js/Python/"},{"name":"阅读","slug":"JavaScript/TypeScript/Node-js/Python/阅读","permalink":"https://blog.rexhang.com/categories/JavaScript/TypeScript/Node-js/Python/%E9%98%85%E8%AF%BB/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://blog.rexhang.com/tags/JavaScript/"},{"name":"TypeScript","slug":"TypeScript","permalink":"https://blog.rexhang.com/tags/TypeScript/"},{"name":"Node.js","slug":"Node-js","permalink":"https://blog.rexhang.com/tags/Node-js/"},{"name":"Python","slug":"Python","permalink":"https://blog.rexhang.com/tags/Python/"},{"name":"阅读","slug":"阅读","permalink":"https://blog.rexhang.com/tags/%E9%98%85%E8%AF%BB/"}]},{"title":"《JavaScript 权威指南第七版》中英文对照版","slug":"《JavaScript 权威指南第七版》中英文对照版","date":"2025-02-22T12:30:10.000Z","updated":"2025-02-22T16:38:43.320Z","comments":true,"path":"2025/02/22/articles/1/","link":"","permalink":"https://blog.rexhang.com/2025/02/22/articles/1/","excerpt":"","text":"本篇博文推荐一本书籍 《JavaScript 权威指南第七版》中英文对照版，博主本人参与了该项目的部分翻译工作。 《JavaScript 权威指南》书籍介绍： JavaScript是Web编程语言，也是很多软件开发者使用的编程语言。近25年来，这本畅销书一直是几十万JavaScript程序员必读的技术著作，本版已经更新到涵盖JavaScript的2020版。书中令人深思、富有启发性的示例随处可见。 这本“犀牛书”在很多工程师心目中有着至高无上的地位。如果你由于种种原因错过了它之前的版本，那一定不要再错过这一版了！ 本书介绍JavaScript语言和由浏览器与Node实现的JavaScript API。本书适合有一定编程经验、想学习JavaScript读者，也适合已经在使用JavaScript但希望更深入地理解进而真正掌握这门语言的程序员。 本书的目标是全面地讲解JavaScript语言，对JavaScript程序中可能用到的重要的客户端API和服务器端API提供深入的介绍。本书篇幅较长，内容非常详尽，相信认…(展开全部) JavaScript是Web编程语言，也是很多软件开发者使用的编程语言。近25年来，这本畅销书一直是几十万JavaScript程序员必读的技术著作，本版已经更新到涵盖JavaScript的2020版。书中令人深思、富有启发性的示例随处可见。 这本“犀牛书”在很多工程师心目中有着至高无上的地位。如果你由于种种原因错过了它之前的版本，那一定不要再错过这一版了！ 本书介绍JavaScript语言和由浏览器与Node实现的JavaScript API。本书适合有一定编程经验、想学习JavaScript读者，也适合已经在使用JavaScript但希望更深入地理解进而真正掌握这门语言的程序员。 本书的目标是全面地讲解JavaScript语言，对JavaScript程序中可能用到的重要的客户端API和服务器端API提供深入的介绍。本书篇幅较长，内容非常详尽，相信认真研究本书的读者都能获益良多。 David Flanagan从1995起就开始使用JavaScript并写作本书的第1版。他拥有麻省理工学院计算机科学与工程学位，目前是VMware的一名软件工程师。 目前主要有以下版本： 第一版（1997年） 由David Flanagan编写，涵盖JavaScript 1.2。 主要针对Netscape Navigator和Internet Explorer 4。 第二版（2002年） 更新至JavaScript 1.5，新增正则表达式、异常处理等内容。 涵盖IE 6和Netscape 6。 第三版（2006年） 更新至JavaScript 1.5和1.6，新增JSON、E4X等特性。 涵盖IE 7和Firefox 1.5。 第四版（2011年） 更新至ECMAScript 5，新增严格模式、JSON支持等。 涵盖现代浏览器如IE 9、Firefox 4、Chrome 7等。 第五版（2012年） 更新至ECMAScript 5.1，修正错误并改进内容。 涵盖IE 10、Firefox 12、Chrome 18等。 第六版（2015年） 更新至ECMAScript 6（ES2015），新增箭头函数、类、模块等。 涵盖现代浏览器如Edge、Firefox 40、Chrome 45等。 第七版（2020年） 更新至ECMAScript 2020（ES11），新增可选链、空值合并等特性。 涵盖现代浏览器如Edge 80、Firefox 72、Chrome 80等。 各个版本的主要区别： 语言版本：各版对应不同ECMAScript标准，新版涵盖更多现代特性。 浏览器支持：新版涵盖更多现代浏览器及其特性。 内容更新：新版增加新特性和最佳实践，删除过时内容。 最后放上体验地址： 1、在线阅读地址: 《JavaScript 权威指南第七版》中英文对照版 2、项目开源地址: https://gitee.com/rexhang/doc-jstdg7 此项目基于 vuepress 进行开发，以提供比 GitHub Markdown 更佳的阅读体验。 —END— 参考文档: [1] JavaScript-The-Definitive-Guide-7th-zh ❤ enjoy it.","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://blog.rexhang.com/categories/JavaScript/"},{"name":"电子书","slug":"JavaScript/电子书","permalink":"https://blog.rexhang.com/categories/JavaScript/%E7%94%B5%E5%AD%90%E4%B9%A6/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://blog.rexhang.com/tags/JavaScript/"},{"name":"电子书","slug":"电子书","permalink":"https://blog.rexhang.com/tags/%E7%94%B5%E5%AD%90%E4%B9%A6/"}]},{"title":"Ollama如何更改安装位置及自定义模型下载目录","slug":"Ollama如何更改安装位置及自定义模型下载目录","date":"2025-02-18T10:30:10.000Z","updated":"2025-02-22T16:10:22.835Z","comments":true,"path":"2025/02/18/articles/1/","link":"","permalink":"https://blog.rexhang.com/2025/02/18/articles/1/","excerpt":"","text":"本文主要针对已经默认安装过后的用户使用，如果你还未安装主程序包，想要将 Ollama 应用程序安装在主目录以外的位置，请使用以下标志启动安装程序。 1OllamaSetup.exe /DIR=&quot;d:\\some\\location&quot; Windows系统下由于Ollama默认安装位置以及模型下载位置一般在C盘，有较多弊端，故做一教程以记录一下。 为什么不推荐将软件安装在C盘 系统性能下降C盘通常存放操作系统文件，软件安装在此会占用空间，导致系统运行变慢，尤其是SSD容量有限时。 系统崩溃风险增加软件安装在C盘可能影响系统文件，增加系统崩溃或启动失败的风险。 重装系统时数据丢失重装系统通常会格式化C盘，导致软件和数据丢失，增加恢复难度。 磁盘空间不足C盘空间有限，安装大型软件会迅速耗尽空间，影响系统更新和其他操作。 备份和恢复复杂系统备份时，C盘上的软件会增加备份文件大小，延长备份和恢复时间。 权限问题某些软件需要管理员权限，安装在C盘可能引发权限冲突，导致运行异常。 1、更改ollama安装位置Ollama默认装位置一般会在: C:\\Users\\xxx\\AppData\\Local\\Programs\\Ollama 进行存储的。 Ollama对于它下载的模型(models及其配置文件)位置一般会在: C:\\Users\\xxx\\.ollama 进行存储的。 其中 xxx 是你的用户名 此时我们可以在你想要的盘创建 Ollama 文件夹，然后在里面再创建 models 子文件夹存用于放模型，再将上述两个文件夹移动到该文件夹下。 以D盘举例: 接下来移动 C:\\Users\\xxx\\AppData\\Local\\Programs\\Ollama 下的所有内容到 D:\\Ollama 下。 然后再移动 C:\\Users\\xxx\\.ollama\\models 下的所有内容到 D:\\Ollama\\models 下。 2、更改环境变量按 Win + R 打开 “运行” 对话框。 输入以下命令(管理员模式)： 1rundll32 sysdm.cpl,EditEnvironmentVariables 然后回车确定，打开环境变量编辑框，如果系统变量区 Path 不可编辑，可以使用如下方式打开环境变量编辑框。 参照下图顺序，Path变量增加 D:\\Ollama\\，在系统变量下新建系统变量 变量名 OLLAMA_MODELS 变量值 D:\\Ollama\\models 3、验证结果打开命令行运行: ollama --version 会显示Ollama的版本号 ollama ls 命令会显示当前系统下所有安装的本地模型列表 ollama rm [模型名称] 可以删除指定模型 ollama run deepseek-r1:14b 命令行模式下运行本地的 deepseek-r1:14b 模型 总结本文主要介绍了 Ollama如何更改安装位置及自定义模型下载目录。 —END— 参考文档: [1] Ollama for Windows document ❤ enjoy it.","categories":[{"name":"AI","slug":"AI","permalink":"https://blog.rexhang.com/categories/AI/"},{"name":"Ollama","slug":"AI/Ollama","permalink":"https://blog.rexhang.com/categories/AI/Ollama/"},{"name":"DeepSeek","slug":"AI/Ollama/DeepSeek","permalink":"https://blog.rexhang.com/categories/AI/Ollama/DeepSeek/"}],"tags":[{"name":"AI","slug":"AI","permalink":"https://blog.rexhang.com/tags/AI/"},{"name":"Ollama","slug":"Ollama","permalink":"https://blog.rexhang.com/tags/Ollama/"},{"name":"DeepSeek","slug":"DeepSeek","permalink":"https://blog.rexhang.com/tags/DeepSeek/"}]},{"title":"Chrome Prerender2.0 - 新一代 Web 预渲染技术","slug":"Chrome Prerender2.0 - 新一代 Web 预渲染技术","date":"2023-10-13T04:00:00.000Z","updated":"2023-10-13T08:28:51.232Z","comments":true,"path":"2023/10/13/articles/1/","link":"","permalink":"https://blog.rexhang.com/2023/10/13/articles/1/","excerpt":"","text":"如何在 Chrome 浏览器中更快地加载网站? 这是本篇文章即将讨论的主题。 📃前言Chrome浏览器在ver.103中引入了许多新功能，例如 Journeys、新的隐私指南界面、扩展入门等，仔细查看 Chrome 的隐藏标志，我们发现了另一个可以显着加快网站加载速度的功能。 这项技术功能可用于预加载和渲染内容，可以大大的提高用户访问网站的体验，取代了旧版 Chrome 中的 NoState Prefetch 预渲染 并且消耗资源更少。 ❔如何启用确保你的Chrome版本在 103+ 查看 chrome://flags 输入 prerender 确保相关项 是 Enabled 状态 根据系统提示进行重启动浏览器。 ❔Prerender2.0的使用使用 Prerender2.0 机制需要使用新增的 Speculation Rules API，此API可同时支持触发 Prefetch、NSP、Prerender 机制。 1、Prefetch（预取）机制： 预取是一种优化策略，通过在用户点击链接之前提前获取相关资源，以减少加载时间。这可以包括预先加载链接指向的页面的CSS、JavaScript、图像等内容，提高用户体验。2、NSP（Next Scheduled Prefetch）机制： NSP 是一种进一步的优化，它预定了将来可能发生的预取操作。系统会根据用户行为和网站的预取策略，提前获取可能被访问的页面资源，以减少未来导航时的加载时间。3、Prerender（预渲染）机制： 预渲染是一种更进一步的优化技术，它不仅预取资源，还预先渲染整个页面。这意味着浏览器在用户导航到页面之前会预先加载、执行 JavaScript 和渲染页面，以便在用户实际导航到该页面时可以立即呈现。这有助于显著缩短页面加载时间。 可以通过 (&#39;supports&#39; in HTMLScriptElement &amp;&amp; HTMLScriptElement.supports(&#39;speculationrules&#39;)) 来查看当前运行环境的支持情况 API 使用: 123456789101112131415161718&lt;script type=&quot;speculationrules&quot;&gt; &#123; &quot;prerender&quot;: [ &#123;&quot;source&quot;: &quot;list&quot;, &quot;urls&quot;: [&quot;next.html&quot;, &quot;./PrefetchTestNew.html&quot;]&#125; ], &quot;prefetch&quot;: [ &#123;&quot;source&quot;: &quot;list&quot;, &quot;urls&quot;: [&quot;next.html&quot;], &quot;requires&quot;: [&quot;anonymous-client-ip-when-cross-origin&quot;]&#125; ], &quot;prefetch_with_subresources&quot;: [ &#123;&quot;source&quot;: &quot;list&quot;, &quot;urls&quot;: [&quot;next.html&quot;], &quot;requires&quot;: [&quot;anonymous-client-ip-when-cross-origin&quot;]&#125; ] &#125;&lt;/script&gt; API 主要参数说明: 类型 含义 备注 prerender 使用预渲染机制 / prefetch 使用预加载机制，仅预加载主文档(Document) 内部使用 SimpleURLLoader 实现主文档的预加载 prefetch_with_subresources 使用预加载机制，预加载主文档 + 关键子资源。功能效果类似于NSP 内部使用 SimpleURLLoader 实现主文档的预加载 requires 在确保客户端IP对服务端不可见时，可预加载跨域资源 value只能为 anonymous-client-ip-when-cross-origin，且 只支持 key为 prefetch 和 prefetch_with_subresources 的场景下使用 根据支持情况使用: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;Prerendering with web-vitals: index&lt;/title&gt; &lt;link id=&quot;favicon&quot; rel=&quot;icon&quot; href=&quot;https://glitch.com/favicon.ico&quot; type=&quot;image/x-icon&quot; /&gt; &lt;meta http-equiv=&quot;Content-Security-Policy&quot; content=&quot;script-src &#x27;strict-dynamic&#x27; &#x27;sha256-kBytAlkzbRIYPXxDAM/I6PhcHCfaLyEcc48s76/JtOI=&#x27;&quot;&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;Start page&lt;/h1&gt; &lt;p&gt;&lt;a href=&quot;next.html&quot;&gt;This link should be prerendered&lt;/a&gt;&lt;/p&gt; &lt;p&gt;&lt;a href=&quot;next2.html&quot;&gt;This link should also be prerendered&lt;/a&gt;&lt;/p&gt; &lt;hr&gt; &lt;pre id=&quot;output1&quot;&gt;&lt;/pre&gt; &lt;pre id=&quot;output2&quot;&gt;&lt;/pre&gt; &lt;hr&gt; &lt;p&gt;&lt;a href=&quot;https://glitch.com/edit/#!/prerender-demos&quot;&gt;View the code on Glitch&lt;/a&gt;&lt;/p&gt; &lt;script&gt; function trackAction(selector, actionName, args) &#123; document.querySelector(selector).textContent = `$&#123;actionName&#125;: $&#123;JSON.stringify(args, 0, 2).replaceAll(&#x27;\\\\&quot;&#x27;,&#x27;&quot;&#x27;)&#125;`; &#125; function addSpeculationRules() &#123; const specScript = document.createElement(&quot;script&quot;); specScript.id = &quot;speculationrules&quot;; specScript.type = &quot;speculationrules&quot;; specScript.textContent = ` &#123; &quot;prerender&quot;: [ &#123; &quot;source&quot;: &quot;list&quot;, &quot;urls&quot;: [&quot;next.html&quot;, &quot;next2.html&quot;] &#125; ] &#125;`; document.body.appendChild(specScript); &#125; if (!(&#x27;supports&#x27; in HTMLScriptElement &amp;&amp; HTMLScriptElement.supports(&#x27;speculationrules&#x27;))) &#123; trackAction(&#x27;#output1&#x27;, &#x27;Speculation Rules supported on your browser&#x27;, &#x27;false&#x27;); &#125; else &#123; trackAction(&#x27;#output1&#x27;, &#x27;Speculation Rules supported on your browser&#x27;, &#x27;true&#x27;); addSpeculationRules(); trackAction(&#x27;#output2&#x27;, &#x27;Added speculationrules&#x27;, document.querySelector(&#x27;#speculationrules&#x27;).text.replaceAll(&#x27;\\n&#x27;,&#x27;&#x27;).replace(/ +/g,&#x27; &#x27;)); &#125; window.addEventListener(&#x27;pageshow&#x27;, (event) =&gt; &#123; // on bfcache restore, reinitialise the speculation rules to force another prerender const navigationType = performance.getEntriesByType(&#x27;navigation&#x27;)[0].type; if (event.persisted || navigationType == &#x27;back_forward&#x27; ) &#123; document.querySelector(&#x27;#speculationrules&#x27;)?.remove(); addSpeculationRules(); trackAction(&#x27;#output2&#x27;, &#x27;Page reactivated: re-added speculationrules&#x27;, document.querySelector(&#x27;#speculationrules&#x27;).text.replaceAll(&#x27;\\n&#x27;,&#x27;&#x27;).replace(/ +/g,&#x27; &#x27;)); &#125; &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 由于 Speculation Rules API 的灵活性较好，Chromium预言此API将逐步替代规则，成为开发者使用较多的API。 ❔我根据代码提示使用了Prerender2.0技术，那么如何客观的体现呢? 如何知道用户打开了已Prerender的页面呢? 可以打开F12控制台，通过输入 performance.getEntriesByType(&#39;navigation&#39;)[0].type 可以获取到当前页面的加载类型，如果是 ‘prerender’ 则表示当前页面是通过 Prerender2.0 技术加载的。 同上，但是输入performance.getEntriesByType(&#39;navigation&#39;)[0].activationStart; 如果大于0 则表示当前页面是通过 Prerender2.0 技术加载的。 同上123456let wasActivated = false;document.addEventListener(&#x27;prerenderingchange&#x27;, (event) =&gt; &#123; wasActivated = true;&#125;);// wasActivated = true 则表示当前页面是通过 Prerender2.0 技术加载的。console.info(wasActivated); 提供了三种方式去验证当前页面是否是通过 Prerender2.0 技术加载的，当然还可以通过任务管理器查看 带有预渲染的网页 会有预渲染: 开头。 ❔效果如何?根据 Chromium 提供的视频示例(视频演示)，不使用 Prerender 能力可以明显的看到页面中内容从0到1展示的过程，而使用Prerender后页面几乎是即时展示的。效果对比 非常明显。 ❔体验地址Prerender Demo: 前往体验demo Prerender Demo源代码: 前往查看源代码 ❔应用场景由于预渲染页面对于设备的资源消耗较大，是个需要谨慎使用的机制能力，若肆无忌惮的使用此能力，不仅无法提高用户的浏览体验，还会耗尽用户的宝贵资源，可能带来卡顿、崩溃等负向影响。Chromium推荐用法中表示当用户加载某些页面的可能性很高时才推荐使用Prerender机制，此时可将Prerender机制带来的正向收益最大化。 Chromium将预测技术与Prerender2.0机制结合使用，利用预测技术提高预渲染页面的准确性。通过 chrome://predictors 页面可看出Chromium对用户行为的预测，如下图。 其中 绿色高亮 表示有足够信心触发预渲染。以上示例可看出，当用户在输入框中输入”aliy”/“aliyu”/“aliyun”字符后，Chrome 将对 “https://www.aliyundrive.com/&quot; 站点发起预渲染，因为经过多次统计有足够的信心认为用户将进入目标站点。 Chromium会根据用户输入和选择不断的更新预测结果。 当置信度&gt;50%(图中黄色)，Chromium会发起预链接当置信度&gt;80%(图中绿色)，Chromium会发起预渲染 同时Chromium会将预测的结果呈现在Sug选项栏中，辅助用户进入目标站点。 进入站点后，开发者可以通过上面提到的验证方式，来确认当前是否是 Prerender2.0 技术预加载的。 总结本文主要介绍了 Prerender 机制的发展过程和现状，并对 Prerender2.0 技术进行介绍。其中重点介绍了 Prerender2.0 技术的使用、实现流程和应用场景。Prerender2.0 机制还在初级阶段，目前为止Chromium还在对 Prerender2.0 技术进行完善，故文档中内容可能和最新方案有些许差异。但是我们仍将持续关注 Prerender2.0 技术发展，发掘其应用于业务的可行场景，持续优化页面上屏性能，提升用户体验。 —END— 参考文档: [1] Chrome Prerender开发者文档 [2] Chrome Prerender官方论坛 [3] Chrome 多页面架构文档 [4] 社区博客 [5] 社区博客 ❤ enjoy it.","categories":[{"name":"前端","slug":"前端","permalink":"https://blog.rexhang.com/categories/%E5%89%8D%E7%AB%AF/"},{"name":"Chrome","slug":"前端/Chrome","permalink":"https://blog.rexhang.com/categories/%E5%89%8D%E7%AB%AF/Chrome/"},{"name":"Prerender2.0","slug":"前端/Chrome/Prerender2-0","permalink":"https://blog.rexhang.com/categories/%E5%89%8D%E7%AB%AF/Chrome/Prerender2-0/"}],"tags":[{"name":"frontend","slug":"frontend","permalink":"https://blog.rexhang.com/tags/frontend/"},{"name":"Chrome","slug":"Chrome","permalink":"https://blog.rexhang.com/tags/Chrome/"},{"name":"Prerender2.0","slug":"Prerender2-0","permalink":"https://blog.rexhang.com/tags/Prerender2-0/"}]},{"title":"如何设置npm镜像源","slug":"如何设置npm镜像源","date":"2023-10-10T04:00:04.000Z","updated":"2023-10-10T06:55:49.452Z","comments":true,"path":"2023/10/10/articles/5/","link":"","permalink":"https://blog.rexhang.com/2023/10/10/articles/5/","excerpt":"","text":"📃一、前言npm原始的仓库源 https://registry.npmjs.org 下载内容会比较慢，如果使用较快的其他镜像(国内)，将会大大提高下载速度，节省开发时间。 解决方案1直接使用cnpm代替npm 1234# 安装cnpmnpm install -g cnpm# 使用cnpm代替npmcnpm install xx 解决方案2直接修改全局的npm源地址 123456# 设置为淘宝的源地址npm config set registry https://registry.npm.taobao.org# 恢复默认npm config set registry https://registry.npmjs.org# 查看当前环境下的npm的registry配置源地址npm config get registry 解决方案3安装的时候指定源参数 12# 安装lodashnpm install lodash --registry=https://registry.npm.taobao.org 解决方案4使用nrm管理npm源 相应的如果需要切换node版本可以借助nvm工具，参考之前的 这篇文章 12345678# 安装nrm工具npm install -g nrm --registry=https://registry.npm.taobao.org# 查看当前可配置的源nrm ls# 切换使用某个源nrm use taobao# 切换成功后 nrm ls 列表会突出一个 * 号 标识当前采用的源nrm ls 解决方案5修改 .npmrc 文件也可以实现指定源的配置，关于全局 .npmrc 文件的位置 可以通过命令 npm config list 查看得到 可以使用 npm config edit命令直接修改 也可打开具体文件位置进行编辑修改 关于.npmrc的地址mac系统一般在 ~/.npmrcwindows系统一般在 C:\\Users\\username\\.npmrc当前项目根目录有时候也会配置.npmrc 特别注意 要是项目本身有 .npmrc 则优先级是最高的 yarnrc等 rc文件同理 1registry = https://registry.npm.taobao.org npm目录 &amp; 强制删除缓存npm 的缓存目录 可以通过 npm config get cache 命令得到 npm 的全局node包目录 可以通过 npm config get prefix 或者 npm root -g 命令得到 如果要修改以上路径 可以通过 以下命令对应 进行修改 12npm config set cache &quot;&lt;new_path&gt;&quot;npm config set prefix &quot;&lt;new_path&gt;&quot; 强制删除当前环境下全局的npm缓存 使用以下命令即可 1npm cache clean --force npm升级到最新版本1npm i -g npm 关于pnpmpnpm 相关资料移步这里 点击此处跳转 ❤ enjoy it.","categories":[{"name":"前端","slug":"前端","permalink":"https://blog.rexhang.com/categories/%E5%89%8D%E7%AB%AF/"},{"name":"npm","slug":"前端/npm","permalink":"https://blog.rexhang.com/categories/%E5%89%8D%E7%AB%AF/npm/"}],"tags":[{"name":"frontend","slug":"frontend","permalink":"https://blog.rexhang.com/tags/frontend/"},{"name":"npm","slug":"npm","permalink":"https://blog.rexhang.com/tags/npm/"}]},{"title":"JavaScript代码编写规范","slug":"JavaScript代码编写规范","date":"2023-10-10T01:00:03.000Z","updated":"2023-10-10T03:13:14.322Z","comments":true,"path":"2023/10/10/articles/4/","link":"","permalink":"https://blog.rexhang.com/2023/10/10/articles/4/","excerpt":"","text":"一. 通用规则1.1 编码使用 UTF-8（无 BOM）。 确保你的编辑器将没有字节顺序标记的 UTF-8 用作字符编码。 1.2 末尾空白删除行尾空格。 行尾空格属于多余的符号，并且会让 diff 变得更加复杂。 不推荐： 1const name = &quot;John Smith&quot;;__ 推荐： 1const name = &quot;John Smith&quot;; 如果你使用 VS Code，你可进入编辑器菜单的「首选项——&gt;设置」中搜索 files.trimTrailingWhitespace ，然后将选项勾选即可，这样每当你保存文件时，去除行尾空格操作便会自动完成： 1&quot;files.trimTrailingWhitespace&quot;: true 1.3 缩进整个文件中的缩进应保持前后一致，使用 Tab、2个空格或4个空格都可以，但需保持前后一致。 1.4 注释用注释解释代码的覆盖范围、目的和作用以及使用和选择各解决方案的原因。 你可以选择使用 JSDoc，即编写代码注释的文件生成器和标准，对你的 JavaScript 功能进行记录，其优点包括为你的注释提供技术参照和能够针对文件生成网页的命令行 jsdoc 工具。 JSDoc 会为你提供记录代码的多种注释，但我们只推荐你使用以下种类： @constructor：用于记录一个 Class 类，也就是用 new 关键字调用的函数。 @description：用于描述你的函数，该标签还可以使你在需要时添加 HTML 标记。 @param：用于描述函数参数的名称、类别和说明。 @returns：记录函数返回值的类型和说明。 下方实例说明了如何记录类构造函数（注意注释区开头使用的 /** ，这个非常重要）： 12345678910/*** @description 简要描述这本书* @constructor* @param &#123;string&#125; title - 书的标题* @param &#123;string&#125; author - 书的作者*/function Book(title, author) &#123; ...&#125; 以下函数含有能返回值的参数，注意，这里的参数作用一目了然，因此并未对其进行说明。 12345678910/*** @description 计算两数相加* @param &#123;number&#125; a* @param &#123;number&#125; b* @returns &#123;number&#125; 数字 a 与 b 的和*/function sum(a, b) &#123; return a + b;&#125; 你也可以使用更多你想要编写的注释。 1.5 待办任务用 TODO: 标注待办事项和任务项 仅用关键词 TODO 标注待办事项，不要使用 @@ 等其他格式的字样。在任务项前加冒号，如： TODO: 待办任务 推荐： 1// TODO: 加些其他的需求 二. JavaScript 语言规则2.1 变量在 JavaScript 里一共有三种定义变量的方式： const let var 当定义变量的时候，你应该使用上面列出的关键字来定义变量。优先考虑使用 const 定义你的变量，如果觉得以后需要对变量重新赋值的，则使用 let。现在已经不推荐使用 var 关键字来定义变量了。 2.2 分号始终使用分号。 依靠隐式插入会造成难以排除的细微问题。分号应放在函数表达式的末尾，而不是函数声明的末尾。 不推荐： 123456const foo = function() &#123; return true // 缺少分号&#125; // 缺少分号function foo() &#123; return true;&#125;; // 额外的分号 推荐： 123456const foo = function() &#123; return true;&#125;;function foo() &#123; return true;&#125; 2.3 基本类型包装对象基本类型无需使用包装对象，此外，包装对象还具有潜在危险，但可以使用类型转换。 不推荐： 1234const x = new Boolean(0);if (x) &#123; alert(&#x27;hi&#x27;); // 如果 x 是一个真实对象，则显示 hi&#125; 推荐： 1234const x = Boolean(false);if (x) &#123; alert(&#x27;hi&#x27;); // 如果 x 是一个否定的布尔值，则显示 hi&#125; 2.4 闭包进行该操作时要小心谨慎。 创建闭包的能力可能是 JavaScript 中最有用但最常被忽略的能力。需要记住的是，闭包会储存对其封闭范围的指针，因此，将 DOM 元素与闭包相连会生成循环引用，从而导致内存的泄露。 不推荐： 123function foo(element, a, b) &#123; element.onclick = function() &#123; /* 使用 a 和 b */ &#125;&#125; 推荐： 123456function foo(element, a, b) &#123; element.onclick = bar(a, b);&#125;function bar(a, b) &#123; return function() &#123; /* 使用 a 和 b */ &#125;&#125; 2.5 for 、for-in 和 forEach2.6 数组在迭代数组时，相比 for-in 循环， forEach 或 for 循环更具优势。 不推荐： 1234567891011121314151617181920const myArray = [&#x27;a&#x27;, 1, &#x27;etc&#x27;];for (const indexNum in myArray) &#123; console.log(myArray[indexNum]);&#125;const starWars = &#123; &quot;creatures&quot;: [ &#123; &quot;name&quot;: &quot;bantha&quot;, &quot;face&quot;: &quot;furry&quot; &#125;, &#123; &quot;name&quot;: &quot;loth-cat&quot;, &quot;face&quot;: &quot;toothy&quot; &#125; ]&#125;;for (const i in starWars.creatures) &#123; console.log(starWars.creatures[i].name); console.log(starWars.creatures[i].face);&#125;; 推荐： 12345678910111213141516171819202122232425const mySimpleArray = [&#x27;a&#x27;, 1, &#x27;etc&#x27;];const mySimpleArray.forEach(function(val) &#123; console.log(val);&#125;);const starWars = &#123; &quot;creatures&quot;: [ &#123; &quot;name&quot;: &quot;bantha&quot;, &quot;face&quot;: &quot;furry&quot; &#125;, &#123; &quot;name&quot;: &quot;loth-cat&quot;, &quot;face&quot;: &quot;toothy&quot; &#125; ]&#125;;starWars.creatures.forEach(function(creature)&#123; console.log(creature.name); console.log(creature.face)&#125;);// 或者const myArray = [&#x27;a&#x27;, 1, &#x27;etc&#x27;];for (let indexCount = 0; indexCount &lt; myArray.length; indexCount++) &#123; console.log(myArray[indexCount]);&#125;; 2.6 对象for-in 循环用于在对象中循环关键词。这样很容易出错，因为， for-in 不会从 0 循环，而是循环对象及其原型链中现存的所有关键词。 如果可以的话，对数据进行整理，以避免迭代对象。如果不可行，将 for-in 循环的内容包裹在条件语句中，以避免迭代原型链。 for-in 循环用于循环对象中的键。这很容易出错，因为 for-in 不是从 0 循环到 length-1 ，而是循环对象及其原型链中的所有现有键。 如果可以的话，对数据进行整理，这样就不必在对象上迭代。如果不可行，就将 for-in 循环的内容包裹在条件语句中，以防止它在原型链上迭代。 不推荐： 1234const myObj = &#123;&#x27;firstName&#x27;:&#x27;Ada&#x27;,&#x27;secondName&#x27;:&#x27;Lovelace&#x27;&#125;;for (const key in myObj) &#123; console.log(myObj[key]);&#125; 推荐： 123456const myObj = &#123;&#x27;firstName&#x27;:&#x27;Ada&#x27;,&#x27;lastName&#x27;:&#x27;Lovelace&#x27;&#125;;for (const key in myObj) &#123; if (myObj.hasOwnProperty(key)) &#123; console.log(myObj[key]); &#125;&#125; 2.7 多行字符串字面量不要使用。 编译期间无法妥善删除各行开头的空格，斜杠后的空白会引发棘手的问题，虽然大部分脚本引擎支持该操作，但这并不属于规格中的一部分。 不推荐： 123456const myPoetry = &#x27;一二三四五，\\ 上山打老虎，\\ 老虎没打到，\\ 打到小松鼠，\\ 让我数一数，\\ 一二三四五&#x27;; 推荐： 123456789101112const myPoetry = &#x27;黄河远上白云间，&#x27; + &#x27;一片孤城万仞山。&#x27; + &#x27;羌笛何须怨杨柳，&#x27; + &#x27;春风不度玉门关。&#x27;;// orconst myPoetry = ` 黄河远上白云间， 一片孤城万仞山。 羌笛何须怨杨柳， 春风不度玉门关。`; 2.8 数组和对象字面量使用数组和对象字面量，而不是数组和对象构造函数。 不推荐： 123const myArray = new Array(x1, x2, x3);const myObject = new Object();myObject.a = 0; 推荐： 1234const myArray = [x1, x2, x3];const myObject = &#123; a: 0&#125;; 三. JavaScript 样式规则3.1 命名总体来说，函数名称为 functionNames ，变量名称为 variableNames ，类名称为 ClassNames ，方法名称为 methodNames ，常量值名称为 CONSTANT_VALUES ，文件名称为 filenames 。 3.2 代码格式由于分号的隐式插入，大括号应与其内容放置在同一行。 推荐： 12345if (something) &#123; // 执行某项任务&#125; else &#123; // 执行另外一项任务&#125; 只有在单行数组和对象初始器可以在写同一行时方可使用这两项。左括号前和右括号后都不应有空格。 推荐： 12const array = [1, 2, 3];const object = &#123;a: 1, b: 2, c: 3&#125;; 多行数组和对象初始器需进行单行缩进，与代码块一样，其括号与内容应位于同一行。 推荐： 123456789101112const array = [ &#x27;Joe &lt;joe@email.com&gt;&#x27;, &#x27;Sal &lt;sal@email.com&gt;&#x27;, &#x27;Murr &lt;murr@email.com&gt;&#x27;, &#x27;Q &lt;q@email.com&gt;&#x27;];const object = &#123; id: &#x27;foo&#x27;, class: &#x27;foo-important&#x27;, name: &#x27;notification&#x27;&#125;; 3.3 字符串为了保持连贯性，应使用单引号 &#39; 而不是双引号 &quot;。这在创建含有 HTML 的字符串时尤其有帮助。 推荐： 1const element = &#x27;Click Me&#x27;; 此规则较为明显的一个例外是在 JSON 对象中： JSON 要求使用双引号。 四. 技巧提示4.1 真假布尔表达式以下为假的布尔表达式： null undefined &#39;&#39; 空字符串 数字 0 注意区分，以下为真的表达式： &#39;0&#39; 字符串0 [] 空数组 &#123;&#125; 空对象 4.2 三元表达式 expr ? A : B不强制规定，但建议使用三元条件运算符编写简洁代码，避免使用以下代码： 不推荐： 12345if (val) &#123; return foo();&#125; else &#123; return bar();&#125; 推荐： 1return val ? foo() : bar(); 4.3 短路求值 &amp;&amp; 和 ||短路求值是一种逻辑运算符的求值策略。只有当第一个运算数的值无法确定逻辑运算的结果时，才对第二个运算数进行求值。例如，当 &amp;&amp; 的第一个运算数的值为 false 时，其结果必定为 false ；当 || 的第一个运算数为 true 时，最后结果必定为 true ，在这种情况下，就不需要知道第二个运算数的具体值。 不推荐： 123456789function foo(name) &#123; let theName; if (name) &#123; theName = name; &#125; else &#123; theName = &#x27;John&#x27;; &#125; return theName;&#125; 推荐： 123function foo(name) &#123; return theName = name || &#x27;John&#x27;;&#125; 4.4 &amp;&amp; 也被用于缩减代码不推荐： 12345if (node) &#123; if (node.kids) &#123; console.log(node.kids); &#125;&#125; 推荐： 123if (node &amp;&amp; node.kids) &#123; console.log(node.kids);&#125; ❤ enjoy it.","categories":[{"name":"前端","slug":"前端","permalink":"https://blog.rexhang.com/categories/%E5%89%8D%E7%AB%AF/"},{"name":"JS","slug":"前端/JS","permalink":"https://blog.rexhang.com/categories/%E5%89%8D%E7%AB%AF/JS/"},{"name":"guide","slug":"前端/JS/guide","permalink":"https://blog.rexhang.com/categories/%E5%89%8D%E7%AB%AF/JS/guide/"},{"name":"规范","slug":"前端/JS/guide/规范","permalink":"https://blog.rexhang.com/categories/%E5%89%8D%E7%AB%AF/JS/guide/%E8%A7%84%E8%8C%83/"}],"tags":[{"name":"frontend","slug":"frontend","permalink":"https://blog.rexhang.com/tags/frontend/"},{"name":"guide","slug":"guide","permalink":"https://blog.rexhang.com/tags/guide/"},{"name":"规范","slug":"规范","permalink":"https://blog.rexhang.com/tags/%E8%A7%84%E8%8C%83/"},{"name":"js","slug":"js","permalink":"https://blog.rexhang.com/tags/js/"}]},{"title":"HTML代码编写规范","slug":"HTML代码编写规范","date":"2023-10-10T01:00:02.000Z","updated":"2023-10-10T03:10:47.466Z","comments":true,"path":"2023/10/10/articles/3/","link":"","permalink":"https://blog.rexhang.com/2023/10/10/articles/3/","excerpt":"","text":"一. 通用规则1.1 编码使用 UTF-8 。 确保你的编辑器将没有字节顺序标记的 UTF-8 用作字符编码。在 HTML 模板中设置编码并用 &lt;meta charset=&quot;utf-8&quot;&gt; 记录。 1.2 字母大小写仅使用小写。 所有代码均使用小写，该规则适用于 HTML 元素名、属性和属性值（文本/ CDATA 除外）。 不推荐： 1&lt;A HREF=&quot;/&quot; class=&quot;HOME&quot;&gt;主页&lt;/A&gt; 推荐： 1&lt;a href=&quot;/&quot; class=&quot;home&quot;&gt;主页&lt;/a&gt; 1.3 末尾空格删除行尾空格。 行尾空格属于多余的符号，并且会让 diff 变得更加复杂。 不推荐： 1&lt;p&gt;什么?&lt;/p&gt;__ 推荐： 1&lt;p&gt;一往情深深几许？深山夕照深秋雨。&lt;/p&gt; 如果你使用 VS Code，你可进入编辑器菜单的「首选项——&gt;设置」中搜索 files.trimTrailingWhitespace ，然后将选项勾选即可，这样每当你保存文件时，去除行尾空格操作便会自动完成： 1&quot;files.trimTrailingWhitespace&quot;: true 1.4 缩进整个文件中的缩进应保持前后一致，使用 Tab、2个空格或4个空格都可以，但需保持前后一致。 1.5 注释在可行和必要时，对代码进行注释。 用注释解释代码的覆盖范围、目的和作用以及使用和选择各解决方案的原因。 1.6 待办任务用 TODO: 标注待办事项和任务项 仅用关键词 TODO 标注待办事项，不要使用 @@ 等其他格式的字样。在任务项前加冒号，如： TODO: 待办任务 推荐： 1234&lt;!-- TODO: 对出下联 --&gt;&lt;ul&gt; &lt;li&gt;风吹云，云随风，风云变幻&lt;/li&gt;&lt;/ul&gt; 二. HTML 样式规则2.1 文件类型使用 HTML5 。 所有 HTML 文件均应使用 HTML5 （ HTML 语法）： &lt;!DOCTYPE html&gt; 不要结束自结束元素，即编写 &lt;br&gt; ，而不是 &lt;br /&gt; 。 2.2 语义根据目的使用 HTML 。 根据元素的预期作用使用元素。例如，针对标题使用标题元素，针对段落使用 p 元素，针对锚点使用 a 元素等。根据目的使用 HTML 对提高可访问性、再利用程度和代码效率十分重要。 不推荐： 1&lt;div onclick=&quot;goToRecommendations();&quot;&gt;All recommendations&lt;/div&gt; 推荐： 1&lt;a href=&quot;recommendations/&quot;&gt;All recommendations&lt;/a&gt; 2.3 多媒体应变计划为多媒体设置备用内容。 确保为图片、视频或通过画布呈现的动画对象等多媒体提供其他访问方式。对于图片而言，使用有意义的 Alt 文本。对于视频，使用音频转述资料和字幕（如有）。 为方便访问，需提供备用内容，若没有 alt 属性，盲人用户将难以辨别图片的内容，其他用户也可能无法理解视频或音频的内容。 针对具有会引入冗余的 alt 属性的图片和无法立即使用 CSS 的装饰性图片，使用空备用内容，即 alt=&quot;&quot; 。 不推荐： 1&lt;img src=&quot;udacity.png&quot;&gt; 推荐： 1&lt;img src=&quot;udacity.png&quot; alt=&quot;Udacity logo&quot;&gt; 2.4 关注点分离将结构、描述和行为相互分离。 将结构（标记）、描述（样式）和行为（脚本设计）严格分开，将三者间可能发生的相互作用降至最低。 也就是说，确保文件和模板仅含有 只用于结构目的 HTML 。将所有描述性事物移至样式表，将所有行为性事物移至脚本。此外，尽可能少地连接文件和模板中的样式表和脚本，以便使接触面积最小化。 将结构、描述和行为相互分离对维护十分重要。相比对样式表和脚本进行更新，更改 HTML 文件和模板的成本往往更高。 不推荐： 12345678910111213141516171819&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; /* 此处省略 n 行样式 */ &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; // 此处省略 n 行脚本 &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 推荐： 123456789101112&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;style.css&quot;&gt;&lt;/head&gt;&lt;body&gt; &lt;script src=&quot;js/app.js&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 2.5 类型属性忽略样式表和脚本的 type 属性。 不要针对样式表和脚本使用 type 属性。因为 HTML 已经默认设置了 text/css 和 text/javascript ，所以在此类语境中无需设置 type 属性。 在老式浏览器中，也可以安全进行此项操作。 不推荐： 12&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;css/style.css&quot;&gt;&lt;script src=&quot;js/app.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt; 推荐： 12&lt;link rel=&quot;stylesheet&quot; href=&quot;css/style.css&quot;&gt;&lt;script src=&quot;js/app.js&quot;&gt;&lt;/script&gt; 三. HTML 格式规则3.1 一般格式所有代码块、列表和表元素均需另起一行，所有子元素均需缩进。 每一个代码块、列表和表元素均需另起一行，与元素的样式相独立（因为 CSS 允许元素在每一个显示属性中担任不同的角色）。 此外，代码块、列表和表元素的子元素也需进行缩进（如果你遇到列表项间存在空白的问题，可以将所有 li 元素放置在一行）。 推荐: 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;blockquote&gt; &lt;p&gt;啊！&lt;em&gt;船长！&lt;/em&gt;我的船长！&lt;/p&gt;&lt;/blockquote&gt;&lt;ul&gt; &lt;li&gt;啊．船长，我的船长！我们艰苦的航程已经终结，&lt;/li&gt; &lt;li&gt;这只船安然渡过了一切风浪，我们寻求的奖赏已经获得。&lt;/li&gt; &lt;li&gt;港口在望，我听见钟声在响，人们都在欢呼，&lt;/li&gt; &lt;li&gt;目迎着我们的船从容返航，它显得威严而英武。&lt;/li&gt; &lt;li&gt;可是，啊，心啊！心啊！心啊！&lt;/li&gt; &lt;li&gt;啊．殷红的鲜血长流，&lt;/li&gt; &lt;li&gt;在甲板上，那里躺着我的船长，&lt;/li&gt; &lt;li&gt;他已倒下，已死去，已冷却。&lt;/li&gt; &lt;li&gt;啊，船长，我的船长！起来吧，起来听听这钟声，&lt;/li&gt; &lt;li&gt;起来，——旌旗正为你招展——军号正为你发出颤音。&lt;/li&gt; &lt;li&gt;为你．送来了这些花束和花环。&lt;/li&gt; &lt;li&gt;为你，熙攘的群众在呼唤，转动着多少殷切的脸。&lt;/li&gt; &lt;li&gt;这里，船长！亲爱的父亲！&lt;/li&gt; &lt;li&gt;你头颅下边是我的手臂！&lt;/li&gt; &lt;li&gt;在甲板上像是在一场梦里，&lt;/li&gt; &lt;li&gt;你已倒下，已死去，已冷却。&lt;/li&gt; &lt;li&gt;我们的船长不作回答，他的双唇惨白而寂静，&lt;/li&gt; &lt;li&gt;我的父亲不能感觉我的手臂，他已没有脉息、没有知觉，&lt;/li&gt; &lt;li&gt;我们的船已安全抛锚碇泊，已经结束了它的航程，&lt;/li&gt; &lt;li&gt;胜利的船从险恶的旅途归来，我们寻求的已赢得手中。&lt;/li&gt; &lt;li&gt;欢呼吧，啊，海岸！轰鸣，啊，洪钟！&lt;/li&gt; &lt;li&gt;可是，我却轻移悲伤的步履，&lt;/li&gt; &lt;li&gt;在甲板上，那里躺着我的船长，&lt;/li&gt; &lt;li&gt;他已倒下，已死去，已冷却。&lt;/li&gt;&lt;/ul&gt;&lt;table&gt; &lt;thead&gt; &lt;tr&gt; &lt;th scope=&quot;col&quot;&gt;姓名&lt;/th&gt; &lt;th scope=&quot;col&quot;&gt;职业&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td&gt;瓦尔特·惠特曼&lt;/td&gt; &lt;td&gt;诗人&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt;&lt;/table&gt; 3.2 HTML 引号在引用属性值时，使用双引号。 不推荐： 1&lt;a href=&#x27;login/&#x27; class=&#x27;btn btn-secondary&#x27;&gt;登录&lt;/a&gt; 推荐： 1&lt;a href=&quot;login/&quot; class=&quot;btn btn-secondary&quot;&gt;登录&lt;/a&gt; ❤ enjoy it.","categories":[{"name":"前端","slug":"前端","permalink":"https://blog.rexhang.com/categories/%E5%89%8D%E7%AB%AF/"},{"name":"HTML","slug":"前端/HTML","permalink":"https://blog.rexhang.com/categories/%E5%89%8D%E7%AB%AF/HTML/"},{"name":"guide","slug":"前端/HTML/guide","permalink":"https://blog.rexhang.com/categories/%E5%89%8D%E7%AB%AF/HTML/guide/"},{"name":"规范","slug":"前端/HTML/guide/规范","permalink":"https://blog.rexhang.com/categories/%E5%89%8D%E7%AB%AF/HTML/guide/%E8%A7%84%E8%8C%83/"}],"tags":[{"name":"frontend","slug":"frontend","permalink":"https://blog.rexhang.com/tags/frontend/"},{"name":"guide","slug":"guide","permalink":"https://blog.rexhang.com/tags/guide/"},{"name":"规范","slug":"规范","permalink":"https://blog.rexhang.com/tags/%E8%A7%84%E8%8C%83/"},{"name":"html","slug":"html","permalink":"https://blog.rexhang.com/tags/html/"}]},{"title":"CSS代码编写规范","slug":"CSS代码编写规范","date":"2023-10-10T01:00:01.000Z","updated":"2023-10-10T03:10:44.858Z","comments":true,"path":"2023/10/10/articles/2/","link":"","permalink":"https://blog.rexhang.com/2023/10/10/articles/2/","excerpt":"","text":"一. 通用规则1.1 编码使用 UTF-8 。 确保你的编辑器将没有字节顺序标记的 UTF-8 用作字符编码。 1.2 字母大小写仅使用小写。 所有代码均使用小写，该规则适用于 CSS 选择符、属性和属性值（字符串除外）。 不推荐： 1color: #E5E5E5; 推荐： 1color: #e5e5e5; 1.3 末尾空格删除行尾空格。 行尾空格属于多余的符号，并且会让 diff 变得更加复杂。 不推荐： 1border: 0;__ 推荐： 1border: 0; 如果你使用 VS Code，你可进入编辑器菜单的「首选项——&gt;设置」中搜索 files.trimTrailingWhitespace ，然后将选项勾选即可，这样每当你保存文件时，去除行尾空格操作便会自动完成： 1&quot;files.trimTrailingWhitespace&quot;: true 1.4 缩进整个文件中的缩进应保持前后一致，使用 Tab、2个空格或4个空格都可以，但需保持前后一致。 1.5 注释在可行和必要时，对代码添加注释。 用注释解释代码的覆盖范围、目的和作用以及使用和选择各解决方案的原因。 1.6 区块注释在可行时，用注释将样式表区块组合在一起，用新行分隔各区块。 推荐： 1234567891011121314151617181920212223242526/* Header */.header &#123; …&#125;.header-nav &#123; …&#125;/* Content */.gallery &#123; …&#125;.gallery-img &#123; …&#125;/* Footer */.footer &#123; …&#125;.footer-nav &#123; …&#125; 1.7 待办任务用 TODO: 标注待办事项和任务项： 仅用关键词 TODO 标注待办事项，不要使用 @@ 等其他格式的字样。在任务项前加冒号，如：TODO: 待办任务 。 推荐： 1/* TODO: 添加一个按钮元素 */ 二. CSS 样式规则2.1 ID 和 CLASS 名称使用有意义或具有普遍性的 ID 和类名称。 不可使用意义含糊的 ID 和类名称，使用能够反映相应元素意义的名称或具有普遍性的通用名。 最好使用能够反映相应元素意义的具体名称，因为这些名称最易于理解且不易变更。 具有普遍性的通用名被用于与类似元素意义相仿的元素，主要起辅助作用。 不推荐： 1234567.p-998 &#123; …&#125;.btn-green &#123; …&#125; 推荐： 1234567.gallery &#123; …&#125;.btn-default &#123; …&#125; 2.2 类型选择符避免用类型选择器限定 ID 和类名称。 除非情况需要（例如，在辅助类型中），否则不要将元素名和 ID 或类名称同时使用。为提高性能，避免使用不必要的祖先选择符。 在 CSS 文件中使用 ID 也是较糟糕的做法，类别始终比名称更具优势，如果你需要给予某元素一个特殊的名称，请使用类别。（ ID 的唯一优点是在存在数千个类似元素的页面上能保持较快的运行速度。） 不推荐： 1234567ul#example &#123; …&#125;div.error &#123; …&#125; 推荐： 1234567.example &#123; …&#125;.error &#123; …&#125; 2.3 简写属性应使用简写。 CSS 可提供多种简写属性（例如，padding，而不是 padding-top、padding-bottom 等），应尽可能使用这些简写，但字体属性和在 Bootstrap 等框架中会覆盖其他同名属性的属性除外。 使用简写属性有助于提高代码的效率和易懂性。推荐在设置仅与字体 font 相关的属性时使用字体简写属性，但无需在进行小幅改动时使用。在使用字体简写属性时，请注意，如果未注明字体的大小和系列，浏览器会忽略整个字体声明。 不推荐： 12345678border-top-style: none;font-family: palatino, georgia, serif;font-size: 100%;line-height: 1.6;padding-bottom: 2em;padding-left: 1em;padding-right: 1em;padding-top: 0; 推荐： 123border-top: 0;font: 100%/1.6 palatino, georgia, serif;padding: 0 1em 2em; 2.4 省略0后面的单位去掉 0 值后面的单位。 不推荐： 12margin: 0em;padding: 0px; 推荐： 12margin: 0;padding: 0; 2.5 前导零为方便阅读，十进制值中含有前导零。 不推荐： 1font-size: .8em; 推荐： 1font-size: 0.8em; 2.6 十六进制表示法在可行时，使用三个十六进制表示法的字符。 不推荐： 1color: #eebbcc; 推荐： 1color: #ebc; 2.7 ID 和 CLASS 名称分隔符用连字符分隔 ID 和类名称中的字词 -。 用连字符连接选择符中的词语和缩略词，以方便理解和扫描。 唯一的例外：在编写 BEM 样式 CSS 选择符时也可以使用下划线 _ 。 不推荐： 1234567.demoimage &#123; …&#125;.errorStatus &#123; …&#125; 推荐： 1234567.demo-image &#123; …&#125;.error-status &#123; …&#125; 2.8 Hack避免用户代理检测或 CSS Hack ——尝试另一种方法。 人们可能很想处理用户代理检测或特殊的 CSS 过滤器以及应变方案和非法入侵之间的样式差异。这两项措施均为实现和维护有效和可处理的代码库的最后方案。请考虑该样式是否对应用的性能至关重要，需要该样式的用户代理是否可以不采样该样式。 三. CSS 格式规则3.1 代码块内容缩进缩进所有代码块内容，即规则内的规则和声明，以反映层次结构、方便理解。 推荐： 123456@media screen, projection &#123; html &#123; background: #fff; color: #444; &#125;&#125; 3.2 声明标点在所有声明后使用分号，以增加连贯性和延展性。 不推荐： 1234.test &#123; display: block; height: 100px&#125; 推荐： 1234.test &#123; display: block; height: 100px;&#125; 3.3 属性名标点所有属性名冒号后均需添加空格，但属性和冒号间不加空格，以增加连贯性。 不推荐： 123font-weight:bold;padding : 0;margin :0; 推荐： 123font-weight: bold;padding: 0;margin: 0; 3.4 声明区标点最后一个选择符和声明区起始处的左大括号之间需加空格。 不推荐： 1234567.video-block&#123; margin: 0;&#125;.audio-block&#123; margin: 0;&#125; 推荐： 1234567.video-block &#123; margin: 0;&#125;.audio-block &#123; margin: 0;&#125; 3.5 选择符和声明分隔所有选择符和声明均需另起一行。 不推荐： 1234h1, h2, h3 &#123; font-weight: normal; line-height: 1.2;&#125; 推荐： 123456h1,h2,h3 &#123; font-weight: normal; line-height: 1.2;&#125; 3.6 规则分隔所有规则间均需加一个空行（两个换行符）。 推荐： 12345678html &#123; background: #fff;&#125;body &#123; margin: auto; width: 50%;&#125; 3.7 CSS 引号属性选择符和属性值均需使用双引号，链接值 url() 中不可使用双引号。 不推荐： 1234@import url(&quot;css/links.css&quot;);html &#123; font-family: &#x27;Open Sans&#x27;, arial, sans-serif;&#125; 推荐： 1234@import url(css/links.css);html &#123; font-family: &quot;Open Sans&quot;, arial, sans-serif;&#125; ❤ enjoy it.","categories":[{"name":"前端","slug":"前端","permalink":"https://blog.rexhang.com/categories/%E5%89%8D%E7%AB%AF/"},{"name":"CSS","slug":"前端/CSS","permalink":"https://blog.rexhang.com/categories/%E5%89%8D%E7%AB%AF/CSS/"},{"name":"guide","slug":"前端/CSS/guide","permalink":"https://blog.rexhang.com/categories/%E5%89%8D%E7%AB%AF/CSS/guide/"},{"name":"规范","slug":"前端/CSS/guide/规范","permalink":"https://blog.rexhang.com/categories/%E5%89%8D%E7%AB%AF/CSS/guide/%E8%A7%84%E8%8C%83/"}],"tags":[{"name":"frontend","slug":"frontend","permalink":"https://blog.rexhang.com/tags/frontend/"},{"name":"css","slug":"css","permalink":"https://blog.rexhang.com/tags/css/"},{"name":"guide","slug":"guide","permalink":"https://blog.rexhang.com/tags/guide/"},{"name":"规范","slug":"规范","permalink":"https://blog.rexhang.com/tags/%E8%A7%84%E8%8C%83/"}]},{"title":"Git 提交信息规范","slug":"Git 提交信息规范","date":"2023-10-10T01:00:00.000Z","updated":"2023-10-10T03:07:52.896Z","comments":true,"path":"2023/10/10/articles/1/","link":"","permalink":"https://blog.rexhang.com/2023/10/10/articles/1/","excerpt":"","text":"📃一、前言该指南内容主要是去描述你应该在项目进行过程中所需遵守的基础规范。在Git仓库管理的过程中，为了减少开发或者其他工作过程中因选择何种方式提交而产生困惑，我们强烈建议你们在其项目中遵循这个指南。 🎬二、提交信息👀1、信息结构提交信息由三个不同的部分构成，这些部分均由空行分隔：标题、可选的消息体和可选的注释。其布局大致如此： 123类型：主题消息正文注释 标题由消息类型和主题构成。 👀2、类型类型位于在标题内，有以下几种可能： 类型 作用 feature(feat) 新增特性(feature) fix 修复 Bug(bug fix) docs 修改文档(documentation) style 代码格式修改(white-space,formatting,missing semi colons,etc) 格式、分号缺失等，代码无变动 refactor 代码重构(refactor) perf 改善性能(A code change that improves performance) test 测试(when adding missing tests) 测试添加、测试重构等，生产代码无变动 build 变更项目构建或外部依赖 (例如 scopes: webpack、gulp、npm 等) ci 更改持续集成软件的配置文件和 package 中的 scripts 命令，例如 scopes:Travis,Circle等 chore 构建任务更新、程序包管理器配置等，生产代码无变动 revert 代码回退 👀3、标题主题不得超过50个字符，首字母大写，末尾不加句号。以祈使语气描述提交的任务，而不是其已完成的任务。例如，使用 change…，而不是 changed 或 changes 。 👀4、信息正文并不是所有的提交信息都复杂到需要主体，因此这是可选内容，仅在提交信息需要一定的解释和语境时使用。消息体是用于解释提交任务的内容和原因，而不是方法。 在编写正文时，需要在标题和正文间加一个空行，且每行的内容应控制在72个字符内。 👀5、注释注释是可选内容，用于引用问题跟踪的 ID 。 👀6、提交信息示例12345678910111213Feature: 总结变动的内容，保持在50个字符内如有需要，使用更详细的说明性文字，将其大概控制在72个字符。在部分语境中，第一行被视为提交信息的主题，余下的文本被视为主体。分隔总结与主体的空行十分重要（除非你完全忽略主体）；否则`log`、 `shortlog` 和 `rebase` 等多个工具容易发生混淆。解释该提交信息所解决的问题，说明你进行该变动的原因，而不是方法（代码本身可以解释方法）。该变动是否存在副作用或其他直觉性后果？在这里进行解释。后续段落前需加空行。可以列出要点- 通常情况下，要点会使用空格加上连字符或星号，中间用空行分隔，但该规定存在差别。如果你使用问题追踪，将其引用放在末尾，例如：解决了问题：#123另见：#456, #789 示例: Sourcetree 软件 提交示例(携带签名) ❤ enjoy it.","categories":[{"name":"前端","slug":"前端","permalink":"https://blog.rexhang.com/categories/%E5%89%8D%E7%AB%AF/"},{"name":"Git","slug":"前端/Git","permalink":"https://blog.rexhang.com/categories/%E5%89%8D%E7%AB%AF/Git/"},{"name":"guide","slug":"前端/Git/guide","permalink":"https://blog.rexhang.com/categories/%E5%89%8D%E7%AB%AF/Git/guide/"},{"name":"规范","slug":"前端/Git/guide/规范","permalink":"https://blog.rexhang.com/categories/%E5%89%8D%E7%AB%AF/Git/guide/%E8%A7%84%E8%8C%83/"}],"tags":[{"name":"frontend","slug":"frontend","permalink":"https://blog.rexhang.com/tags/frontend/"},{"name":"guide","slug":"guide","permalink":"https://blog.rexhang.com/tags/guide/"},{"name":"规范","slug":"规范","permalink":"https://blog.rexhang.com/tags/%E8%A7%84%E8%8C%83/"},{"name":"git","slug":"git","permalink":"https://blog.rexhang.com/tags/git/"}]},{"title":"Promise之allSettled","slug":"Promise之allSettled","date":"2023-10-08T10:00:01.000Z","updated":"2023-10-08T10:13:56.859Z","comments":true,"path":"2023/10/08/articles/1/","link":"","permalink":"https://blog.rexhang.com/2023/10/08/articles/1/","excerpt":"","text":"📃一、前言Promise.allSettled 是一个用于处理一组 Promise 的方法，它会等待所有的 Promise 被 settled（无论是解决还是拒绝），然后返回一个包含每个 Promise 结果的数组。这个方法解决了 Promise.all 存在的一个痛点：即是如若其中一个 Promise 被拒绝，Promise.all 就会立即返回一个被拒绝的 Promise，导致整个操作中断 有时候我们并不满意这样的结果 因此使用 ES2020 中提出的 allSettled 可以解决这个问题，并且下文中会给出相应的 Polyfill 确保能够支持 Promise.all 的场景下都能够顺利使用。 🎬二、一些关键点和应用场景包括：🎀1、解决所有 Promise 结果：Promise.allSettled 返回一个数组，包含每个 Promise 的结果对象，这些结果对象包含 status 属性，表示 Promise 的状态是 fulfilled 还是 rejected ，以及相应的值或原因。 🎀2、不中断整个操作：与 Promise.all 不同，Promise.allSettled 不会因为其中一个 Promise 被拒绝而中断执行。即使有一些 Promise 被拒绝，其他 Promise 仍然会继续执行，而最终返回的结果是一个包含所有 Promise 结果的数组。 🎀3、处理并行异步任务：在处理需要并行执行的异步任务时，有时你可能希望了解每个任务的最终状态，而不仅仅是得到一个被拒绝的结果就中断。这在需要收集多个异步任务的结果，而不希望因为其中一个失败而中断整个流程时非常有用。 🎀4、示例代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768function allSettled (promises) &#123; return Promise.all( promises.map(promise =&gt; Promise.resolve(promise).then( value =&gt; (&#123; status: &#x27;fulfilled&#x27;, value, &#125;), reason =&gt; (&#123; status: &#x27;rejected&#x27;, reason, &#125;) ) ) );&#125;// 模拟三个promise方法，其中第二个一定会失败const p1 = new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(1); &#125;, 100);&#125;);const p2 = new Promise((resolve, reject) =&gt; &#123; reject(&#x27;2 is error&#x27;);&#125;);const p3 = Promise.resolve(&#x27;3&#x27;);(async () =&gt; &#123; try &#123; // 使用Promise.all 只要有一个失败就会返回失败，成功的结果集不会返回, 此场景下后续的p3并不会执行 const allPromiseResult = await Promise.all([p1, p2, p3]) console.debug(allPromiseResult); &#125; catch (err) &#123; console.error(err); &#125;&#125;)();(async () =&gt; &#123; // 使用Promise.allSettled 会等待所有的promise执行完毕，不管成功还是失败，都会返回结果集，可以根据返回的状态来判断是否成功 const allSettledResult = await allSettled([p1, p2, p3]); console.debug(allSettledResult); /* allSettledResult 返回 =&gt; [ &#123; &quot;status&quot;: &quot;fulfilled&quot;, &quot;value&quot;: 1 &#125;, &#123; &quot;status&quot;: &quot;rejected&quot;, &quot;reason&quot;: &quot;2 is error&quot; &#125;, &#123; &quot;status&quot;: &quot;fulfilled&quot;, &quot;value&quot;: &quot;3&quot; &#125; ] */&#125;)();// 垫片 polyfillif (!Promise.allSettled) &#123; Promise.allSettled = allSettled;&#125;(async () =&gt; &#123; // 使用 Promise.allSettled const allSettledResult = await Promise.allSettled([p1, p2, p3]) console.debug(allSettledResult);&#125;)(); 在上述示例中，无论每个 Promise 是否被解决，都会输出相应的状态和值或原因。这种行为对于需要收集异步任务结果且不希望中断整个操作的情况非常有用。 🎀5、示例代码图片： 可以保存代码图片到本地。 ❤ enjoy it.","categories":[{"name":"大前端","slug":"大前端","permalink":"https://blog.rexhang.com/categories/%E5%A4%A7%E5%89%8D%E7%AB%AF/"},{"name":"面试经","slug":"大前端/面试经","permalink":"https://blog.rexhang.com/categories/%E5%A4%A7%E5%89%8D%E7%AB%AF/%E9%9D%A2%E8%AF%95%E7%BB%8F/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://blog.rexhang.com/tags/javascript/"}]},{"title":"how to use NVM","slug":"how-to-use-NVM","date":"2023-09-26T01:01:12.000Z","updated":"2023-09-26T07:18:35.257Z","comments":true,"path":"2023/09/26/articles/1/","link":"","permalink":"https://blog.rexhang.com/2023/09/26/articles/1/","excerpt":"","text":"一、前言 一个nodejs版本管理工具 NVM，一个用来管理nodejs版本的工具，在开发过程中如果需要切换node版本将会非常有需要，请在安装node之前先安装nvm。 二、开始参考文档: 传送门 download: https://github.com/coreybutler/nvm-windows/releases (nvm-setup.zip：这是一个安装包，下载之后点击安装，无需配置就可以使用，方便。) 123456789101112131415161718192021222324# 安装指定node版本nvm install v14.15.0# 运行指定node版本nvm use v14.15.0# 切换到最新的node版本nvm use node# 远程服务器上所有的可用版本nvm ls-remote# 给不同的版本号设置别名nvm alias node_cms 14.15.0# 使用该别名nvm use node_cms# 查看已安装node列表nvm ls--- add--- uninstall# 显示可下载版本的部分列表nvm list available# 显示node是运行在32位还是64位nvm arch 文档、点击了解更多…","categories":[{"name":"node","slug":"node","permalink":"https://blog.rexhang.com/categories/node/"},{"name":"nvm","slug":"node/nvm","permalink":"https://blog.rexhang.com/categories/node/nvm/"}],"tags":[{"name":"node","slug":"node","permalink":"https://blog.rexhang.com/tags/node/"},{"name":"nvm","slug":"nvm","permalink":"https://blog.rexhang.com/tags/nvm/"}]},{"title":"ChromeDevTools的一些使用技巧","slug":"ChromeDevTools的一些使用技巧","date":"2023-08-31T03:33:29.000Z","updated":"2023-08-31T04:37:09.816Z","comments":true,"path":"2023/08/31/articles/1/","link":"","permalink":"https://blog.rexhang.com/2023/08/31/articles/1/","excerpt":"","text":"我们可以通过这些小技巧来更效率我们的开发调试工作。 1、在控制台获取上次操作返回的值我们可以使用 $_ 作为1个变量, 来拿到上次控制台显示的值 123const ar = [1,2,3];ar;$_ 2、在控制台打印当前选中的dom元素鼠标点中需要打印的dom元素, 在控制台输入 $0 即可打印出选中元素节点, 等同于 document.querySelector 12$0$0.textContent 3、使用copy命令对于内容过多的地方, 我们可以使用 copy 方法来将内容拷贝到我们的剪切板内, 还是拿script标签举例 1copy($0.textContent) 按下回车后, 相关内容就已经进入到剪切板内了 持续更新中…","categories":[{"name":"大前端","slug":"大前端","permalink":"https://blog.rexhang.com/categories/%E5%A4%A7%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"Chrome","slug":"Chrome","permalink":"https://blog.rexhang.com/tags/Chrome/"}]},{"title":"ES2023-深入解析JavaScript的最新更新","slug":"ES2023来了！深入解析JavaScript的最新更新","date":"2023-08-23T02:41:22.000Z","updated":"2023-08-23T02:53:47.627Z","comments":true,"path":"2023/08/23/articles/1/","link":"","permalink":"https://blog.rexhang.com/2023/08/23/articles/1/","excerpt":"","text":"前言ES2023-深入解析JavaScript的最新更新，本篇文章将会为各位简单分析下具体的用法和作用。 Symbol是ECMAScript中唯一的原始类型，允许使用唯一的值，因此可以使用Symbol作为键，而不是创建一个新的带有WeakMap的对象。 1、从数组末尾查找元素这个函数允许我们根据条件从数组的最后一个元素向前查找元素。例如： 123456const array = [&#123;a: 1, b: 1&#125;, &#123;a: 2, b: 2&#125;, &#123;a: 3, b: 3&#125;, &#123;a: 4, b: 4&#125;]console.log(array.findLast(n =&gt; n)); //result -&gt; &#123;a: 4,b: 4 &#125;console.log(array.findLast(n =&gt; n.a * 5 === 20)); // result -&gt; &#123;a:4,b:4&#125;console.log(array.findLast(n =&gt; n.a * 5 === 21)); //result -&gt; undefinedconsole.log(array.findLastIndex(n =&gt; n.a * 5 === 21)); // result -&gt; -1console.log(array.findLastIndex(n =&gt; n.a * 5 === 20)); // result -&gt; 3 分析： 12const array = [&#123;a: 1, b: 1&#125;, &#123;a: 2, b: 2&#125;, &#123;a: 3, b: 3&#125;, &#123;a: 4, b: 4&#125;]console.log(array.findLast(n =&gt; n)); //结果 -&gt; &#123;a: 4,b: 4 &#125; 使用 findLast 方法从数组的末尾开始查找第一个满足条件（n =&gt; n，即所有元素）的元素。因为所有元素都满足条件，所以它返回了数组的最后一个元素 {a: 4, b: 4}。 1console.log(array.findLast(n =&gt; n.a * 5 === 20)); //结果 -&gt; &#123;a:4,b:4&#125;，因为条件为真，所以返回最后一个元素。 使用 findLast 方法从数组的末尾开始查找第一个满足条件（n =&gt; n.a * 5 === 20）的元素。这个条件相当于在查找数组中 a 属性值为4的元素，所以它返回了 {a: 4, b: 4}。 1console.log(array.findLast(n =&gt; n.a * 5 === 21)); //结果 -&gt; undefined，因为条件为假，所以返回undefined，而不是 &#123;a:4,b:4&#125;。 使用 findLast 方法从数组的末尾开始查找第一个满足条件（n =&gt; n.a * 5 === 21）的元素。由于数组中没有任何元素的 a 属性值可以满足这个条件，所以返回 undefined。 1console.log(array.findLastIndex(n =&gt; n.a * 5 === 21)); //结果 -&gt; -1，因为条件不能为返回最后一个元素。 使用 findLastIndex 方法从数组的末尾开始查找第一个满足条件（n =&gt; n.a * 5 === 21）的元素的索引。由于数组中没有任何元素的 a 属性值可以满足这个条件，所以返回 -1。 1console.log(array.findLastIndex(n =&gt; n.a * 5 === 20)); //结果 -&gt; 3，这是最后一个元素的索引，因为条件为真。 使用 findLastIndex 方法从数组的末尾开始查找第一个满足条件（n =&gt; n.a * 5 === 20）的元素的索引。这个条件相当于在查找数组中 a 属性值为4的元素的索引，所以它返回了 3，这是数组的最后一个元素的索引。 2、Hashbang 语法这个特性使我们能够在某些命令行接口中使用 Hashbang / Shebang。Shebang 用 #! 表示，是脚本开始的特殊行，告诉操作系统执行脚本时应该使用哪个解释器。 123456789#!/usr/bin/env node// in the Script Goal&#x27;use strict&#x27;;console.log(2*3);#!/usr/bin/env node// in the Module Goalexport &#123;&#125;;console.log(2*2); #!/usr/bin/env node 这行代码将直接调用一个 Node.js 源文件，作为其自身的可执行文件。 我们不需要使用这行代码 (#!/usr/bin/env node) 来显式地通过 Node 解释器调用文件，例如， node ./file 。 3、将 Symbols 作为 WeakMap 的键这允许使用唯一的 Symbols 作为键。目前 WeakMaps 只允许对象作为键。因为它们共享同样的身份特性。 Symbol是ECMAScript中唯一的原始类型，允许使用唯一的值，因此可以使用Symbol作为键，而不是创建一个新的带有WeakMap的对象。 1234567const weak = new WeakMap();const key = Symbol(&#x27;my ref&#x27;);const someObject = &#123; a:1 &#125;;weak.set(key, someObject);console.log(weak.get(key)); 4、通过复制改变数组这在 Array.prototype 上提供了额外的方法，通过返回带有更改的新数组副本，而不是更新原始数组来更改数组。 新引入的 Array.prototype 函数包括： Array.prototype.toReversed() Array.prototype.toSorted(compareFn) Array.prototype.toSpliced(start, deleteCount, …items) Array.prototype.with(index, value) 示例： 12345const numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9]/* toReversed */const reversed = numbers.toReversed();console.log(&quot;reversed&quot;, reversed); // &quot;reversed&quot;, [9, 8, 7, 6, 5, 4, 3, 2, 1]console.log(&quot;original&quot;, numbers); // &quot;original&quot;, [1, 2, 3, 4, 5, 6, 7, 8, 9] 这段代码使用了 toReversed 方法，该方法返回一个新数组，新数组的元素顺序与原数组相反。我们可以看到，原数组 numbers 并未被改变。 1234/* toSorted */const sortedArr = numbers.toSorted();console.log(&quot;sorted&quot;, sortedArr); // &quot;sorted&quot;, [1, 2, 3, 4, 5, 6, 7, 8, 9]console.log(&quot;original&quot;, numbers); // &quot;original&quot;, [1, 2, 3, 4, 5, 6, 7, 8, 9] 这段代码使用了 toSorted 方法，该方法返回一个新数组，新数组的元素是原数组元素的排序结果。由于原数组已经是排序的，所以新数组与原数组相同。我们可以看到，原数组 numbers 并未被改变。 1234/* with */const replaceWith = numbers.with(1, 100);console.log(&quot;with&quot;, replaceWith); // &quot;with&quot;, [1, 100, 3, 4, 5, 6, 7, 8, 9]console.log(&quot;original&quot;, numbers); // &quot;original&quot;, [1, 2, 3, 4, 5, 6, 7, 8, 9] 这段代码使用了 with 方法，该方法返回一个新数组，新数组在指定索引位置的元素被替换为指定值。我们可以看到，新数组的第二个元素已经被替换为 100，而原数组 numbers 并未被改变。 1234/* toSpliced */const splicedArr = numbers.toSpliced(0, 4);console.log(&quot;toSpliced&quot;, splicedArr); // &quot;toSpliced&quot;, [5, 6, 7, 8, 9]console.log(&quot;original&quot;, numbers); // &quot;original&quot;, [1, 2, 3, 4, 5, 6, 7, 8, 9] 这段代码使用了 toSpliced 方法，该方法返回一个新数组，新数组删除了原数组从指定位置开始的指定数量的元素。我们可以看到，新数组删除了从位置0开始的4个元素，而原数组 numbers 并未被改变。 这些都是ES2023将推出的一些令人期待的新功能. ❤ enjoy it.","categories":[{"name":"大前端","slug":"大前端","permalink":"https://blog.rexhang.com/categories/%E5%A4%A7%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://blog.rexhang.com/tags/javascript/"},{"name":"ES2023","slug":"ES2023","permalink":"https://blog.rexhang.com/tags/ES2023/"}]},{"title":"JS中判断对象是否为真·空","slug":"JS中判断对象是否为真·空","date":"2023-08-22T02:01:19.000Z","updated":"2023-08-22T05:44:58.963Z","comments":true,"path":"2023/08/22/articles/1/","link":"","permalink":"https://blog.rexhang.com/2023/08/22/articles/1/","excerpt":"","text":"一、前言js中判断对象是否为空有多种方法，比如转为string比较是否 === ‘{}’等，那么哪一种是最为正确的呢？ 1234567891011// 一种特殊键值 Symbol 作为keyconst name = Symbol(&#x27;name&#x27;);const obj = &#123; [name]: &#x27;rexhang&#x27;&#125;;console.log(obj); // &#123; Symbol(name): &#x27;rexhang&#x27; &#125;console.log(JSON.stringify(obj) === &#x27;&#123;&#125;&#x27;); // true, 期望得到false 因为对象内是有内容的，因此 此方法不准确console.log(Object.keys(obj).length === 0); // true, 拿不到Symbol keys 判断不准确// 推荐使用const isEmptyObject = globalThis.Reflect ? !Reflect.ownKeys(obj).length : !(Object.getOwnPropertyNames(obj).concat(Object.getOwnPropertySymbols(obj))).length;console.log(isEmptyObject); // false 由此可以得出 此对象(obj) 并非空对象 使用上述方法可以比较完美的解决 判断js对象是否为空的问题，说不定可以解决你一个生产环境的P0级别的BUG哟~ ❤","categories":[{"name":"大前端","slug":"大前端","permalink":"https://blog.rexhang.com/categories/%E5%A4%A7%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://blog.rexhang.com/tags/javascript/"},{"name":"javascript对象","slug":"javascript对象","permalink":"https://blog.rexhang.com/tags/javascript%E5%AF%B9%E8%B1%A1/"}]},{"title":"如何注册ChatGPT账号","slug":"如何注册ChatGPT账号","date":"2023-07-24T17:20:17.000Z","updated":"2023-07-25T07:07:30.526Z","comments":true,"path":"2023/07/25/articles/1/","link":"","permalink":"https://blog.rexhang.com/2023/07/25/articles/1/","excerpt":"","text":"简介 ChatGPT（全名：Chat Generative Pre-trained Transformer），是OpenAI研发的聊天机器人程序 ，于2022年11月30日发布。ChatGPT是人工智能技术驱动的自然语言处理工具，它能够通过理解和学习人类的语言来进行对话，还能根据聊天的上下文进行互动，真正像人类一样来聊天交流，甚至能完成撰写邮件、视频脚本、文案、翻译、代码，写论文等任务。 那么如何注册它呢，其实还是有一些小门槛的，下面就来介绍如何进行注册。 准备工作: 科学上网条件 谷歌、微软或者苹果邮箱, 其他邮箱不建议 国外手机号，没有也没关系，下文会推荐去一个平台使用国外的虚拟手机号来接受验证码等信息 第一步，设置代理科学上网软件设置为全局模式（可以查看下面2个网站来确认自己的是否处于外网网站1、网站2、网站3，），国家尽量选择北美或者日本这些国家，不要选择括号内这些国家（俄罗斯、中国、北朝鲜、古巴、伊朗、叙利亚、意大利）因为这些国家禁止使用ChatGPT服务，以下是符合注册条件的的IP示例 第二步(如果有国外手机号忽略此步骤)，打开虚拟电话号码注册平台打开虚拟电话号码注册平台，进入后点击右上角登录注册，先进行账号注册 还是一样，尽可能使用准备工作中准备好的邮箱平台进行注册，注册邮箱如果长时间没收到验证信息的，请检查是否被归类到垃圾邮件了，如果一切正常，点击官方发来的邮件后，会自动打开网址，那么此时你应该已经登录成功了，如下图所示 此时，我们在左侧搜索栏直接搜索openai，并且点击下图中粗红色框住的部分，可能由于没有钱包余额，购买失败，请继续往下看 商品列表中可以根据价格排序，选择最低价格的即可，推荐印度尼西亚 但是此时我们账户没余额，因此需要先充值，点击右上角用户头像旁边的加号按钮进入充值页面，拉到底部选择支付宝，进行充值付款即可(某些平台有的需要最低充值金额)，然后返回继续购买 充值完成后，右上角观察看到余额变化 点击购物车按钮即可，点一下就行，不要多点，以免造成重复扣费！如果购买成功页面会刷出来手机号码，直接去ChatGPT官网注册使用这个号码即可，短信验证码也会在web端刷出来，填入即可 下面来到上文提到的ChatGPT官网注册，点击注册按钮 选择三大邮箱或者准备好的国际其他平台邮箱，填入 此处我选择的谷歌邮箱 填入手机号的时候注意，如果是点击上方网站直接复制的手机号码记得去掉前面的几位xxx，例如+62就去掉复制出来的前两位62，+029就去掉复制出来的前三位029，如果验证手机号是无效的，可以在web网站点击号码后面的刷新按钮，获取一个新手机号，再返回重填即可，下面的选项选择NO，然后点击发送SMS 不出意外的话，回到短信平台验证码收到了，如下图所示，复制出来，填入Enter code输入框即可 随后网站会自动跳转到主应用界面，就可以在输入框输入内容进行提问了 至此，ChatGPT官网注册教程就基本完毕了，你可以愉快的使用啦，切记以后尽量使用同一个国家的节点，或者全局代理到合规的国家节点内，ChatGPT只要登录后，则可直接通过获取access_token，再结合潘多拉项目，达成在使用时能够免翻墙使用！","categories":[{"name":"ai","slug":"ai","permalink":"https://blog.rexhang.com/categories/ai/"},{"name":"openai","slug":"ai/openai","permalink":"https://blog.rexhang.com/categories/ai/openai/"},{"name":"chatgpt","slug":"ai/openai/chatgpt","permalink":"https://blog.rexhang.com/categories/ai/openai/chatgpt/"}],"tags":[{"name":"ai","slug":"ai","permalink":"https://blog.rexhang.com/tags/ai/"},{"name":"openai","slug":"openai","permalink":"https://blog.rexhang.com/tags/openai/"},{"name":"chatgpt","slug":"chatgpt","permalink":"https://blog.rexhang.com/tags/chatgpt/"}]},{"title":"前端技术摘要","slug":"前端技术摘要","date":"2023-07-01T14:22:22.000Z","updated":"2023-07-21T07:17:58.429Z","comments":true,"path":"2023/07/01/articles/1/","link":"","permalink":"https://blog.rexhang.com/2023/07/01/articles/1/","excerpt":"","text":"前端技术总结罗列(持续更新中…)1、localStorage、sessionStorage、cookie、session、indexDB… 跨页面共享策略？机制各有不同之处？如何跨页面通信？ postMessage、iframe、跨域策略、时效性… session: 存于服务器端，安全，前端不可改，大小几乎不限制, 可存在于redis、SQL数据库中 可用于登录cookie 4kb 不安全 默认20分钟 到期后会被清除 前后端都可设置 不设置的话自然会失效消失 可存储登录token 可被浏览器请求携带(默认携带跨域不携带)，请求的时候带上凭证配置(credentials)&lt;omit(不发送)、same-orgin(同源才发送 cookies)、include(必定全部发送)&gt;: true server端也需要接受Access-Control-Allow-Credentials才可sessionStorage 5MB+- 仅存在于当前会话页面 关闭后 会清除localStorage 5MB+- 持久化存储 不主动清除不会消失indexDB 大小默认50MB 不主动清除 除非手动 可以扩容 kv形式存储 2、React路由鉴权 包装组件后if return 3、策略模式 使用js策略模式优化代码 4、前端跨域问题解决 浏览器的一种在前端客户端进行的防护策略，规定必须同源同端口&lt;协议、域名、端口&gt;解决&lt;参考: 链接&gt;： jsonp Script、jQuery、Axios 跨域资源共享（CORS）前后端共同实现 简单请求和非简单请求 nginx反向代理接口跨域 nodejs中间件代理跨域 使用node + express + http-proxy-middleware搭建一个proxy服务器 node + vue|react + webpack + webpack-dev-server 进行proxy配置解决跨域访问资源 因为渲染和代理都在同一处不在跨域 document.domain + iframe跨域 主域相同，子域不同的跨域应用场景 eg: weixin.qq.com和im.qq.com 2边都强制设置 document.domain = qq.com 即可，iframe子窗口则可以通过window.parent.xx获取主页面中的全局变量内容了 location.hash + iframe跨域 不展开叙述 window.name + iframe跨域 不展开叙述 postMessage(data, origin) 主页面通过 iframeDom.contentWindow.postMessage(&#39;xx&#39;, &#39;*&#39;)发送数据，子页面(iframe)通过window.onMessage监听即可, 也可以再发给父级页面 window.parent.postMessage, 父级页面再window.onMessage监听 webSocket本身不存在跨域问题，所以我们可以利用webSocket来进行非同源之间的通信 socket.io前后端搭建ws服务实现跨页面数据传输 本质还是搭建服务器 使用chrome扩展插件解决跨域问题 针对特定浏览器内 解决跨域问题 因为本身扩展插件是不会被跨域策略拦截的 利用这一特性实现 chrome版本号49之前的跨域设置 启动目标框里加上 --disable-web-security 前端chrome插件配置代理 + 后端接口代理请求服务实现 5、Js instanceof 用于检测构造函数的 prototype 属性是否出现在某个实例对象的原型链上 参考URLa instanceof A 用于检测 a是一个实例化对象 它的__proto__是否指向或者说是等于A的prototype 6、事件循环 任务队列 宏任务 微任务 同步任务 放入主线程中 eg: console.log(‘’); 异步任务 放入任务队列中(延迟性任务) 宏任务 setTimeout、setInterval等(优先级低于微任务) 微任务 Promise await async Object.observe MutationObserver process.nextTick(优先级最高)等 主线程先执行，然后微任务 7、http请求过程 浏览器输入网址DNS解析得到服务器IP，进行三次握手，建立TCP协议 客户端web浏览器向服务器发起请求，发送http请求和头信息发送 服务端应答客户端请求，响应头信息和浏览器所需内容 根据请求头信息是否包含keep-alive，决定是关闭TCP或保持TCP 最后客户端web浏览器得到服务端响应的结果 8、JSBridge原理 &lt;参考: 链接&gt;： 注入API 注入API，是通过WebView，向JavaScript的Context(window)上注入对象或方法，js直接调用注入的方法，即可执行Native的功能 拦截URL Scheme wx://ht/xxx?data=aa JS发送URL Scheme请求 重写 prompt 等原生 JS 方法 9、Vue、React优缺点比较 渲染执行机制 生命周期 xxx 10、Vue2和Vue3区别 vue2的双向数据绑定是利用了es5 的一个API Object.defineProperty() 对数据进行劫持 结合发布订阅模式来实现的。vue3中使用了es6的proxyAPI对数据进行劫持后处理。 Vue2是Vue.js的早期版本，已经经过多年实践检验，是稳定的版本。Vue3是Vue.js的最新版本，在保留Vue2的优点的同时，提供了更多的新特性和改进。 Vue2使用虚拟DOM来提高渲染性能，并提供了组件化的开发模式。Vue3在此基础上进一步优化了虚拟DOM的实现，并引入了编译器和运行时编译，使得渲染性能更高、代码更小、更灵活。 Vue2提供了响应式系统和组件化的开发模式，支持使用插件扩展功能。Vue3在此基础上提供了更多的开发工具，如可观察对象和组件代码分离等，使得开发更快捷、更灵活。 总的来说，Vue3在保留Vue2的优点的同时，提供了更快的运行速度、更小的体积和更多的灵活性，可以更好地满足开发人员的需求。 11、React Fiber原理和作用 概念: React Fiber是React执行渲染时的一种新的调度策略，因JavaScript是单线程的，一旦组件开始更新，主线程就一直被React控制，这个时候如果再次执行交互操作，就会容易导致卡顿，React Fiber就是来解决这个问题的 React Fiber就是通过对象的形式来记录组件上需要做或者已经完成的更新等详细信息，一个组件可以对应多个Fiber React Element树在第一次渲染的时候会创建一颗结构一模一样的的Fiber节点树（Fiber是个链表，有child和sibing属性FiberTree）。不同的React Element类型对应不同的Fiber节点类型。一个React Element的工作就由它对应的Fiber节点来负责。 React Fiber这种方式，渲染过程采用切片的方式，每执行一会儿，就歇一会儿。如果有优先级更高的任务到来以后呢，就会先去执行，降低页面发生卡顿的可能性，使得React对动画等实时性要求较高的场景体验更好。 参考: 链接 12、React高版本(v.18)新增的方法及作用 React18 通过其改进的渲染系统带来了并发能力，严格模式更新(更严格) flushSync函数来强制立即刷新更改(异步变同步)1234567891011import &#123; flushSync &#125; from &quot;react-dom&quot;;const handleClick = () =&gt; &#123; flushSync(() =&gt; &#123; setA(a =&gt; a + 1); &#125;); // Re-render flushSync(() =&gt; &#123; setB(b =&gt; b - 1); &#125;); // Re-render&#125;; 并发的React, useTransition, 可以使用 useTransition() 钩子来创建一个 transition。这个钩子返回一个函数来启动一个 transition，还有一个挂起的指示器来通知你 transition 的进度。12345678910111213141516import &#123; useTransition, useState &#125; from &quot;react&quot;;const App = () =&gt; &#123; const [isPending, startTransition] = useTransition(); const [value, setValue] = useState(0); function handleClick() &#123; startTransition(() =&gt; &#123; setValue((value) =&gt; value + 1); &#125;); &#125; return ( &lt;div&gt; &#123;isPending &amp;&amp; &lt;Loader /&gt;&#125; &lt;button onClick=&#123;handleClick&#125;&gt;&#123;value&#125;&lt;/button&gt; &lt;/div&gt; );&#125;; Suspense组件等 13、React Redux 原理 action 事件处理函数，有多个 action 是一个事件处理器，结构可以是switch case的模式 定义数据合成 store.dispatch() 将 action 传到 store12345678910111213import &#123; USER_INFO &#125; from &quot;../constants/actionTypes&quot;;import store from &#x27;../store/store&#x27;export const switchUser = (data) =&gt; &#123; return dispatch =&gt; &#123; // do somethings... dispatch(&#123; type: USER_INFO, payload: &#123; ...data, &#125; &#125;); &#125;&#125; reducer Reducers 指定了应用状态的变化如何响应 actions并发送到 store 的 reducer函数主要接收2个参数,state和action switch action.type 做出state数据合成并返回处理后的12345678910111213141516171819202122232425import &#123; USER_INFO &#125; from &quot;../constants/actionTypes&quot;;const redUserInfo = (state = &#123; userId: 1, userName: &#x27;&#x27;&#125;, action) =&gt; &#123; if (action === undefined) &#123; return state &#125; switch (action.type) &#123; case USER_INFO: return &#123; ...state, ...action.payload, &#125; case USER_SET: return &#123; ...state, ...action.payload, set: true, &#125; default: return state &#125;&#125; store redux 提供一个 createStore方法 传入 reducers 并返回新的store对象 code: 1234import &#123; createStore &#125; from &#x27;redux&#x27;import reducers from &#x27;../reducers/index&#x27;let store = createStore(reducers, ...initState)export default store Provider Provider 其实就只是一个外层容器，它的作用就是通过配合 connect 来达到跨层级跨组件共享传递数据。123456import store from &#x27;../store/store&#x27;&lt;Provider store=&#123;store&#125;&gt; &lt;PersistGate loading=&#123;null&#125; persistor=&#123;persistor&#125;&gt; &lt;About&gt;&lt;/About&gt; &lt;/PersistGate&gt;&lt;/Provider&gt; connect connect 的作用是连接React组件与 Redux store 它接收上面 Provider 提供的 store 里面的 state 和 dispatch，并返回一个对象，以属性形式传给我们的容器组件的props对象内1234567891011121314151617181920212223242526272829import &#123; connect &#125; from &#x27;react-redux&#x27;;import &#123; add, del, switchUser &#125; from &#x27;../../store/action/numAction&#x27;;function About(props) &#123; const &#123; add, del, item, switchUser &#125; = props const test = () =&gt; &#123; add(item) &#125; const test1 = () =&gt; &#123; del(item) &#125; return ( &lt;div&gt; &lt;h3&gt;我是About的内容&lt;/h3&gt; &lt;div&gt;&#123;item&#125;&lt;/div&gt; &lt;button onClick=&#123;() =&gt; test()&#125;&gt; 增加 &lt;/button&gt; &lt;button onClick=&#123;() =&gt; test1()&#125;&gt; 减少 &lt;/button&gt; &lt;/div&gt; )&#125;const mapStateToProps = state =&gt; &#123; return &#123; userInfo: &#123; ...state.userInfo &#125; &#125;&#125;const mapDispatchToProps = dispatch =&gt; &#123; return &#123; add(data)&#123; dispatch(add(data)); &#125;, switchUser: data =&gt; dispatch(switchUser(data));, &#125;&#125;export default connect(mapStateToProps, mapDispatchToProps)(About); 14、发布订阅 new event() on emit … 15、ES6新增内容 解构赋值，展开运算符（形参剩余量…rest），默认值定义，Promise异步方案，symbol数据类型，箭头函数 ES6新增了数组操作方法includes、map、forEach、findIndex、filter、some、every、reduce、 16、判断当前web环境是否支持某个css属性 例如 判断是否支持css { position: sticky }CSS.supports(&quot;position&quot;, &quot;sticky&quot;): boolean … 17、Map和Object区别 键的区别(Map可以是任意数据类型，Object只能string，或者symbol) … 18、Map和Set区别 共同点 它们的内容都是可迭代对象 都有delete、has、clear等方法 不同点 Map值是双元数组，key可以为任何数据，这点区别于普通Object只能是数字或字符串(Symbol) Set值是单个可迭代对象，key = value，因此可以直接add而不需要set(k, v)的方法 19、Js链式调用概念: 所谓的链式调用，简单粗暴的讲，就是在一个实例对象调用完一个方法后，在后边可以一直去调用其他方法，例如，Promise.then()的方法就是一个很好的例子，他可以在后边一直的.then下去。 1234567891011121314151617181920212223242526272829303132333435/* 简单的链式调用 */class Person &#123; constructor(name, age) &#123; this.name = name this.age = age &#125; info() &#123; console.log(`$&#123;this.age&#125;的$&#123;this.name&#125;`); return this &#125; start() &#123; console.log(&#x27;开始起床！&#x27;); return this &#125; eat() &#123; console.log(&#x27;开始吃饭&#x27;); return this &#125; school() &#123; console.log(&#x27;开始上学！&#x27;); return this &#125; sleep() &#123; console.log(&#x27;开始睡觉&#x27;); return this &#125; &#125; const person = new Person(&#x27;小红&#x27;, 36); person.info().start().eat().school().sleep(); // 36的小红 // 开始起床！ // 开始吃饭 // 开始上学！ // 开始睡觉 第二种，异步任务的处理方式 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354/* 如果加上异步代码那该如何实现 */function People(name) &#123; this.name = name; // 创建一个数组模拟任务队列 this.queue = []; // 用延迟器开启一个事件的总线 setTimeout(() =&gt; &#123; // 首次会调用next console.log(&#x27;首次会调用next&#x27;) this.next(); &#125;, 0); // 将this返回 return this;&#125;People.prototype.next = function() &#123; // 将队列中的第一个任务找出 const fn = this.queue.shift(); // 如果有任务的话就进行调用 fn &amp;&amp; fn();&#125;People.prototype.sayHello = function() &#123; const fn = () =&gt; &#123; console.log(&#x27;您好，我叫&#x27; + &quot; &quot; + this.name); this.next(); &#125; // 将该任务添加到队列当中 this.queue.push(fn); return this;&#125;People.prototype.eat = function(time) &#123; const that = this; const fn = () =&gt; &#123; setTimeout(function() &#123; console.log(`吃饭花费了 $&#123;time&#125;s`); that.next(); &#125;, time * 1000); &#125; that.queue.push(fn); return that;&#125;People.prototype.taskList = function() &#123; const fn = () =&gt; &#123; console.log(this.queue); &#125; this.queue.push(fn); return this;&#125;const people = new People(&#x27;rex&#x27;);people.sayHello().eat(2).taskList().queue; 20、Set集合forEach遍历会导致无限循环问题 在调用forEach遍历Set集合的时候，如果其中1个值被删除后又被重新添加到集合,那么该访问会重新再来1次, 形成无限循环 12345678910111213141516const set = new Set([1, 2])const newSet = new Set(set);console.log(set);console.log(newSet);newSet.forEach((item: key值, index: &lt;索引不是从0开始 而是 === item(key值)&gt;, s: Set) =&gt; &#123; console.log(set); console.log(item, index, s) newSet.delete(2); // newSet.add(2); newSet.add(new Date().getTime()); console.log(&#x27;我在遍历&#x27;);&#125;)；console.log(newSet);console.log(set); 21、Js柯里化 柯里化是一种函数的转换。是指将一个函数从可调用的 f(a, b, c) 转换为 f(a)(b)(c)。 解决&lt;参考: 链接&gt;： 12345678910111213141516171819202122function sum(num) &#123; //function s(innerVar)&#123; //num += innerVar; // arguments.callee 是一个指向正在执行的函数的指针，因此可以用它来实现对函数的调用，使用 arguments.callee 代替函数名，可以确保无论怎样调用函数都不会出问题。 // 注意点: &quot;use strict&quot; 下 不可用 使用下面写的第二种 //return arguments.callee; //&#125; // 不过，可以使用命名函数表达式来达成相同的结果 // 以上代码创建了一个名为 f()的命名函数表达式，然后将它赋值给变量 s。即便把函数赋值给了另一个变量，作用域内函数的名字 f 仍然有效 const s = (function f(innerVar)&#123; num += innerVar; return f; &#125;); s.toString = function()&#123; return num; &#125; return s;&#125;console.log( sum(3)(2)(1)(4) );alert(sum(3)(2)(1)(4));console.log( sum(1) )console.log( sum(1) * 1 ) 解析:s function 主要用来保存数据的累加 并 返回函数 让其能够继续被调用s.toString 主要用来实现静态方法，能够访问函数内部作用域内的变量(闭包特性)最后返回s方法sum(1) ===&gt; 会把num = 1放到toString中返回，没有调用到ssum(1)(2) ===&gt; 运行了s函数(会把2放到s函数的位参innerVar位置)，然后对num进行累加处理, num = num + innerVar, 且继续返回成可调用的s方法，接着s.toString会返回闭包中的最新num结果，以供静态调用(例如当函数进行比较时运算会调用toString方法，&lt;数据基本类型比较时可能会发生转换, 具体可参考资料&gt;)，例如alert，或者console.log( sum(1)(2) * 1 ) 使之发生数据转换得到静态化的结果值，实现功能 22、Js函数的指针(this) 普通函数、箭头函数&lt;()=&gt;{}&gt;的指针 1、只有一个参数的时候，参数可以不加小括号，没有参数或2个及以上参数的，必须加上小括号2、返回语句只有一条的时候可以不写{}和return，会自动加上return的，返回多条语句时必须加上{}和return3、箭头函数在返回对象的时候必须在对象外面加上小括号 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253// &#x27;use strict&#x27;;// 1、普通函数this指向：// 指向它的调用者，如果没有调用者则默认指向Window// 2、箭头函数指向：// 指向箭头函数定义的时候所处的对象，而不是其所使用的时候所处的对象，默认指向父级的this// 综上：箭头函数没有自己的this，它的this是继承来的，默认指向它定义的时候所处的对象const fMap = &#123; name() &#123; // this = 对象本身fMap console.log(this); &#125;, age: (e) =&gt; &#123; // this = window console.log(this); &#125;, sex: function() &#123; // this =&gt; fMap this.xx = &#x27;xx&#x27;; function the4() &#123; // this =&gt; window console.log(this); &#125;; const the5 = () =&gt; &#123; // this =&gt; sex的this = fMap console.log(this); &#125; the4(); the5(); &#125;&#125;fMap.name();fMap.age();fMap.sex();// 定义构造函数 如果函数是构造函数，那this将指的新的对象function Persion() &#123; // this指向p this.age = 0; console.log(this); setInterval(function () &#123; // this 指向Window this.age++; console.log(this); &#125;, 1000); setInterval(() =&gt; &#123; // ★ 箭头函数从自己的作用域链上一层继承的this，所以这个this也指向p this.age++; console.log(this); &#125;, 1000);&#125;// Persion();// this -&gt; windowconst p = new Persion(); // this =&gt; p;p.name = &#x27;rex&#x27;;console.log(p); 总结: 普通function函数this指向: 指向它的调用者，如果没有调用者则默认指向Window 箭头函数this指向: 指向箭头函数定义的时候所处的对象(默认指向父级的this) 如果没有父级程序 或者 父级程序没有指向 箭头函数的this指向是window 箭头函数没有自己的this，它的this是继承来的 箭头函数和普通函数的区别 箭头函数是匿名函数，普通函数可以是匿名函数也可以是具名函数 箭头函数不能作为构造函数使用，不能使用new关键字 箭头函数没有原型，所以没有prototype属性 call、apply、和bind无法改变箭头函数的this指向，但可以改变普通函数的this指向 箭头函数没有arguments对象，如果有外层函数，则继承外层函数的arguments，没有外层函数则会报错，箭头函数用的是rest参数（形式为: …rest） 箭头函数没有Generator，不能使用yield关键字 箭头函数没有自己的this 23、Vue3 composition API(组合式API) 类似于React的HOC高阶组件、Hooks 将组件的功能抽象为函数或对象的形式, 提高组件的可复用性和可维护性 24、函数式编程 xxx … 25、CI/CD 代码-编译-多环境测试部署-生产-回滚&lt;参考: 链接&gt;： 持续集成(CI) 持续部署(CD) 26、DevOps DevOps是一种思想，是一种文化，主要强调软件开发测试运维的一体化，目标是减少各个部门之间的沟通成本从而实现软件的快速高质量的发布。CI/CD是指持续集成发布部署，是一套流程实现软件的构建测试部署的自动化。DevOps与CICD紧密相关，是理论与实践的结合，DevOps要实现人员一体化，必须要借助CICD工具来自动化整个流程。 xxx … 27、ES6 Class的get set get set static 不要和this.xx重名 get vars(): string|xx —&gt; 只读 类似于 computed 返回值 set vars(value): void —&gt; 同computed 可以监听数据变动做出适当的相应 static method(): void —&gt; 定义静态方法, 不能在类的实例上调用静态方法, 而应该通过类本身调用。 28、Object.defineProperty Object.defineProperty(对象, &#39;某成员属性&#39;, &#123; ...配置项 &#125;) 主要配置 12345678910111213&#123; writable： 是否可重写 value： 当前值 get： 读取时内部调用的函数 set： 写入时内部调用的函数 enumerable： 是否可以遍历 configurable： 是否可再次修改配置项&#125; 29、前端性能优化(多角度) 加载优化 CSS优化 图片优化 脚本优化 渲染优化 … 30、SSR(NEXT.js、NUXT.js) Vue、React服务端渲染 Server Side Rendering … 31、算法: 冒泡排序 xxx … 32、求2个数组之间的【交集】【并集】【差集】 xxx … 33、Webpack、Vite、Rollup工作原理 Webpack 需要查找依赖，打包所有的模块，然后才能提供服务，更新速度会随着代码体积增加越来越慢 解析入口文件搜集依赖形成抽象语法关系树AST 接着解析AST加载模块，根据不同模块使用加载器进行处理 编译模块，变成可执行的js代码 打包输出(1或者多个文件 可以是css、js、等) 优化和插件系统(混淆、加密等) Vite 使用原生 ESModule 通过 script 标签动态导入，访问页面的时候加载到对应模块编译并响应 项目打包的时候最终还是需要打包成静态资源的，打包工具 Rollup 34、React组件重新渲染(刷新) &lt;参考: 链接&gt;： 类组件 this.forceUpdate(); 功能组件 函数组件: 调用App.render 用自己的新实例替换状态对象setUser(&#123; ...user &#125;); 让一个空的状态变量触发更新 12const [, updateState] = React.useState();const forceUpdate = React.useCallback(() =&gt; updateState(&#123;&#125;), []); 35、Keep-alive 缓存组件的一种解决方案 &lt;参考: 链接&gt;： vue 内置组件 keep-alive动态缓存方案 在组件切换过程中将状态保留在内存中，防止重复渲染DOM，减少加载时间及性能消耗，提高用户体验性 keep-alive包裹动态组件时，会缓存不活动的组件实例，而不是销毁它们。一般用法为下 例如路由，按需设置，性能达到最为均衡的状态 可以结合router来处理路由页面的缓存，在router中设置router的元信息meta : keepAlive: true &lt;keep-alive&gt; 包裹组件(路由) 进行缓存12345&lt;keep-alive&gt; &lt;router-view v-if=&quot;$route.meta.keepAlive&quot;&gt;&lt;/router-view&gt;&lt;/keep-alive&gt;// 这里不需要缓存&lt;router-view v-if=&quot;!$route.meta.keepAlive&quot;&gt;&lt;/router-view&gt; 路由配置1234567&#123; path:&quot;/list&quot;, component:HomeBookList, meta: &#123; keepAlive: true // 需要缓存 &#125;&#125; keep-alive支持三个属性，分别是 include - 字符串或正则表达式。只有名称匹配的组件会被缓存。 exclude - 字符串或正则表达式。任何名称匹配的组件都不会被缓存。 max - 数字。最多可以缓存多少组件实例。 通过设置: include = 变量数组, 然后监听路由 watch(to, from)，判断去到指定的路由的时候，改变这个变量数组，去掉缓存即可， keep-alive 中创建的组件，会多出两个生命周期的钩子: activated 与 deactivated activated在缓存组件激活时调用 deactivated在缓存组件失活时调用，取代原本的destroyed 36、路由守卫 全局守卫 router/index.js router.beforeEach(to, from, next) 全局前置路由守卫，每次路由切换之前被调用，可以做**权限拦截 **需要调用next() router.afterEach(to, from) 全局后置路由守卫，每次路由切换之后调用,注意没有next 可用于切换document.title router.beforeResolve 和 beforeEach类似 也属于全局守卫 区别是 在所有组件内守卫和异步路由组件被解析之后 导航确认之前 会调用 独享守卫 router/index.js router.beforeEnter(to, from, next)针对某个路由单独设置的守卫 独享路由守卫，只有前置，没有后置，写在routes配置项里，路由进入之前会调用 组件内守卫 Demo.vue router.beforeRouteEnter(to, from, next) 在渲染该组件的对应路由被 confirm 前调用 不可以访问本组件this对象 但是可以在next回调首个形参里面得到vm来访问this, 然后可以return false 来做拦截 router.beforeRouteUpdate(to, from, next) 在当前路由改变，且该组件被复用时调用 eg: /item/:id 之间跳转的时候 会被调用 切换路由动态参数的时候 router.beforeRouteLeave(to, from, next) 导航离开该组件的对应路由时调用 37、闭包 什么是「闭包」。 「函数」和「函数内部能访问到的变量」的总和，就是一个闭包。 「闭包」的作用是什么。 可以用来封装插件、柯里化… 闭包副作用 内存泄漏 -&gt; 坑没空着的了 内存溢出(扩展内容非闭包导致) -&gt; 一个坑2个人爆炸了 38、JavaScript中window.onload和document.onload有什么区别？&lt;参考: 链接&gt;： document.onload 在加载图像和其他外部内容之前将其触发。文件。在window.onload之前触发onload事件。 window.onload 加载整个页面（包括图像，脚本，css等）完成时，它将被触发。 $(document).ready() || DOMContentLoaded 当页面 DOM 加载完成后，ready() 里的函数便会立即执行 document.onload 和 document.ready onload 文档元素加载完毕后执行 只能执行一次 会覆盖 需要等待所有资源全部加载完成， ready 或者 DOMContentLoaded 不会覆盖 都会执行 执行顺序在load之前，只需等待DOM树结构完成 即可触发 document.body.onload 需要在body标签内引用才有效，body内容加载完成 总结: 使用window.onload 和 DOMContentLoaded 即可 DOMContentLoaded - load - beforeunload - unload DOMContentLoaded 只能用 addEventListener 39、JavaScript中事件委托(代理)的作用 JQ bind和on的区别 addEventListener和普通on区别 捕获顺序 冒泡顺序 怎么取消冒泡 事件委托是利用事件冒泡，只指定一个事件处理程序来管理某一类型的所有事件 delegate 执行事件委托 指定元素类型 ul.delegate(li, clickFunc) bind不能给不存在的元素绑定例如click事件 on可以代理也可以给未来的元素添加 bind只能给符合条件的元素本身添加事件 捕获行为是由上往下，而冒泡阶段是自下往上 事件流的三个阶段：冒泡阶段、捕获阶段、目标阶段 on会被覆盖 addEventListener(&gt;=IE9) 不会被覆盖 40、Webpack、Vite 工作流程 xxx … 41、Js call apply bind 区别 xxx … 42、Vue代码优化(下文续有性能优化) Object.freeze() 减少ES6代码，降低webpack编译的代码量 43、flex布局、多端兼容、响应式布局 rem原理 计算方法 1234const b = window.devicePixelRatio//dprconst c = &#x27;某个自己设置的值，我们公司为375px&#x27; //切图稿的统一宽度const d = document.documentElement.clientWidth//视口宽度const e = &#x27;某个自己设置的值，我们公司为37.5px&#x27; //根元素font-size大小 第一种方法是将px转化成rem再除以e 第二种方法非要用px作单位的话就把值除以c再乘以d webpack 插件 npm install px2rem-loader lib-flexible --save-dev 123456789101112131415module.exports = &#123; // ... module: &#123; rules: [&#123; test: /\\.less$/, use: [&#x27;style-loader&#x27;, &#x27;css-loader&#x27;, &#x27;less-loader&#x27;, &#123; loader: &#x27;px2rem-loader&#x27;, options: &#123; remUni: 75, // 适合750的设计稿 1rem = 75px remPrecision: 8 // px转rem小数点保留的位置 &#125; &#125;] &#125;] &#125;&#125; 在项目中引入lib-flexible &lt;script src=&quot;lib-flexible/flexible.js&quot;&gt;&lt;/script&gt; lib-flexible应最早执行 这样就可以实现PX到REM单位的自动转化了~ rem 计算原理: const w = 计算当前视口宽度(document.documentElement.clientWidth) eg: 375px const designWidth = 750px const dzr = w / designWidth eg: 0.5 // 设备缩放比 给html设置font-size = dzr =&gt; // 0.5 设计图 10px =&gt; 10px * dzr = 5px 设计图 12px =&gt; 12px * dzr = 6px dzr = 0.3 设计图 *12px =&gt; 12px * 0.3 = 3.6px* 非常不好计算, 因此可以在初始的时候 放大100倍 利于计算 给html设置font-size = dzr * 100 = 30px 设计图 12px =&gt; 12px * 0.3 * 100 = 360px 1rem = 0.3 x 100 x 1px = 300px 12px = (1rem / 100) * 12 0.12rem 总结: 先计算1个单位像素的比例 html: 1个单位 = 缩放比，1rem = 缩放比 x 单位量 但是方便计算 会倍率 否则rem: 0.3 x 12px，不利于计算 因此先x100 html set 缩放比*100 再除100 就是 rem: 1个html x 12 相当于12个单位的量 rem = 12 / 100 = 0.12rem 因为整体x了100倍 所以直接除以100即可 44、created、mounted和this.$nextTick()的区别 created: 页面渲染成htlm之前运行 可以做一些初始化操作 生命周期运行1次 mounted: 页面渲染成html后运行 可以操作一些静态dom元素 生命周期运行1次 this.$nextTick(fn) fn中可以对动态dom进行操作 生命周期运行多次 45、浏览器垃圾回收的基本算法 引用计数法，为0时，释放 有缺陷: 互为引用 标记清除法，先标记 后 回收, 从根部[globalThis]找有无使用处，无则回收 46、vue2性能优化 解决&lt;参考: 链接&gt;： Deferred 延迟 分批渲染 xxx 47、websocket soket.io xxx 48、Web Worker 浏览器提供的一种通信方式(API)，由主线程main script 和 worker script进行通信的 有利于性能提升 xxx 49、算法 二分法排序 冒泡排序 xxx 50、原型链的理解 原型链的理解prototype xxx 51、Vue组件重新渲染(刷新) :key 更改会刷新 v-if 会刷新 main.js 使用 Vue.forceUpdate()后 组件中使用this.$forceUpdate 刷新页面有路由的话 刷当前 this.$router.go(0)、 返回上一页 go(-1) 去另外的路由页 push(‘/login’) 或 push({ name: ‘login’ }) 52、在多个文件中import同一个文件，webpack会多次打包吗 不会 不同文件中多次import同一个文件，webpack并不会多次打包，只会在打包后的文件中会多次引用打包后的该文件对应的函数。 参考 53、React高阶组件HOC 实际上就是一个函数或者一个类 接收一个组件作为参数 然后生成新的组件 其中包含了参数组件体 … 54、TypeScript中type与interface的区别 interface用于定义一个新的对象的结构跟类型type用于给一个已存在的对象取名或者赋予别名 interface可以重复定义一个对象，最终的结果是合集的状态 1234567891011121314151617interface Person &#123; name: string age: number&#125;interface Person &#123; address: string&#125;type Person2 = &#123; name: string age: number&#125;type Person3 = Person2 &amp; &#123; address: string&#125; type可以定义联合类型，比如: 1type language = &#x27;cn&#x27;|&#x27;en&#x27;|&#x27;jp&#x27; 55、JWT是什么? 是一种用于在前端web端进行认证和授权的令牌机制、在前端存储传递 json web tokens 来实现用户身份校验和访问控制 header、payload、signature，三段式.隔开 http请求头可带上、cookie也可以带上、?token也可带上 56、简述HTTP 主要分为以下7步骤：DNF-&gt;IP 建立TCP、发起请求、服务端接收处理请求、服务端返回结果、客户端接收结果、客户端处理结果、关闭连接，复杂情况还需要加上重定向等 三次握手 1客户端发给服务端带有一把确认的钥匙，2服务端收到了你的钥匙并给你客户端发起一个确认，3.客户端从服务端得到了钥匙的确认信息","categories":[{"name":"大前端","slug":"大前端","permalink":"https://blog.rexhang.com/categories/%E5%A4%A7%E5%89%8D%E7%AB%AF/"},{"name":"面试经","slug":"大前端/面试经","permalink":"https://blog.rexhang.com/categories/%E5%A4%A7%E5%89%8D%E7%AB%AF/%E9%9D%A2%E8%AF%95%E7%BB%8F/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://blog.rexhang.com/tags/javascript/"},{"name":"前端技术","slug":"前端技术","permalink":"https://blog.rexhang.com/tags/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/"}]},{"title":"如何编写web前端开发岗简历","slug":"如何编写web前端开发岗简历","date":"2022-12-15T04:10:01.000Z","updated":"2022-12-15T03:16:34.572Z","comments":true,"path":"2022/12/15/articles/2/","link":"","permalink":"https://blog.rexhang.com/2022/12/15/articles/2/","excerpt":"","text":"如何编写web前端开发岗简历 编写简历时，首先要包括你的个人信息，包括姓名、联系方式、电子邮箱和地址。接下来，你可以简要介绍你的教育背景和工作经验。 在简历中提及你对 Web 前端开发的经验。你可以提到你掌握的主要技术，例如 HTML、CSS 和 JavaScript，并列出你的项目经验。此外，你还可以提到你对用户体验和交互设计的兴趣和经验。 另外，你可以在简历中提到你的专业技能和特长，例如掌握的其他编程语言和框架，或者对数据分析和可视化的经验。这些内容可以帮助雇主了解你的能力，并决定是否与你进一步沟通。 最后，你可以在简历中列出你的证书和荣誉，以及参加过的培训和活动。这些内容有助于雇主了解你的专业知识和技能水平，并评估你是否符合他们的招聘标准。 总之，在编写简历时，要注意清晰、简洁、准确地展示你的个人信息和专业技能，以便雇主能够快速了解你，并决定是否与你进一步沟通 个人信息，包括姓名、电话号码、电子邮件地址和社交媒体链接。 教育经历，包括毕业院校、学位和专业。 工作经历，包括公司名称、职位名称和工作描述。 技能清单，包括掌握的语言、框架和工具。 项目经验，包括项目名称、描述和贡献。 证书或其他资格证明。 编写简历时，要尽量详细且简洁，将你的能力和经验介绍给招聘方。为了让你的简历更加出色，还可以添加下列内容： 个人简介，包括你的专业方向、兴趣爱好和个人特点。 其他语言能力，如果你会一种或多种外语，可以在简历中提及。 兴趣爱好或个人项目，如果你有一些有趣的兴趣爱好或个人项目，可以在简历中提及。 总之，编写简历时要注意交代清楚你的能力和经验，并以简洁易读的方式展现出来。 编写一份web前端开发岗简历，首先应该包含您的个人信息，包括姓名、联系方式和电子邮件地址。接下来，应该概述您的专业技能和工作经验，并突出您在web前端开发方面的专业知识和经验。 在描述您的专业技能时，应该清楚地说明您掌握的技术和工具，例如HTML、CSS、JavaScript、jQuery、Bootstrap等。此外，还应该简要说明您了解的开发框架和库，例如React、Vue、Angular等。 在描述您的工作经验时，应该简要介绍您曾经参与的项目，包括项目的主要功能、您负责的工作内容和您贡献的主要技术。此外，还应该提及您的工作态度和工作能力，例如认真负责、注重团队合作、熟练掌握代码调试等。 在编写完简历之后，应该仔细检查语法和拼写错误，并确保简历内容简洁明了，表达出您的专业知识和工作经验。此外，还应该考虑简历的整体布局和设计，以确保简历能够吸引招聘方的眼球。 在简历开头写明自己的个人信息，包括姓名、电话号码、电子邮件地址、个人网站等。 接下来，写出自己的教育背景，包括所就读的大学和专业。如果有相关的证书或培训课程，也可以在这一部分提及。 在工作经验部分，按照时间倒序列出自己的工作经历。对于每个工作经历，可以描述工作内容、工作职责和所取得的成就。 在技能部分，列出自己在web前端开发方面的技能，包括熟悉的编程语言、框架和工具。还可以提及自己对用户体验和可用性的关注程度。 在简历末尾，可以附上作品集，展示自己在web前端开发方面的能力。这一部分可以包括项目链接、设计稿和截图等。 在简历最后，可以写一段自荐信，介绍自己的工作理念和为公司所做的贡献。 总的来说，编写web前端开发岗简历时，应该注重个人信息的准确性、工作经历的详实性","categories":[{"name":"面试经","slug":"面试经","permalink":"https://blog.rexhang.com/categories/%E9%9D%A2%E8%AF%95%E7%BB%8F/"},{"name":"前端","slug":"面试经/前端","permalink":"https://blog.rexhang.com/categories/%E9%9D%A2%E8%AF%95%E7%BB%8F/%E5%89%8D%E7%AB%AF/"},{"name":"JavaScript","slug":"面试经/前端/JavaScript","permalink":"https://blog.rexhang.com/categories/%E9%9D%A2%E8%AF%95%E7%BB%8F/%E5%89%8D%E7%AB%AF/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://blog.rexhang.com/tags/JavaScript/"},{"name":"面试经","slug":"面试经","permalink":"https://blog.rexhang.com/tags/%E9%9D%A2%E8%AF%95%E7%BB%8F/"},{"name":"前端","slug":"前端","permalink":"https://blog.rexhang.com/tags/%E5%89%8D%E7%AB%AF/"}]},{"title":"json-server的使用(接口数据mock好帮手)","slug":"json-server","date":"2022-12-15T04:00:20.000Z","updated":"2022-12-15T03:16:34.572Z","comments":true,"path":"2022/12/15/articles/1/","link":"","permalink":"https://blog.rexhang.com/2022/12/15/articles/1/","excerpt":"","text":"简介 json-server: 接口数据mock好帮手 新建文件&lt;db.json&gt;, 内容如下: 123456789101112131415161718192021222324252627&#123; &quot;posts&quot;: [ &#123; &quot;id&quot;: 1, &quot;title&quot;: &quot;json-server&quot;, &quot;author&quot;: &quot;typicode&quot; &#125; ], &quot;comments&quot;: [ &#123; &quot;id&quot;: 1, &quot;body&quot;: &quot;some comment&quot;, &quot;postId&quot;: 1 &#125; ], &quot;profile&quot;: &#123; &quot;name&quot;: &quot;typicode&quot; &#125;, &quot;users&quot;: [ &#123; &quot;id&quot;: 1, &quot;name&quot;: &quot;rexhang&quot;, &quot;guid&quot;: &quot;ee7a6768-bb2c-423c-ac06-5c7905c035b5&quot;, &quot;time&quot;: &quot;Wed, 14 Dec 1970 13:20:02 GMT&quot; &#125; ]&#125; 安装&amp;启动 npm install -g json-server 默认启动在localhost:3000端口，参数: 可以监听文件变化 –watch, 可以指定端口号 –port, 可以指定host –host json-server --watch db.json --port 8111 --host 127.0.0.1 然后会以JSON成员为键名，生成若干个请求地址，http://127.0.0.1:8111/JSON_KEY 请求方法(实现CURD) with REST Client(Ext) -&gt; 直达官网 Create 123456789###POST http://127.0.0.1:8111/userscontent-type: application/json &#123; &quot;name&quot;: &quot;rexhang&quot;, &quot;guid&quot;: &quot;&#123;&#123;$guid&#125;&#125;&quot;, &quot;time&quot;: &quot;&#123;&#123;$datetime rfc1123|iso8601&#125;&#125;&quot;&#125; Update 1234567###PATCH http://127.0.0.1:8111/users/1content-type: application/json &#123; &quot;name&quot;: &quot;rexhang&quot;&#125; Read 12###GET http://127.0.0.1:8111/profile 1234###GET http://127.0.0.1:8111/users?id=1&amp;name=rexhang Delete 12###DELETE http://127.0.0.1:8111/users/1","categories":[{"name":"前端","slug":"前端","permalink":"https://blog.rexhang.com/categories/%E5%89%8D%E7%AB%AF/"},{"name":"开发工具","slug":"前端/开发工具","permalink":"https://blog.rexhang.com/categories/%E5%89%8D%E7%AB%AF/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"},{"name":"node","slug":"前端/开发工具/node","permalink":"https://blog.rexhang.com/categories/%E5%89%8D%E7%AB%AF/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/node/"}],"tags":[{"name":"node","slug":"node","permalink":"https://blog.rexhang.com/tags/node/"},{"name":"开发工具","slug":"开发工具","permalink":"https://blog.rexhang.com/tags/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"},{"name":"devtools","slug":"devtools","permalink":"https://blog.rexhang.com/tags/devtools/"}]},{"title":"使用mask实现视频弹幕人物遮罩过滤，就是牛逼","slug":"使用mask实现视频弹幕人物遮罩过滤，就是牛逼","date":"2022-09-30T08:17:28.000Z","updated":"2022-10-25T14:41:49.323Z","comments":true,"path":"2022/09/30/articles/2/","link":"","permalink":"https://blog.rexhang.com/2022/09/30/articles/2/","excerpt":"","text":"经常看一些LOL比赛直播的小伙伴，肯定都知道，在一些弹幕网站（Bilibili、虎牙）中，当人物与弹幕出现在一起的时候，弹幕会“巧妙”的躲到人物的下面，看着非常的智能。 简单的一个截图例子： 其实，这里是运用了 CSS 中的 mask 属性实现的。 mask 简单用法介绍 这里只简单介绍下 mask 的基本用法： 最基本，使用 mask 的方式是借助图片，类似这样： 12345&#123; /* Image values */ mask: url(mask.png); /* 使用位图来做遮罩 */ mask: url(masks.svg#star); /* 使用 SVG 图形中的形状来做遮罩 */&#125; 当然，使用图片的方式后文会再讲。借助图片的方式其实比较繁琐，因为我们首先还得准备相应的图片素材，除了图片，mask 还可以接受一个类似 background 的参数，也就是渐变。 类似如下使用方法： 123&#123; mask: linear-gradient(#000, transparent) /* 使用渐变来做遮罩 */&#125; 那该具体怎么使用呢？一个非常简单的例子，上述我们创造了一个从黑色到透明渐变色，我们将它运用到实际中，代码类似这样： 下面这样一张图片，叠加上一个从透明到黑色的渐变， 1234&#123; background: url(image.png) ; mask: linear-gradient(90deg, transparent, #fff);&#125; 应用了 mask 之后，就会变成这样： 这个 DEMO，可以先简单了解到 mask 的基本用法。 这里得到了使用 mask 最重要结论：添加了 mask 属性的元素，其内容会与 mask 表示的渐变的 transparent 的重叠部分，并且重叠部分将会变得透明。 值得注意的是，上面的渐变使用的是 linear-gradient(90deg, transparent, #fff)，这里的 #fff 纯色部分其实换成任意颜色都可以，不影响效果。 使用 mask 实现人物遮罩过滤 了解了 mask 的用法后，接下来，我们运用 mask，简单实现视频弹幕中，弹幕碰到人物，自动被隐藏过滤的例子。 首先，我简单的模拟了一个召唤师峡谷，以及一些基本的弹幕： 方便示意，这里使用了一张静态图，表示了召唤师峡谷的地图，并非真的视频，而弹幕则是一条一条的 &lt;p&gt; 元素，和实际情况一致。伪代码大概是这样： 123456789&lt;!-- 地图 --&gt;&lt;div class=&quot;g-map&quot;&gt;&lt;/div&gt;&lt;!-- 包裹所有弹幕的容器 --&gt;&lt;div class=&quot;g-barrage-container&quot;&gt; &lt;!-- 所有弹幕 --&gt; &lt;div class=&quot;g-barrage&quot;&gt;6666&lt;/div&gt; ... &lt;div class=&quot;g-barrage&quot;&gt;6666&lt;/div&gt;&lt;/div&gt; 为了模拟实际情况，我们再用一个 div 添加一个实际的人物，如果不做任何处理，其实就是我们看视频打开弹幕的感受，人物被视频所遮挡： 注意，这里我添加了一个人物亚索，并且用 animation 模拟了简单的运动，在运动的过程中，人物是被弹幕给遮挡住的。 接下来，就可以请出 mask 了。 我们利用 mask 制作一个 radial-gradient ，使得人物附近为 transparent，并且根据人物运动的 animation，给 mask 的 mask-position 也添加上相同的 animation 即可。最终可以得到这样的效果： 1234567891011.g-barrage-container &#123; position: absolute; mask: radial-gradient(circle at 100px 100px, transparent 60px, #fff 80px, #fff 100%); animation: mask 10s infinite alternate;&#125;@keyframes mask &#123; 100% &#123; mask-position: 85vw 0; &#125;&#125; 实际上就是给放置弹幕的容器，添加一个 mask 属性，把人物所在的位置标识出来，并且根据人物的运动不断的去变换这个 mask 即可。我们把 mask 换成 background，原理一看就懂。 把 mask 替换成 background 示意图： background 透明的地方，即 mask 中为 transparent 的部分，实际就是弹幕会被隐藏遮罩的部分，而其他白色部分，弹幕不会被隐藏，正是完美的利用了 mask 的特性。 其实这项技术和视频本身是无关的，我们只需要根据视频计算需要屏蔽掉弹幕的位置，得到相应的 mask 参数即可。如果去掉背景和运动的人物，只保留弹幕和 mask，是这样的： 需要明确的是，使用 mask，不是将弹幕部分给遮挡住，而是利用 mask，指定弹幕容器之下，哪些部分正常展示，哪些部分透明隐藏。 实际生产环境中的运用 当然，上面我们简单的还原了利用 mask 实现弹幕遮罩过滤的效果。但是实际情况比上述的场景复杂的多，因为人物英雄的位置是不确定的，每一刻都在变化。所以在实际生产环境中，mask 图片的参数，其实是由后端实时对视频进行处理计算出来的，然后传给前端，前端再进行渲染。 对于运用了这项技术的直播网站，我们可以审查元素，看到包裹弹幕的容器的 mask 属性，每时每刻都在发生变化： 返回回来的其实是一个 SVG 图片，大概长这个样子： 这样，根据视频人物的实时位置变化，不断计算新的 mask，再实时作用于弹幕容器之上，实现遮罩过滤。","categories":[{"name":"大前端","slug":"大前端","permalink":"https://blog.rexhang.com/categories/%E5%A4%A7%E5%89%8D%E7%AB%AF/"},{"name":"css3","slug":"大前端/css3","permalink":"https://blog.rexhang.com/categories/%E5%A4%A7%E5%89%8D%E7%AB%AF/css3/"}],"tags":[{"name":"css3","slug":"css3","permalink":"https://blog.rexhang.com/tags/css3/"},{"name":"mask","slug":"mask","permalink":"https://blog.rexhang.com/tags/mask/"},{"name":"遮罩","slug":"遮罩","permalink":"https://blog.rexhang.com/tags/%E9%81%AE%E7%BD%A9/"}]},{"title":"CocosCreator实现不规则区域点击","slug":"CocosCreator实现不规则区域点击","date":"2022-09-30T07:36:22.000Z","updated":"2022-10-25T14:41:49.321Z","comments":true,"path":"2022/09/30/articles/1/","link":"","permalink":"https://blog.rexhang.com/2022/09/30/articles/1/","excerpt":"","text":"一、问题背景在CocosCreator中，点击图片透明区域依然触发节点的点击事件。但在web开发中，可以使用Inkscape、SvgPathEditor等矢量图编辑器转为SVG，或者直接从figma中导出SVG，然后监听不规则图形事件。 以地图边界高亮为例：html 类似地图的不规则图形事件处理 123svg &#123; height: 50vw; &#125;path &#123; fill: #d3d3d3; transition: .6s fill; opacity: 0.6;&#125;path:hover &#123; fill: #eee;opacity: 0.6; &#125; 但CocosCreator中Sprite目前支持的格式为jpg和png，未直接支持SVG。 二、方案调研图像模板(image_stencil) mask 如何控制只让图像遮罩的可视区域响应点击 图像模板可以根据设置的透明度阈值，只有当模板像素的 alpha 值大于该阈值时，才会绘制内容。 但是该方式点击透明区域，依然会触发该节点的事件。 通过查看2.4.7版本 CCMask.js 的源码 ，可以看到在碰撞检测中，图像模板类型的mask的命中方式与矩形保持一致，只有椭圆才是单独检测，故该方式并不能解决问题。 123456789101112131415161718192021222324252627282930_hitTest (cameraPt) &#123; let node = this.node; let size = node.getContentSize(), w = size.width, h = size.height, testPt = _vec2_temp; node._updateWorldMatrix(); // If scale is 0, it can&#x27;t be hit. if (!Mat4.invert(_mat4_temp, node._worldMatrix)) &#123; return false; &#125; Vec2.transformMat4(testPt, cameraPt, _mat4_temp); testPt.x += node._anchorPoint.x * w; testPt.y += node._anchorPoint.y * h; let result = false; if (this.type === MaskType.RECT || this.type === MaskType.IMAGE_STENCIL) &#123; result = testPt.x &gt;= 0 &amp;&amp; testPt.y &gt;= 0 &amp;&amp; testPt.x &lt;= w &amp;&amp; testPt.y &lt;= h; &#125; else if (this.type === MaskType.ELLIPSE) &#123; let rx = w / 2, ry = h / 2; let px = testPt.x - 0.5 * w, py = testPt.y - 0.5 * h; result = px * px / (rx * rx) + py * py / (ry * ry) &lt; 1; &#125; if (this.inverted) &#123; result = !result; &#125; return result;&#125; 多边形mask 1.Creator | 编辑器中可操作顶点的多边形遮罩2.【组件分享】使用Mask+Graphic魔改的多边形遮罩组件3.[ Mask + PolygonCollider 简易自定义多边形遮罩制作 ] 沿着mask的思路，在论坛上找到了多边形mask的实现方式。大致都是在CCMask源码的基础上，增加多边形的节点添加和碰撞检测，其中一位作者实现的组件非常吸睛，GitHub上共有400余Star，目前cocos商店已有该组件。感兴趣可阅读源码。 效果如下： 比较有意思是其碰撞检测（点是否在多边形内），采用射线法判断。 定义：从目标点出发引一条射线，看这条射线和多边形所有边的交点数目。如果有奇数个交点，则说明在内部，如果有偶数个交点，则说明在外部。 具体步骤：将测试点的Y坐标与多边形的每一个点进行比较，会得到一个测试点所在的行与多边形边的交点的列表。在下图的这个例子中有8条边与测试点所在的行相交，而有6条边没有相交。如果测试点的两边点的个数都是奇数个则该测试点在多边形内，否则在多边形外。在这个例子中测试点的左边有5个交点，右边有三个交点，它们都是奇数，所以点在多边形内。 算法实现： 12345678910111213141516171819202122232425isInPolygon(checkPoint: cc.Vec2, polygonPoints: cc.Vec2[]) &#123; let counter = 0, i: number, xinters: number; let p1: cc.Vec2, p2: cc.Vec2; let pointCount = polygonPoints.length; p1 = polygonPoints[0]; for (i = 1; i &lt;= pointCount; i++) &#123; p2 = polygonPoints[i % pointCount]; if ( checkPoint.x &gt; Math.min(p1.x, p2.x) &amp;&amp; checkPoint.x &lt;= Math.max(p1.x, p2.x) ) &#123; if (checkPoint.y &lt;= Math.max(p1.y, p2.y)) &#123; if (p1.x != p2.x) &#123; xinters = (checkPoint.x - p1.x) * (p2.y - p1.y) / (p2.x - p1.x) + p1.y; if (p1.y == p2.y || checkPoint.y &lt;= xinters) &#123; counter++; &#125; &#125; &#125; &#125; p1 = p2; &#125; return (counter &amp; 1) !== 0;&#125; 多边形mesh 多边形裁剪图片(非mask,使用mesh)，新增 gizmo 支持https://github.com/baiyuwubing/cocos-creator-examples/tree/master/meshTexture 2年前开发，已停止维护，使用不佳，节点关联顺序容易紊乱。根据作者的描述，可以解决mask过多带来性能影响。 像素点计算 creator 2.4.8中获取像素信息 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768const getPixelData = (node: cc.Node, x: number, y: number) =&gt; &#123; const pixelsData = getPixelsData(node); const startIndex = node.width * 4 * Math.floor(node.height - y) + 4 * Math.floor(x); const pixelData = pixelsData.slice(startIndex, startIndex + 4); return pixelData;&#125;;const isPixelTransparent = (node: cc.Node, x: number, y: number) =&gt; &#123; const pixelData = getPixelData(node, x, y); return pixelData[3] === 0;&#125;;const getPixelsData = (node: cc.Node) =&gt; &#123; if (!cc.isValid(node)) &#123; return null; &#125; // 节点宽度 const width = Math.floor(node.width); const height = Math.floor(node.height); // 创建临时摄像机用于渲染目标节点 const cameraNode = new cc.Node(); cameraNode.parent = node; const camera = cameraNode.addComponent(cc.Camera); // eslint-disable-next-line no-bitwise camera.clearFlags |= cc.Camera.ClearFlags.COLOR; camera.backgroundColor = cc.color(0, 0, 0, 0); camera.zoomRatio = cc.winSize.height / height; // 将节点渲染到 RenderTexture中 const renderTexture = new cc.RenderTexture(); renderTexture.initWithSize( width, height, cc.RenderTexture.DepthStencilFormat.RB_FMT_S8 ); camera.targetTexture = renderTexture; camera.render(node); const pixelData = renderTexture.readPixels(); return pixelData;&#125;;/** 点击事件是否合法，非透明像素 */ isValidTouch(e: cc.Event.EventTouch) &#123; const touchLocation = e.touch.getLocation(); /** 相对节点左下角的相对坐标，即图片内的坐标 */ const locationInNode = this.node.convertToNodeSpaceAR(touchLocation); /** 非本节点内 透传 */ if (!this.node.getBoundingBoxToWorld().contains(touchLocation)) &#123; this.setSwallowTouches(false); return false; &#125; const &#123; anchorX, anchorY, width, height &#125; = this.node; const x = locationInNode.x + anchorX * width; const y = -(locationInNode.y - anchorY * height); const isValid = !isPixelTransparent(this.node, x, y); this.setSwallowTouches(isValid); return isValid; &#125; /** 设置是否阻止点击事件透传 */ setSwallowTouches(bool: boolean) &#123; (this.node as any)._touchListener.setSwallowTouches(bool); &#125; 方案对比 方案名称 优点 缺点 图像模板mask - 适合图片快速裁剪渲染 - 不满足要求 多边形mask - 适用于多边形定制化裁剪 - 参考文章 [@]Mask组件多边形方案性影响手机Web性能。多边形mask使用过多，低端机性能下降严重（碰撞检测占主要原因） - 手动描边 多边形mesh - 根据作者描述，比mask性能更优 - 手动描边 像素点计算 - 颗粒度精细，能精确到像素点 - 无需特殊处理图片 - 图片过大时，可能带来性能问题 可能的最佳实践？在论坛中看到有个大佬在尝试svg拓展 Creator + SVG 解析渲染扩展组件 ，已上架cocos商店【价值80¥】","categories":[{"name":"大前端","slug":"大前端","permalink":"https://blog.rexhang.com/categories/%E5%A4%A7%E5%89%8D%E7%AB%AF/"},{"name":"游戏引擎","slug":"大前端/游戏引擎","permalink":"https://blog.rexhang.com/categories/%E5%A4%A7%E5%89%8D%E7%AB%AF/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"}],"tags":[{"name":"cocos2d","slug":"cocos2d","permalink":"https://blog.rexhang.com/tags/cocos2d/"},{"name":"CocosCreator","slug":"CocosCreator","permalink":"https://blog.rexhang.com/tags/CocosCreator/"},{"name":"游戏引擎","slug":"游戏引擎","permalink":"https://blog.rexhang.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"}]},{"title":"JS中非常实用的『一行代码』","slug":"JS中非常实用的『一行代码』","date":"2022-08-04T04:03:28.000Z","updated":"2023-07-21T07:17:58.428Z","comments":true,"path":"2022/08/04/articles/1/","link":"","permalink":"https://blog.rexhang.com/2022/08/04/articles/1/","excerpt":"","text":"导读: 最近在国外技术社区看到了一些关于 一行代码 的文章📄，感觉很有意思，就整理了下来并且自己额外补充了一部分分享给大家🤜，希望对各位读者们有所帮助💕。 最近一次更新时间 2022-08-21 12:00:15 这些方法使用到了一些API，简化了操作，但是有些方法写一行属实不太优雅，所以这里主要还是学习API的使用小技巧。 一、日期处理 检查日期是否有效该方法用于检测给出的日期是否有效 123const isDateValid = (...val) =&gt; !Number.isNaN( new Date(...val).valueOf() );// how to useisDateValid(&quot;December 17, 1995 03:24:00&quot;); // =&gt; true 计算两个日期之间的间隔该方法用于计算两个日期之间的间隔时间(day) 123const dayDif = (date1, date2) =&gt; Math.ceil( Math.abs( date1.getTime() - date2.getTime() ) / 86400000);// how to usedayDif(new Date(&quot;2022-08-01&quot;), new Date(&quot;2022-08-04&quot;)); // =&gt; 3 查找日期位于一年中的第几天该方法用于检测给出的日期位于今年的第几天 1234const dayOfYear = date =&gt; Math.floor( ( date - new Date(date.getFullYear(), 0, 0) ) / 1000 / 60 / 60 / 24 )// how to usedayOfYear(new Date(&quot;2022-08-01&quot;)); // =&gt; 213dayOfYear(new Date(&quot;2022-01-01&quot;)); // =&gt; 1 时间格式化该方法用于转换时间 12345const timeFromDate = date =&gt; date.toTimeString().slice(0, 8);// how to usetimeFromDate(new Date(2022, 08, 04, 12, 30, 0)); // =&gt; &#x27;12:30:00&#x27;timeFromDate(new Date(2022, 08, 04, 12, 30, 60)); // =&gt; &#x27;12:31:00&#x27;timeFromDate(new Date()); // =&gt; 此刻的时间 二、字符串处理 字符串首字母大写该方法用于将英文字符串的首字母大写处理 123const capitalize = str =&gt; str.charAt(0).toUpperCase() + str.slice(1);// how to usecapitalize(&quot;hello world&quot;); // =&gt; Hello world 翻转字符串该方法用于将一个字符串进行翻转操作并返回翻转后的内容 123const reverse = str =&gt; str.split(&#x27;&#x27;).reverse().join(&#x27;&#x27;);// how to usereverse(&quot;hello world&quot;); // =&gt; dlrow olleh 随机字符串该方法用于生成一个随机的字符串并返回 123const randomString = () =&gt; Math.random().toString(36).slice(2);// how to userandomString(); // =&gt; anyString 去除字符串中的HTML该方法用于去除字符串中的HTML元素 123const stripHtml = html =&gt; (new DOMParser().parseFromString(html, &#x27;text/html&#x27;)).body.textContent || &#x27;&#x27;;// how to usestripHtml(&quot;&lt;div&gt;Beware of the missing closing tag&lt;/div&gt;hello world&lt;i&gt;!&lt;i&gt;&quot;); // =&gt; &#x27;Beware of the missing closing taghello world!&#x27; 获取URL的search参数并json化该方法用于获取当前访问的URL中的search内容并解析成JSON键值对形式 123const urlParams = search =&gt; Object.fromEntries(new URLSearchParams(search));// how to useurlParams(location.search); // =&gt; &#123; id: &#x27;1&#x27;, name: &#x27;rexhang&#x27; &#125; 去除数字之外的所有字符该方法用于去除数字之外的所有字符 1234const toNumber = str =&gt; Number(str.replace(/\\D/g, &#x27;&#x27;));// how to useconst str = &#x27;hello 123 is god 456&#x27;;toNumber(str); // =&gt; 123456 空值(null | undefined)合并运算符该方法用于更简短的定义空值情况下的时候, null 或者 undefined 会认定为判断范围， 其余认为正常赋值 1234567891011121314const aa = isA ?? false;const bb = isB ?? &#x27;hello&#x27;;const cc = isC ?? &#x27;ok&#x27;;const dd = isD ?? &#x27;done&#x27;;// how to useconst isA = null;const isB = &#x27;&#x27;;const isC = undefined;const isD = false;const aa = isA ?? &#x27;...&#x27;;const bb = isB ?? &#x27;hello&#x27;;const cc = isC ?? &#x27;ok&#x27;;const dd = isD ?? &#x27;done&#x27;;console.log(aa, bb, cc, dd); 二、数组处理 从数组中移除重复项该方法用于从数组中移除重复项 123const removeDuplicates = arr =&gt; [...new Set(arr)];// how to useremoveDuplicates([1, 1, 3, 4, 1, 5]); // =&gt; [1, 3, 4, 5] 打乱数组顺序该方法用于打乱数组顺序，随机取random后的数组 1234const randomArr = arr =&gt; arr.sort(() =&gt; 0.5 - Math.random());// how to useconst arr = [&#x27;🙂&#x27;, &#x27;66&#x27;, true, 11, &#123;name: &#x27;rexhang&#x27;&#125;];console.log(randomArr(arr)); // random arr, eg: [&#x27;66&#x27;, 11, true, &#123;name: &#x27;rexhang&#x27;&#125;, &#x27;🙂&#x27;]; 从数组中随机去一个值该方法用于从数组中随机去一个值 1234const takeARandomItem = arr =&gt; arr[Math.floor(Math.random() * arr.length)]// how to useconst eles = [&#x27;🙂&#x27;, &#x27;66&#x27;, true, 11, &#123;name: &#x27;rexhang&#x27;&#125;];console.log(takeARandomItem(eles)); // random item of arr, eg: &#x27;🙂&#x27;; 从数组中取出最大/小值(仅限数字|字符串数字)该方法用于从数组中取出最大/小值(仅限数字|字符串数字) 1234567const getMaxMinValue = arr =&gt; (&#123; max: Math.max(...arr), min: Math.min(...arr),&#125;)// how to useconst items = [11, 12, 11, 1, &#x27;0&#x27;];console.log(getMaxMinValue(items)); // &#123; max: 12, min: 0 &#125; 判断数组是否为空该方法用于判断数组是否为空 12345const isNotEmpty = arr =&gt; Array.isArray(arr) &amp;&amp; !!arr.length;// how to useisNotEmpty([1, 3]); // =&gt; trueisNotEmpty([]); // =&gt; trueisNotEmpty(&quot;[1, 3]&quot;); // =&gt; 非数组返回false 长期且持续更新中…","categories":[{"name":"大前端","slug":"大前端","permalink":"https://blog.rexhang.com/categories/%E5%A4%A7%E5%89%8D%E7%AB%AF/"},{"name":"效率","slug":"大前端/效率","permalink":"https://blog.rexhang.com/categories/%E5%A4%A7%E5%89%8D%E7%AB%AF/%E6%95%88%E7%8E%87/"},{"name":"前端开发","slug":"大前端/效率/前端开发","permalink":"https://blog.rexhang.com/categories/%E5%A4%A7%E5%89%8D%E7%AB%AF/%E6%95%88%E7%8E%87/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://blog.rexhang.com/tags/javascript/"},{"name":"javascript数组","slug":"javascript数组","permalink":"https://blog.rexhang.com/tags/javascript%E6%95%B0%E7%BB%84/"},{"name":"javascript字符串","slug":"javascript字符串","permalink":"https://blog.rexhang.com/tags/javascript%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"js小tips","slug":"js小tips","permalink":"https://blog.rexhang.com/tags/js%E5%B0%8Ftips/"},{"name":"js技巧","slug":"js技巧","permalink":"https://blog.rexhang.com/tags/js%E6%8A%80%E5%B7%A7/"}]},{"title":"一套面向常规统计图表，以数据驱动的高交互可视化图形语法 - G2","slug":"G2","date":"2022-08-04T01:27:08.000Z","updated":"2022-10-25T14:41:49.322Z","comments":true,"path":"2022/08/04/articles/2/","link":"","permalink":"https://blog.rexhang.com/2022/08/04/articles/2/","excerpt":"","text":"G2 一套面向常规统计图表，以数据驱动的高交互可视化图形语法。 网站 • 教程文档 • 博客 • G2Plot G2 是一套基于图形语法理论的可视化底层引擎，以数据驱动，提供图形语法与交互语法，具有高度的易用性和扩展性。使用 G2，你可以无需关注图表各种繁琐的实现细节，一条语句即可使用 Canvas 或 SVG 构建出各种各样的可交互的统计图表。 📺 线上示例 ✨ 特性 💯 完善的图形语法：数据到图形的映射，能够绘制出所有的图表。 🤩 全新的交互语法：通过触发和反馈机制可以组合出各种交互行为，对数据进行探索。 🦍 强大的 View 模块：可支持开发个性化的数据多维分析图形。 👬 双引擎渲染：Canvas 或 SVG 任意切换。 💄 可视化组件体系：面向交互、体验优雅。 🛡 全面拥抱 TypeScript：提供完整的类型定义文件。 📦 安装1$ npm install @antv/g2 🔨 快速上手 在绘图前我们需要为 G2 准备一个 DOM 容器： 1&lt;div id=&quot;c1&quot;&gt;&lt;/div&gt; 12345678910111213141516171819202122232425import &#123; Chart &#125; from &#x27;@antv/g2&#x27;;const data = [ &#123; genre: &#x27;Sports&#x27;, sold: 275 &#125;, &#123; genre: &#x27;Strategy&#x27;, sold: 115 &#125;, &#123; genre: &#x27;Action&#x27;, sold: 120 &#125;, &#123; genre: &#x27;Shooter&#x27;, sold: 350 &#125;, &#123; genre: &#x27;Other&#x27;, sold: 150 &#125;,];// Step 1: 创建 Chart 对象const chart = new Chart(&#123; container: &#x27;c1&#x27;, // 指定图表容器 ID width: 600, // 指定图表宽度 height: 300, // 指定图表高度&#125;);// Step 2: 载入数据源chart.data(data);// Step 3: 创建图形语法，绘制柱状图chart.interval().position(&#x27;genre*sold&#x27;);// Step 4: 渲染图表chart.render(); ⌨️ 本地开发1234567891011121314# 安装依赖$ npm install# 运行测试用例$ npm run test# 打开 electron 运行测试用例，监听文件变化构建$ npm run test-live# 运行 CI$ npm run ci# 运行网站$ npm start 🏷️ 版本 v3.5.x: https://github.com/antvis/G2/tree/v3.5.x v4.0.x: https://github.com/antvis/G2/tree/v4.0.x 你也可以在业务中使用基于 G2 封装的常规统计图表 G2Plot ，可以使用配置的方式快速生成一个通用图表，降低开发者的使用成本。","categories":[{"name":"大前端","slug":"大前端","permalink":"https://blog.rexhang.com/categories/%E5%A4%A7%E5%89%8D%E7%AB%AF/"},{"name":"图表","slug":"大前端/图表","permalink":"https://blog.rexhang.com/categories/%E5%A4%A7%E5%89%8D%E7%AB%AF/%E5%9B%BE%E8%A1%A8/"},{"name":"G2","slug":"大前端/图表/G2","permalink":"https://blog.rexhang.com/categories/%E5%A4%A7%E5%89%8D%E7%AB%AF/%E5%9B%BE%E8%A1%A8/G2/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://blog.rexhang.com/tags/javascript/"}]},{"title":"React代码整洁优化实践","slug":"React代码整洁优化实践","date":"2022-08-02T14:16:48.000Z","updated":"2022-10-25T14:41:49.322Z","comments":true,"path":"2022/08/02/articles/1/","link":"","permalink":"https://blog.rexhang.com/2022/08/02/articles/1/","excerpt":"","text":"整洁的代码不仅仅是正常运行的代码，更是要求易于阅读、简单易懂、组织整齐。在本文中，我会们将示例几种代码整洁案例。在阅读这些建议时，要记住这些只是建议！ 如果你不同意它们中的任何一个，那也完全没关系。以下这些实践，个人觉得对我自己编写 React 代码很有帮助。1. 仅对一个条件进行渲染 如果需要在条件为true时渲染某些内容，而在条件为false时不渲染任何内容，不推荐使用三元表达式，改用与运算符&amp;&amp;，它可以方便地条件渲染一个元素。 优化前: 1234567891011import React from &quot;react&quot;;export const TopNav = (props: &#123; showSearch?: boolean &#125;) =&gt; &#123; const &#123; showSearch = false &#125; = props; return ( &lt;div className=&quot;doc-head&quot;&gt; &#123;/* 三元表达式进行条件渲染 */&#125; &#123;showSearch ? &lt;SearchBox placeholder=&quot;输入关键词搜索&quot; onSearch=&#123;(keyword) =&gt; window.location.assign(`/privatecloud/search?q=$&#123;keyword&#125;`)&#125; style=&#123;&#123; marginRight: 100 &#125;&#125; /&gt; : null&#125; &lt;/div&gt; );&#125;; 优化后: 1234567891011import React from &quot;react&quot;;export const TopNav = (props: &#123; showSearch?: boolean &#125;) =&gt; &#123; const &#123; showSearch = false &#125; = props; return ( &lt;div className=&quot;doc-head&quot;&gt; &#123;/* 与运算符&amp;&amp;进行条件渲染 */&#125; &#123;showSearch &amp;&amp; &lt;SearchBox placeholder=&quot;输入关键词搜索&quot; onSearch=&#123;(keyword) =&gt; window.location.assign(`/privatecloud/search?q=$&#123;keyword&#125;`)&#125; style=&#123;&#123; marginRight: 100 &#125;&#125; /&gt;&#125; &lt;/div&gt; );&#125;; 2. 每一个条件都可能进行渲染 如果需要在条件为 true 时渲染某些内容，而在条件为 false 时渲染其他内容。推荐使用三元表达式！ 优化前: 123&#123;/* 条件 True 和 False 都要渲染内容 */&#125;&#123; good &amp;&amp; &lt;p&gt;Good!&lt;/p&gt; &#125;&#123; !good &amp;&amp; &lt;p&gt;&lt;b&gt;Not Good!&lt;b&gt;&lt;/p&gt; &#125; 优化后: 123456789101112&#123; /* 三元表达式 */&#125;&#123; good ? ( &lt;p&gt;Good!&lt;/p&gt; ) : ( &lt;p&gt; &lt;b&gt;Not Good!&lt;/b&gt; &lt;/p&gt; );&#125; 3. 组件 Boolean props 传参 组件接收参数的属性值为布尔类型, 并且传入 true 值时，可以省略填写值，并不会影响组件内取到 true 值 优化前: 12&lt;Hello disabled=&#123;true&#125; /&gt;&lt;Hello disabled=&#123;false&#125; /&gt; 优化后: 12&lt;Hello disabled /&gt;&lt;Hello disabled=&#123;false&#125; /&gt; 4. 组件 String props 传参 组件 Props 值为 String, 推荐使用双引号包裹，不使用花括号或反引号。 优化前: 123&lt;Hello personName=&#123;&quot;Jim&quot;&#125; /&gt;&lt;Hello personName=&#123;&#x27;Tom&#x27;&#125; /&gt;&lt;Hello personName=&#123;`Ken`&#125; /&gt; 优化后: 123&lt;Hello personName=&quot;Jim&quot; /&gt;&lt;Hello personName=&quot;Tom&quot; /&gt;&lt;Hello personName=&quot;Ken&quot; /&gt; 5. Event handler functions 如果一个事件函数只接受一个参数，不需要传入匿名函数：onChange={ e =&gt; handleChange(e) }，推荐这种写法(直接等于函数)： onChange={ handleChange } 。 优化前: 1234const handleChange = (e) =&gt; &#123; console.info(e.target.value);&#125;;&lt;input id=&quot;name&quot; value=&#123;inputValue&#125; onChange=&#123;(e) =&gt; handleChange(e)&#125; /&gt;; 优化后: 1234567const handleChange = (e) =&gt; &#123; console.info(e.target.value);&#125;;&#123; /* 事件只有一个参数，不需要匿名函数*/&#125;&lt;input id=&quot;name&quot; value=&#123;inputValue&#125; onChange=&#123;handleChange&#125; /&gt;; 6. components as props 将组件作为参数传递给另一个组件时，如果该组件不接受任何参数，则无需将该传递的组件包装在函数中。 优化前: 12&lt;Hello ClockComponent=&#123;() =&gt; &lt;Clock timestamp=&#123;new Date().getTime()&#125; /&gt;&#125; /&gt;&lt;Hello ClockComponent=&#123;() =&gt; &lt;Clock /&gt;&#125; /&gt; 优化后: 12&lt;Hello ClockComponent=&#123;() =&gt; &lt;Clock timestamp=&#123;new Date().getTime()&#125; /&gt;&#125; /&gt;&lt;Hello ClockComponent=&#123;Clock&#125; /&gt; 7. 设置 state 依赖先前的 state 如果新 state 依赖于先前 state，则始终将 state 设置为先前 state 的函数。可以批处理 React 状态更新。 优化前: 1234567891011121314151617181920212223import React, &#123; useState &#125; from &quot;react&quot;;export const Hello = () =&gt; &#123; const [cout, setCount] = useState &lt; number &gt; 0; // 依赖先前/上一个的state值 (异步调用) const handleClick = (e) =&gt; setCount(cout + 1); // 期望执行2次 首次执行理应 cout = 2 const handleClickRunDouble = (e) =&gt; &#123; // 执行第二个handleClick执行的时候第一个count设置未完成(异步的)，所以还是 count = 0 = 0 + 1 = 1 因此 首次的点击得到的值 = 1 而并非2, 如果需要实现2 那么就得利用setState的批处理方式 handleClick(e); handleClick(e); &#125;; return ( &lt;div&gt; &lt;button onclick=&#123;handleClick&#125;&gt;click here&lt;/button&gt; &lt;span&gt;&#123;count&#125;&lt;/span&gt; &lt;button onclick=&#123;handleClickRunDouble&#125;&gt;click here &amp; lunch 2 times&lt;/button&gt; &lt;/div&gt; );&#125;; 优化后: 123456789101112131415161718192021222324import React, &#123; useState &#125; from &quot;react&quot;;export const Hello = () =&gt; &#123; const [cout, setCount] = useState &lt; number &gt; 0; &#123; /* 将set调用设置为批处理模式 使用set方法提供的callback内的数值 */ &#125; const handleClick = (e) =&gt; setCount((c) =&gt; c + 1); // 首次调用后会输出最新的值 count = 2; const handleClickRunDouble = (e) =&gt; &#123; handleClick(e); handleClick(e); &#125;; return ( &lt;div&gt; &lt;button onclick=&#123;handleClick&#125;&gt;click here&lt;/button&gt; &lt;span&gt;&#123;count&#125;&lt;/span&gt; &lt;button onclick=&#123;handleClickRunDouble&#125;&gt;click here &amp; lunch 2 times&lt;/button&gt; &lt;/div&gt; );&#125;; 以上 7 个就是我推荐和总结的几个React代码整洁优化实践 。 最后，祝大家开发愉快！","categories":[{"name":"大前端","slug":"大前端","permalink":"https://blog.rexhang.com/categories/%E5%A4%A7%E5%89%8D%E7%AB%AF/"},{"name":"面试经","slug":"大前端/面试经","permalink":"https://blog.rexhang.com/categories/%E5%A4%A7%E5%89%8D%E7%AB%AF/%E9%9D%A2%E8%AF%95%E7%BB%8F/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://blog.rexhang.com/tags/javascript/"},{"name":"前端框架","slug":"前端框架","permalink":"https://blog.rexhang.com/tags/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/"},{"name":"React","slug":"React","permalink":"https://blog.rexhang.com/tags/React/"}]},{"title":"数组的一些常用方法及使用区别","slug":"数组的一些常用方法及使用区别","date":"2021-05-13T16:22:22.000Z","updated":"2022-10-25T14:41:49.325Z","comments":true,"path":"2021/05/14/articles/1/","link":"","permalink":"https://blog.rexhang.com/2021/05/14/articles/1/","excerpt":"","text":"一、前言push pop unshift shift splice slice split join 方法及使用区别 二、示例1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162// push pop unshift shift splice slice split joinconst arr = [1, 2, 3, 4];// push、unshift向数组的 尾部/头部 添加若干元素，并返回 数组的 新长度const a = arr.push(&#x27;X&#x27;, &#x27;Y&#x27;, &#x27;Z&#x27;); // -&gt; new lengthconst b = arr.unshift(&#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;); // -&gt; new lengthconsole.log(a);console.log(b);console.log(arr);// pop、shift向数组的 尾部/头部 删除一个元素 并返回 数组中 被删除的元素const c = arr.pop(); // -&gt; last itemconst d = arr.shift(); // -&gt; first itemconsole.log(c);console.log(d);const e = arr.push();const f = [].pop();const g = [].shift();console.log(e);console.log(f);console.log(g);// splice 向/从数组中添加/删除项目，然后返回被删除的项目集合[?1, ?2]。 -1开始反方向删除(末尾第一个) 即便是负数 也都是从左到右删除单位const h = arr.splice(-2, 2, &#x27;rex&#x27;, &#x27;hang&#x27;, &#x27;gu&#x27;);console.log(h);// slice 只对数组范围做截取 并返回 截取的内容const i = arr.slice(1, -2); // 区间 -&gt; (?] 不包含末尾console.log(i);// split 用于 把一个有标记的字符串 分割成 标准数组const j = &#x27;a|b|c&#x27;.split(&#x27;|&#x27;);console.log(j);// join 用于 把一个标准数组 变成 固定符号分隔的 字符串const k = [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;].join(&#x27;|&#x27;);console.log(k);console.log(arr); 控制台输出内容如图所示: 看完上述例子后，我想大家都应该大致明白了这些方法的使用区别。","categories":[{"name":"大前端","slug":"大前端","permalink":"https://blog.rexhang.com/categories/%E5%A4%A7%E5%89%8D%E7%AB%AF/"},{"name":"面试经","slug":"大前端/面试经","permalink":"https://blog.rexhang.com/categories/%E5%A4%A7%E5%89%8D%E7%AB%AF/%E9%9D%A2%E8%AF%95%E7%BB%8F/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://blog.rexhang.com/tags/javascript/"},{"name":"javascript数组","slug":"javascript数组","permalink":"https://blog.rexhang.com/tags/javascript%E6%95%B0%E7%BB%84/"}]},{"title":"探讨下前端开发过程中在苹果系统下的一些兼容性小坑以及解决方案","slug":"探讨下前端开发过程中在苹果系统下的一些兼容性小坑以及解决方案","date":"2021-01-12T13:20:30.000Z","updated":"2022-10-25T14:41:49.324Z","comments":true,"path":"2021/01/12/articles/1/","link":"","permalink":"https://blog.rexhang.com/2021/01/12/articles/1/","excerpt":"","text":"导读: 本文会长期更新，目前仅写出已收集并且经过验证的案例分享🙉 大家在做前端开发过程中势必会和H5打交道&lt;这里指的H5仅表示在苹果系统下运行的H5&gt;，在原本不应该出现的异常行为经常会搞得稀里糊涂，遂去各类搜索引擎搜索结局方案，本文故此摘录各类表现在苹果环境下的开发“异常行为”，并且给出大概可行的兼容方案来帮助大家单项搜集的烦恼 可能存在兼容性问题搜集 1.Date.parse() parse() 方法可解析一个日期时间字符串，并返回 1970/1/1 午夜距离该日期时间的毫秒数。W3C参考文档 代码部分: 1Date.parse(&quot;2020-02-02 00:00:00&quot;) 可能会在苹果环境中出现NaN的返回结果 解决方案是: 不使用具体时间 =&gt; Date.parse(&quot;2020-02-02&quot;) 使用“**/”代替“-**”来分割日期 =&gt; Date.parse(&quot;2020/02/02 00:00:00&quot;) 替换字符串为第二种方案 =&gt; Date.parse(&quot;2020-02-02 00:00:00&quot;.replace(/-/g, &#39;/&#39;)) 2.window.open() open() 方法用于打开一个新的浏览器窗口或查找一个已命名的窗口。W3C参考文档 代码部分: 1window.open(&#x27;//rexhang.com&#x27;); 可能会在苹果环境中出现被阻止打开的情况，这是由于苹果安全策略进行了拦截 解决方案是: 使用window.location.href = &#39;//rexhang.com&#39;代替 使用window.location.replace(&#39;//rexhang.com&#39;)代替 3.待博主更新…结语 这样的坑还有许多许多不仅仅是ios还有android也会存在一些兼容性问题，本文会长期更新，尽可能搜集更多的兼容案例，如有更多案例本文未提到的，希望大家踊跃提出，反馈在下方评论里，多谢大家~","categories":[{"name":"大前端","slug":"大前端","permalink":"https://blog.rexhang.com/categories/%E5%A4%A7%E5%89%8D%E7%AB%AF/"},{"name":"兼容性","slug":"大前端/兼容性","permalink":"https://blog.rexhang.com/categories/%E5%A4%A7%E5%89%8D%E7%AB%AF/%E5%85%BC%E5%AE%B9%E6%80%A7/"},{"name":"心得","slug":"大前端/兼容性/心得","permalink":"https://blog.rexhang.com/categories/%E5%A4%A7%E5%89%8D%E7%AB%AF/%E5%85%BC%E5%AE%B9%E6%80%A7/%E5%BF%83%E5%BE%97/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://blog.rexhang.com/tags/javascript/"},{"name":"前端多端开发兼容性","slug":"前端多端开发兼容性","permalink":"https://blog.rexhang.com/tags/%E5%89%8D%E7%AB%AF%E5%A4%9A%E7%AB%AF%E5%BC%80%E5%8F%91%E5%85%BC%E5%AE%B9%E6%80%A7/"},{"name":"ios","slug":"ios","permalink":"https://blog.rexhang.com/tags/ios/"},{"name":"macos","slug":"macos","permalink":"https://blog.rexhang.com/tags/macos/"},{"name":"apple","slug":"apple","permalink":"https://blog.rexhang.com/tags/apple/"},{"name":"苹果","slug":"苹果","permalink":"https://blog.rexhang.com/tags/%E8%8B%B9%E6%9E%9C/"}]},{"title":"Vue双向绑定的原理","slug":"Vue双向绑定的原理","date":"2021-01-10T07:56:57.000Z","updated":"2022-10-25T14:41:49.322Z","comments":true,"path":"2021/01/10/articles/2/","link":"","permalink":"https://blog.rexhang.com/2021/01/10/articles/2/","excerpt":"","text":"双向绑定原理及简单实现Vue是采用数据劫持结合发布者-订阅者模式的方式，通过new Proxy()来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。 Vue3.x与Vue2.x的区别仅是数据劫持的方式由Object.defineProperty更改为Proxy代理，其他代码不变Vue最核心的功能有两个，一是响应式的数据绑定系统，二是组件系统。本文仅探究双向绑定是怎样实现的。以及实现一个简化版的**Vue-lite** 一、访问器属性访问器属性是对象中的一种特殊属性，它不能直接在对象中设置，而必须通过defineProperty()方法单独定义。 123456789101112const obj = &#123;&#125;;Object.defineProperty(obj, &#x27;hello&#x27;, &#123; set: newVal =&gt; &#123; console.log(&#x27;set方法被调用了&#x27;); console.log(&#x27;newVal=&#x27;+newVal); &#125;, get: () =&gt; &#123; console.log(&#x27;get方法被调用了&#x27;); &#125;&#125;);obj.hello = &#x27;xxx&#x27;; // 会触发访问器属性中的set方法 参数是xxxobj.hello // 会触发访问器属性中的get方法 其中**get(),set()**方法就是实现双向绑定的关键 二、极简双向绑定的实现html部分: 1234567891011121314&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Vue-lite&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;input type=&quot;text&quot; id=&quot;inputs&quot; /&gt; &lt;p id=&quot;tips&quot;&gt;&lt;/p&gt; &lt;button id=&quot;btn&quot;&gt;设置新值&lt;/button&gt; &lt;script src=&quot;./js/Vue-lite.js&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; Vue-lite.js: 123456789101112131415161718192021222324const inputs = document.querySelector(&#x27;#inputs&#x27;);const tips = document.querySelector(&#x27;#tips&#x27;);const btn = document.querySelector(&#x27;#btn&#x27;);const obj = &#123;&#125;;Object.defineProperty(obj, &#x27;hello&#x27;, &#123; set: newVal =&gt; &#123; inputs.value = newVal; tips.innerHTML = newVal; &#125;, get: () =&gt; &#123; console.log(&#x27;get方法被调用了&#x27;); return &#x27;123&#x27;; // 可以对值进行修改 &#125;&#125;);obj.hello = &#x27;xxx&#x27;; // 会触发访问器属性中的set方法 参数是xxxconsole.log(obj.hello); // 会触发访问器属性中的get方法inputs.addEventListener(&#x27;keyup&#x27;, e=&gt;&#123; obj.hello = e.target.value;&#125;);btn.addEventListener(&#x27;click&#x27;, e=&gt;&#123; obj.hello = &#x27;233&#x27;; // set数据&#125;);// 实现了 model =&gt; view 以及 view =&gt; model 的双向绑定。// 以上就是 Vue2.x 实现双向绑定的基本原理。 此例实现的效果是：随文本框输入文字的变化，span 中会同步显示相同的文字内容；在js或控制台显式的修改 obj.hello 的值，视图会相应更新。这样就实现了 model =&gt; view 以及 view =&gt; model 的双向绑定，就是Vue实现双向绑定的最基本原理。 三、细节优化上述示例仅仅是为了说明原理。我们最终要实现的是： 1234567&lt;div id=&quot;app&quot;&gt; &lt;div&gt; &lt;span&gt;姓名: &lt;/span&gt; &lt;input type=&quot;text&quot; name=&quot;name&quot; v-mode=&quot;name&quot; /&gt; &lt;/div&gt; &lt;p&gt;您输入的name是: &#123;&#123;name&#125;&#125;&lt;/p&gt;&lt;/div&gt; 123456const vm = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; name: &#x27;rexhang&#x27; &#125;&#125;); 首先做下需要实现功能点: 输入框以及文本节点与 data 中的数据绑定 输入框内容变化时，data 中的数据同步变化。即 view =&gt; model 的变化 data 中的数据变化时，文本节点的内容同步变化。即 model =&gt; view 的变化 html: 1234567891011121314&lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;name&quot; v-model=&quot;name&quot; /&gt; &lt;br /&gt; &#123;&#123;name&#125;&#125;&lt;/div&gt;&lt;script src=&quot;./js/Vue-lite.js&quot;&gt;&lt;/script&gt;&lt;script&gt; new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; name: &#x27;rexhang&#x27; &#125; &#125;);&lt;/script&gt; Vue-lite.js: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135function nodeToFragment(node, vm) &#123; // createDocumentFragment()方法，是用来创建一个虚拟的节点对象，或者说，是用来创建文档碎片节点。它可以包含各种类型的节点，在创建之初是空的。 let virtualDOM = document.createDocumentFragment(); let child; while( child = node.firstChild)&#123; compile(child, vm) virtualDOM.appendChild(child); &#125; return virtualDOM;&#125;function compile (node, vm)&#123; const reg = /\\&#123;\\&#123;(.*)\\&#125;\\&#125;/; console.log(node); console.log(node.nodeType); if (node.nodeType === 1)&#123; // 节点类型是元素 const attr = node.attributes; for(let i = 0; i &lt; attr.length; i++)&#123; console.log(attr[i].nodeName); if(attr[i].nodeName === &#x27;v-model&#x27;)&#123; // 提取v-model的value const name = attr[i].nodeValue; node.addEventListener(&#x27;input&#x27;, e=&gt;&#123; vm[name] = e.target.value; &#125;); // 将data的值赋给该node // node.value = vm.data[name]; node.value = vm[name]; node.removeAttribute(&#x27;v-model&#x27;); &#125; &#125; &#125; if (node.nodeType === 3)&#123; // 节点类型是text if(reg.test(node.nodeValue))&#123; // 正则来获取匹配到的字符串&#123;&#123;name&#125;&#125; =&gt; name let name = node.nodeValue.match(reg)[1].trim(); // 将data的值赋给该node // node.nodeValue = vm.data[name]; // node.nodeValue = vm[name]; console.log(vm, node, name); new Watcher(vm, node, name); &#125; &#125;&#125;function defineReactive(obj, key, val)&#123; const dep = new Dep(); Object.defineProperty(obj, key, &#123; set: newVal =&gt; &#123; if(newVal === val) return; val = newVal; console.log(val); dep.notify(); &#125;, get: () =&gt; &#123; if(Dep.target) dep.addSub(Dep.target); return val; &#125; &#125;)&#125;function observe (obj, vm) &#123; Object.keys(obj).forEach(key=&gt;&#123; defineReactive(vm, key, obj[key]); &#125;);&#125;const dep = new Dep();const pub = &#123; publish: ()=&gt;&#123; dep.notify(); &#125;&#125;const sub1 = &#123; update: function () &#123; console.log(1); &#125; &#125;const sub2 = &#123; update: function () &#123; console.log(2); &#125; &#125;const sub3 = &#123; update: function () &#123; console.log(3); &#125; &#125;function Dep () &#123; // this.subs = [sub1, sub2, sub3]; this.subs = [];&#125;// Dep.prototype.notify = function()&#123;// this.subs.forEach(sub=&gt;&#123;// sub.update();// &#125;)// &#125;Dep.prototype.addSub = function(sub)&#123; this.subs.push(sub)&#125;Dep.prototype.notify = function()&#123; this.subs.forEach(sub=&gt;&#123; sub.update(); &#125;)&#125;pub.publish();function Watcher(vm, node, name)&#123; Dep.target = this; this.name = name; this.node = node; this.vm = vm; this.update(); Dep.target = null;&#125;Watcher.prototype = &#123; update: function()&#123; this.get(); this.node.nodeValue = this.value; &#125;, get: function()&#123; this.value = this.vm[this.name]; &#125;&#125;function Vue(opt)&#123; this.data = opt.data; observe(this.data, this); const rootDom = opt.el; const dom = nodeToFragment(document.querySelector(rootDom), this); // 编译完成，将dom返回到app中 document.querySelector(rootDom).appendChild(dom);&#125; 最终实现效果: 四、总结 Object.defineProperty 来进行数据中转(劫持)，从而实现事件的发布和后续触发订阅者的监听来实现数据绑定 实现一个监听器 observe 用来劫持并监听所有属性，如有变动，就通知订阅者 实现一个订阅者 Watcher 每个Watcher都绑定一个更新函数，可以把收到的属性变化通知并执行相应的函数，更新视图 实现一个解析器 compile 可以循环解析全部节点获取相关指令，初始化数据，初始化订阅 原文参考 Vue3.x双向绑定原理的实现参考","categories":[{"name":"大前端","slug":"大前端","permalink":"https://blog.rexhang.com/categories/%E5%A4%A7%E5%89%8D%E7%AB%AF/"},{"name":"面试经","slug":"大前端/面试经","permalink":"https://blog.rexhang.com/categories/%E5%A4%A7%E5%89%8D%E7%AB%AF/%E9%9D%A2%E8%AF%95%E7%BB%8F/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://blog.rexhang.com/tags/javascript/"},{"name":"Vue","slug":"Vue","permalink":"https://blog.rexhang.com/tags/Vue/"},{"name":"前端框架","slug":"前端框架","permalink":"https://blog.rexhang.com/tags/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/"}]},{"title":"几种判断数组的方法","slug":"几种判断数组的方法","date":"2021-01-09T16:01:22.000Z","updated":"2022-10-25T14:41:49.323Z","comments":true,"path":"2021/01/10/articles/1/","link":"","permalink":"https://blog.rexhang.com/2021/01/10/articles/1/","excerpt":"","text":"一、前言众所周知，js是门“动态”、“弱类型”编程语言，这意味着在js中可以任性定义变量，同时，“任性”也意味着需常在项目开发中对变量做类型判断，曾几何时，对数组变量的类型判断是件很痛苦的事情，开发人员想出多种方案来对数组做出准确的类型判断，但效果不佳，直到ES5标准“入主中原”，判断数组类型有了标准的isArray()官方利剑，才降伏了数组类型判断这条恶龙，世间得一清，但在此之前开发者是如何判断数组类型的？判断数组类型为何会如此玄学？为何要判断数组类型？带着这些疑问，吾跋山涉水，探寻各方资料，整理消化后遂成此文，以记之。 二、判断js数组类型为何麻烦？1、语言本身的“缺陷”js是门“动态”“弱类型”编程语言，这意味着js在定义和使用变量时可以“任性”，在ES6之前，我们定义变量一般使用“var”来定义： 123var name = &#x27;jack&#x27;;name = 20;name = [&#x27;aa&#x27;]; 在上述例子中，name变量初始定义为字符串类型，而后变为数字类型，最后摇身一变成为数组类型，这种任性摇摆的特性就是其“动态”特性，在java中我们定义一个字符串变量须如此定义：String name = ‘jack’，java通过一个String前缀“显式的”、“强制的”指定name变量为字符串类型，之后不得对该name变量进行类型变换(如果执行name = 22将会报type类型转换错误)，但js采用的是弱类型定义方案，在定义变量时使用var声明了一个变量，弱化了类型前缀的限制，并没强制锁死变量类型，之后可以随意更改其类型。动态弱类型这种声明变量的方案用起来可以随性而为，无须顾虑太多，随性的代码书写如若不加管制必将招致灾难性的代码bug。 2、js类型判断的“不足”其实动态弱类型的语言特性并不是决定js判断数组类型麻烦的必然原因，js语言因为历史原因，其创造者在开发之初将其定位为简单的网页小助手语言，为了轻巧、快速的完成小任务开发选择了“动态弱类型”的语言方案，PHP亦为动态弱类型语言，但在处理类型判断时，PHP用一个gettype()方法可以轻松、精准的搞定(PHP作为世界上世界上最好的语言还是有点东西的🤣)，PHP有gettype()这枚银弹，js有吗，嗯，算有吧，js最常用的是用typeof操作符来获取数据类型，看typeof这个名字是不是感觉很厉害？感觉会跟PHP一样轻松简单？但随后你会发现：typeof操作符是个很局限的类型获取方案，用它对基本数据类型做判断还算过得去，但在涉及到引用类型判断这种细活时就显得很low了… 三、判断js数组类型的几个“方案”1.typeof ❌ typeof在判断基础数据类型时尚有问题，更别说用来判断子孙繁多的引用类型了，typeof在判断引用类型时一刀切的统统返回object, 如 1234567var obj = &#123;&#125;;var arr = [];var map = new Map();typeof obj; // objecttypeof arr; // objecttypeof map; // object 故此，不适应于判断数据，PASS 2.data instanceof Array ❌ instanceof是js用来判断继承关系的运算符（js基于原型链实现继承，故instanceof判断的就是对应的类是否存在于变量的原型链上），根据这个特性可以如此来判断数组类型： 12const arr = [1, 2, 3];console.log(arr instanceof Array); // true 控制台打印显示如下: 从打印的结果可以看到Array存在于数组[1, 2, 3]的原型链上，故[1, 2, 3] instanceof Array === true; 利用instanceof的这个特性可以判断数组类型，但是instanceof运算符有个弊端 就是arr instanceof Object也是返回true: 12const arr2 = [1, 2, 3];console.log(arr2 instanceof Object); // true 控制台打印显示如下: 故此，不适应于判断数据，PASS 3.constructor ✔ 在JavaScript中, constructor属性会返回对象的构造函数。 1234let arr = [1, 2, 3];console.log(arr.constructor === Array); // truelet arr = [1, 2, 3];console.log(arr.constructor === Object); // false 控制台打印显示如下: 从打印结果显示，是满足我们的数据类型判断的，并且没有出现第二种判断方式instanceof方法的问题，因此是可以采用的。 4.Object.prototype.toString() ✔ Object.prototype.toString()能获取到变量的“类目名”，在js中万物皆为对象，万物皆有“类目名”，每个变量、对象、数组等都有一个唯一的类目名（这个类目名类似于人类给各类动植物起的“学名”），该方案通过获取目标变量的类目名([object Array])进行判断，如果类目名一致则证明目标变量为数组类型： 12let arr = [1, 2, 3];console.log( Object.prototype.toString.call(arr) === &#x27;[object Array]&#x27; ); // [object Array]: string; 返回 true Tips: 这种方法获取各种类型数据都有与之对应的字符串匹配值 12345678Object.prototype.toString.call([]); // &quot;[object Array]&quot;Object.prototype.toString.call(&#123;&#125;); // &quot;[object Object]&quot;Object.prototype.toString.call(&#x27;&#x27;); // &quot;[object String]&quot;Object.prototype.toString.call(1); // &quot;[object Number]&quot;Object.prototype.toString.call(function f()&#123;&#125;); // &quot;[object Function]&quot;Object.prototype.toString.call(); // &quot;[object Undefined]&quot;Object.prototype.toString.call(null); // &quot;[object Null]&quot;Object.prototype.toString.call(document); // &quot;[object HTMLDocument]&quot; 从打印结果显示，是满足我们的数据类型判断的，因此是可以采用的。 5.Array.isArray() ✔ 该方法是ES5标准规定的判断数组类型的标准方法，虽然Object.prototype.toString()方法可用来判断数组类型，但未免显得有点hack，又因自家typeof类型操作符给予厚望，辱没众望，如果随便更改typeof的返回结果势必会导致天下大乱，instanceof运算符又存在不同frame的局限性难堪大任，ES5不得不亡羊补牢的设计了isArray()方法来“增量”的解决数组判断难题。 12Array.isArray([1, 2, 3]); // trueArray.isArray(&#123;&#125;); // false 从打印结果显示，是满足我们的数据类型判断的，因此是可以采用的。 四、为何要判断数组类型？前面说过js属于动态弱类型语言，可能某个变量用着用着就莫名其妙的变了类型（自己不小心更改类型，引入的第三方代码库，因为同名变量改变了类型），如果你设想的是某个变量为数组类型，但因某个逻辑变成了基本类型，这时如果调用数组的方法注定会报错，凡此种种导致的问题，数不胜数，具体的问题实践多了懂得就懂。 五、结语近几年前端项目愈发复杂庞大，为更好的构建高性能的前端项目，诞生了“react、angular、vue”等数据驱动型解决方案，大量的数据、大量的组件和类对数据类型的判断需求愈发频繁，但因为js动态弱类型语言特性，加之其类型判断的坑爹性，所以各路开发者希望完善和升级js，在ES6标准中，新的const变量定义方案能很好的应对变量动态性问题，微软开发的“typescript”能够实现强类型变量定义，可应对弱类型定义问题。这些方案极大的减少了早期js变量任性定义带来的各种问题，虽然判断数组类型在未来开发中可能会成为历史云烟，但理解其相关的基础和历史演变却是一件很【浪漫】的事情，因为在理解了它的相关坑爹性和进化史有助于我们更好的思考和优化。爱之深，责之切，希望js能在未来变得更加锋利可靠，也希望少为一些坑爹特性而想出一些hack方案(额，比如——&gt;Object.prototype.toString()方法)。","categories":[{"name":"大前端","slug":"大前端","permalink":"https://blog.rexhang.com/categories/%E5%A4%A7%E5%89%8D%E7%AB%AF/"},{"name":"面试经","slug":"大前端/面试经","permalink":"https://blog.rexhang.com/categories/%E5%A4%A7%E5%89%8D%E7%AB%AF/%E9%9D%A2%E8%AF%95%E7%BB%8F/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://blog.rexhang.com/tags/javascript/"},{"name":"javascript数组","slug":"javascript数组","permalink":"https://blog.rexhang.com/tags/javascript%E6%95%B0%E7%BB%84/"}]},{"title":"javascript函数防抖与节流","slug":"javascript函数防抖与节流","date":"2021-01-04T18:03:33.000Z","updated":"2022-10-25T14:41:49.323Z","comments":true,"path":"2021/01/05/articles/2/","link":"","permalink":"https://blog.rexhang.com/2021/01/05/articles/2/","excerpt":"","text":"概念和例子函数防抖(debounce) 在事件被触发n秒后再执行回调，如果在这n秒内又被触发，则重新计时。 12345678910// 模拟一段ajax请求function ajax(content) &#123; console.log(&#x27;ajax request &#x27; + content)&#125;let inputa = document.getElementById(&#x27;unDebounce&#x27;)inputa.addEventListener(&#x27;keyup&#x27;, function (e) &#123; ajax(e.target.value)&#125;) 运行效果如图: 可以看到，我们只要按下键盘，就会触发这次ajax请求。不仅从资源上来说是很浪费的行为，而且实际应用中，用户也是输出完整的字符后，才会请求。下面我们优化一下： 1234567891011121314151617181920212223// 模拟一段ajax请求function ajax(content) &#123; console.log(&#x27;ajax request &#x27; + content)&#125;function debounce(fun, delay) &#123; return function (args) &#123; let that = this let _args = args clearTimeout(fun.id) fun.id = setTimeout(function () &#123; fun.call(that, _args) &#125;, delay) &#125;&#125; let inputb = document.getElementById(&#x27;debounce&#x27;)let debounceAjax = debounce(ajax, 500)inputb.addEventListener(&#x27;keyup&#x27;, function (e) &#123; debounceAjax(e.target.value)&#125;) 运行效果如图: 可以看到，我们加入了防抖以后，当你在频繁的输入时，并不会发送请求，只有当你在指定间隔内没有输入时，才会执行函数。如果停止输入但是在指定间隔内又输入，会重新触发计时。 个人理解 函数防抖就是法师发技能的时候要读条，技能读条没完再按技能就会重新读条。 函数节流(throttle) 规定在一个单位时间内，只能触发一次函数。如果这个单位时间内触发多次函数，只有一次生效。 看代码: 12345678910111213141516171819202122232425function throttle(fun, delay) &#123; let last, deferTimer return function (args) &#123; let that = this let _args = arguments let now = +new Date() if (last &amp;&amp; now &lt; last + delay) &#123; clearTimeout(deferTimer) deferTimer = setTimeout(function () &#123; last = now fun.apply(that, _args) &#125;, delay) &#125;else &#123; last = now fun.apply(that,_args) &#125; &#125;&#125;let throttleAjax = throttle(ajax, 1000)let inputc = document.getElementById(&#x27;throttle&#x27;)inputc.addEventListener(&#x27;keyup&#x27;, function(e) &#123; throttleAjax(e.target.value)&#125;) 看一下运行结果: 可以看到，我们在不断输入时，ajax会按照我们设定的时间，每1s执行一次。 个人理解 函数节流就是fps游戏的射速，就算一直按着鼠标射击，也只会在规定射速内射出子弹。 总结 函数防抖和函数节流都是防止某一时间频繁触发，但是这两兄弟之间的原理却不一样。 函数防抖是某一段时间内只执行一次，而函数节流是间隔时间执行。 结合应用场景 防抖(debounce) search搜索联想，用户在不断输入值时，用防抖来节约请求资源。 window触发resize的时候，不断的调整浏览器窗口大小会不断的触发这个事件，用防抖来让其只触发一次 节流（throttle） 鼠标不断点击触发，mousedown(单位时间内只触发一次) 监听滚动事件，比如是否滑到底部自动加载更多，用throttle来判断","categories":[{"name":"大前端","slug":"大前端","permalink":"https://blog.rexhang.com/categories/%E5%A4%A7%E5%89%8D%E7%AB%AF/"},{"name":"面试经","slug":"大前端/面试经","permalink":"https://blog.rexhang.com/categories/%E5%A4%A7%E5%89%8D%E7%AB%AF/%E9%9D%A2%E8%AF%95%E7%BB%8F/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://blog.rexhang.com/tags/javascript/"}]},{"title":"如何创建一个TC的免费托管服务","slug":"如何创建一个TC的免费托管服务","date":"2021-01-04T17:06:21.000Z","updated":"2022-10-25T14:41:49.324Z","comments":true,"path":"2021/01/05/articles/1/","link":"","permalink":"https://blog.rexhang.com/2021/01/05/articles/1/","excerpt":"","text":"首先&nbsp;&nbsp;&nbsp;&nbsp;需要先全局安装cli, 本地预先安装好nodejs以及git 1$ npm i -g @cloudbase/cli hexo-cli 然后&nbsp;&nbsp;&nbsp;&nbsp;初始化一个hexo项目目录 1$ hexo init 初始化完毕后, 启动服务本地编写文章 1$ hexo s 发布&nbsp;&nbsp;&nbsp;&nbsp;发布就很简单了，获取授权，生成静态代码，使用cli推送到远程托管 123$ cloudbase login$ hexo g$ cloudbase hosting deploy public -e [EnvID] tips 环境ID(EnvID)获取方法: 链接 创建环境指引: 链接","categories":[{"name":"腾讯云","slug":"腾讯云","permalink":"https://blog.rexhang.com/categories/%E8%85%BE%E8%AE%AF%E4%BA%91/"},{"name":"操作技巧","slug":"腾讯云/操作技巧","permalink":"https://blog.rexhang.com/categories/%E8%85%BE%E8%AE%AF%E4%BA%91/%E6%93%8D%E4%BD%9C%E6%8A%80%E5%B7%A7/"}],"tags":[{"name":"腾讯云","slug":"腾讯云","permalink":"https://blog.rexhang.com/tags/%E8%85%BE%E8%AE%AF%E4%BA%91/"}]}],"categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://blog.rexhang.com/categories/JavaScript/"},{"name":"TypeScript","slug":"JavaScript/TypeScript","permalink":"https://blog.rexhang.com/categories/JavaScript/TypeScript/"},{"name":"Node.js","slug":"JavaScript/TypeScript/Node-js","permalink":"https://blog.rexhang.com/categories/JavaScript/TypeScript/Node-js/"},{"name":"Python","slug":"JavaScript/TypeScript/Node-js/Python","permalink":"https://blog.rexhang.com/categories/JavaScript/TypeScript/Node-js/Python/"},{"name":"阅读","slug":"JavaScript/TypeScript/Node-js/Python/阅读","permalink":"https://blog.rexhang.com/categories/JavaScript/TypeScript/Node-js/Python/%E9%98%85%E8%AF%BB/"},{"name":"电子书","slug":"JavaScript/电子书","permalink":"https://blog.rexhang.com/categories/JavaScript/%E7%94%B5%E5%AD%90%E4%B9%A6/"},{"name":"AI","slug":"AI","permalink":"https://blog.rexhang.com/categories/AI/"},{"name":"Ollama","slug":"AI/Ollama","permalink":"https://blog.rexhang.com/categories/AI/Ollama/"},{"name":"DeepSeek","slug":"AI/Ollama/DeepSeek","permalink":"https://blog.rexhang.com/categories/AI/Ollama/DeepSeek/"},{"name":"前端","slug":"前端","permalink":"https://blog.rexhang.com/categories/%E5%89%8D%E7%AB%AF/"},{"name":"Chrome","slug":"前端/Chrome","permalink":"https://blog.rexhang.com/categories/%E5%89%8D%E7%AB%AF/Chrome/"},{"name":"Prerender2.0","slug":"前端/Chrome/Prerender2-0","permalink":"https://blog.rexhang.com/categories/%E5%89%8D%E7%AB%AF/Chrome/Prerender2-0/"},{"name":"npm","slug":"前端/npm","permalink":"https://blog.rexhang.com/categories/%E5%89%8D%E7%AB%AF/npm/"},{"name":"JS","slug":"前端/JS","permalink":"https://blog.rexhang.com/categories/%E5%89%8D%E7%AB%AF/JS/"},{"name":"guide","slug":"前端/JS/guide","permalink":"https://blog.rexhang.com/categories/%E5%89%8D%E7%AB%AF/JS/guide/"},{"name":"规范","slug":"前端/JS/guide/规范","permalink":"https://blog.rexhang.com/categories/%E5%89%8D%E7%AB%AF/JS/guide/%E8%A7%84%E8%8C%83/"},{"name":"HTML","slug":"前端/HTML","permalink":"https://blog.rexhang.com/categories/%E5%89%8D%E7%AB%AF/HTML/"},{"name":"guide","slug":"前端/HTML/guide","permalink":"https://blog.rexhang.com/categories/%E5%89%8D%E7%AB%AF/HTML/guide/"},{"name":"规范","slug":"前端/HTML/guide/规范","permalink":"https://blog.rexhang.com/categories/%E5%89%8D%E7%AB%AF/HTML/guide/%E8%A7%84%E8%8C%83/"},{"name":"CSS","slug":"前端/CSS","permalink":"https://blog.rexhang.com/categories/%E5%89%8D%E7%AB%AF/CSS/"},{"name":"guide","slug":"前端/CSS/guide","permalink":"https://blog.rexhang.com/categories/%E5%89%8D%E7%AB%AF/CSS/guide/"},{"name":"规范","slug":"前端/CSS/guide/规范","permalink":"https://blog.rexhang.com/categories/%E5%89%8D%E7%AB%AF/CSS/guide/%E8%A7%84%E8%8C%83/"},{"name":"Git","slug":"前端/Git","permalink":"https://blog.rexhang.com/categories/%E5%89%8D%E7%AB%AF/Git/"},{"name":"guide","slug":"前端/Git/guide","permalink":"https://blog.rexhang.com/categories/%E5%89%8D%E7%AB%AF/Git/guide/"},{"name":"规范","slug":"前端/Git/guide/规范","permalink":"https://blog.rexhang.com/categories/%E5%89%8D%E7%AB%AF/Git/guide/%E8%A7%84%E8%8C%83/"},{"name":"大前端","slug":"大前端","permalink":"https://blog.rexhang.com/categories/%E5%A4%A7%E5%89%8D%E7%AB%AF/"},{"name":"面试经","slug":"大前端/面试经","permalink":"https://blog.rexhang.com/categories/%E5%A4%A7%E5%89%8D%E7%AB%AF/%E9%9D%A2%E8%AF%95%E7%BB%8F/"},{"name":"node","slug":"node","permalink":"https://blog.rexhang.com/categories/node/"},{"name":"nvm","slug":"node/nvm","permalink":"https://blog.rexhang.com/categories/node/nvm/"},{"name":"ai","slug":"ai","permalink":"https://blog.rexhang.com/categories/ai/"},{"name":"openai","slug":"ai/openai","permalink":"https://blog.rexhang.com/categories/ai/openai/"},{"name":"chatgpt","slug":"ai/openai/chatgpt","permalink":"https://blog.rexhang.com/categories/ai/openai/chatgpt/"},{"name":"面试经","slug":"面试经","permalink":"https://blog.rexhang.com/categories/%E9%9D%A2%E8%AF%95%E7%BB%8F/"},{"name":"前端","slug":"面试经/前端","permalink":"https://blog.rexhang.com/categories/%E9%9D%A2%E8%AF%95%E7%BB%8F/%E5%89%8D%E7%AB%AF/"},{"name":"JavaScript","slug":"面试经/前端/JavaScript","permalink":"https://blog.rexhang.com/categories/%E9%9D%A2%E8%AF%95%E7%BB%8F/%E5%89%8D%E7%AB%AF/JavaScript/"},{"name":"开发工具","slug":"前端/开发工具","permalink":"https://blog.rexhang.com/categories/%E5%89%8D%E7%AB%AF/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"},{"name":"node","slug":"前端/开发工具/node","permalink":"https://blog.rexhang.com/categories/%E5%89%8D%E7%AB%AF/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/node/"},{"name":"css3","slug":"大前端/css3","permalink":"https://blog.rexhang.com/categories/%E5%A4%A7%E5%89%8D%E7%AB%AF/css3/"},{"name":"游戏引擎","slug":"大前端/游戏引擎","permalink":"https://blog.rexhang.com/categories/%E5%A4%A7%E5%89%8D%E7%AB%AF/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"效率","slug":"大前端/效率","permalink":"https://blog.rexhang.com/categories/%E5%A4%A7%E5%89%8D%E7%AB%AF/%E6%95%88%E7%8E%87/"},{"name":"前端开发","slug":"大前端/效率/前端开发","permalink":"https://blog.rexhang.com/categories/%E5%A4%A7%E5%89%8D%E7%AB%AF/%E6%95%88%E7%8E%87/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"},{"name":"图表","slug":"大前端/图表","permalink":"https://blog.rexhang.com/categories/%E5%A4%A7%E5%89%8D%E7%AB%AF/%E5%9B%BE%E8%A1%A8/"},{"name":"G2","slug":"大前端/图表/G2","permalink":"https://blog.rexhang.com/categories/%E5%A4%A7%E5%89%8D%E7%AB%AF/%E5%9B%BE%E8%A1%A8/G2/"},{"name":"兼容性","slug":"大前端/兼容性","permalink":"https://blog.rexhang.com/categories/%E5%A4%A7%E5%89%8D%E7%AB%AF/%E5%85%BC%E5%AE%B9%E6%80%A7/"},{"name":"心得","slug":"大前端/兼容性/心得","permalink":"https://blog.rexhang.com/categories/%E5%A4%A7%E5%89%8D%E7%AB%AF/%E5%85%BC%E5%AE%B9%E6%80%A7/%E5%BF%83%E5%BE%97/"},{"name":"腾讯云","slug":"腾讯云","permalink":"https://blog.rexhang.com/categories/%E8%85%BE%E8%AE%AF%E4%BA%91/"},{"name":"操作技巧","slug":"腾讯云/操作技巧","permalink":"https://blog.rexhang.com/categories/%E8%85%BE%E8%AE%AF%E4%BA%91/%E6%93%8D%E4%BD%9C%E6%8A%80%E5%B7%A7/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://blog.rexhang.com/tags/JavaScript/"},{"name":"TypeScript","slug":"TypeScript","permalink":"https://blog.rexhang.com/tags/TypeScript/"},{"name":"Node.js","slug":"Node-js","permalink":"https://blog.rexhang.com/tags/Node-js/"},{"name":"Python","slug":"Python","permalink":"https://blog.rexhang.com/tags/Python/"},{"name":"阅读","slug":"阅读","permalink":"https://blog.rexhang.com/tags/%E9%98%85%E8%AF%BB/"},{"name":"电子书","slug":"电子书","permalink":"https://blog.rexhang.com/tags/%E7%94%B5%E5%AD%90%E4%B9%A6/"},{"name":"AI","slug":"AI","permalink":"https://blog.rexhang.com/tags/AI/"},{"name":"Ollama","slug":"Ollama","permalink":"https://blog.rexhang.com/tags/Ollama/"},{"name":"DeepSeek","slug":"DeepSeek","permalink":"https://blog.rexhang.com/tags/DeepSeek/"},{"name":"frontend","slug":"frontend","permalink":"https://blog.rexhang.com/tags/frontend/"},{"name":"Chrome","slug":"Chrome","permalink":"https://blog.rexhang.com/tags/Chrome/"},{"name":"Prerender2.0","slug":"Prerender2-0","permalink":"https://blog.rexhang.com/tags/Prerender2-0/"},{"name":"npm","slug":"npm","permalink":"https://blog.rexhang.com/tags/npm/"},{"name":"guide","slug":"guide","permalink":"https://blog.rexhang.com/tags/guide/"},{"name":"规范","slug":"规范","permalink":"https://blog.rexhang.com/tags/%E8%A7%84%E8%8C%83/"},{"name":"js","slug":"js","permalink":"https://blog.rexhang.com/tags/js/"},{"name":"html","slug":"html","permalink":"https://blog.rexhang.com/tags/html/"},{"name":"css","slug":"css","permalink":"https://blog.rexhang.com/tags/css/"},{"name":"git","slug":"git","permalink":"https://blog.rexhang.com/tags/git/"},{"name":"javascript","slug":"javascript","permalink":"https://blog.rexhang.com/tags/javascript/"},{"name":"node","slug":"node","permalink":"https://blog.rexhang.com/tags/node/"},{"name":"nvm","slug":"nvm","permalink":"https://blog.rexhang.com/tags/nvm/"},{"name":"ES2023","slug":"ES2023","permalink":"https://blog.rexhang.com/tags/ES2023/"},{"name":"javascript对象","slug":"javascript对象","permalink":"https://blog.rexhang.com/tags/javascript%E5%AF%B9%E8%B1%A1/"},{"name":"ai","slug":"ai","permalink":"https://blog.rexhang.com/tags/ai/"},{"name":"openai","slug":"openai","permalink":"https://blog.rexhang.com/tags/openai/"},{"name":"chatgpt","slug":"chatgpt","permalink":"https://blog.rexhang.com/tags/chatgpt/"},{"name":"前端技术","slug":"前端技术","permalink":"https://blog.rexhang.com/tags/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/"},{"name":"面试经","slug":"面试经","permalink":"https://blog.rexhang.com/tags/%E9%9D%A2%E8%AF%95%E7%BB%8F/"},{"name":"前端","slug":"前端","permalink":"https://blog.rexhang.com/tags/%E5%89%8D%E7%AB%AF/"},{"name":"开发工具","slug":"开发工具","permalink":"https://blog.rexhang.com/tags/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"},{"name":"devtools","slug":"devtools","permalink":"https://blog.rexhang.com/tags/devtools/"},{"name":"css3","slug":"css3","permalink":"https://blog.rexhang.com/tags/css3/"},{"name":"mask","slug":"mask","permalink":"https://blog.rexhang.com/tags/mask/"},{"name":"遮罩","slug":"遮罩","permalink":"https://blog.rexhang.com/tags/%E9%81%AE%E7%BD%A9/"},{"name":"cocos2d","slug":"cocos2d","permalink":"https://blog.rexhang.com/tags/cocos2d/"},{"name":"CocosCreator","slug":"CocosCreator","permalink":"https://blog.rexhang.com/tags/CocosCreator/"},{"name":"游戏引擎","slug":"游戏引擎","permalink":"https://blog.rexhang.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"javascript数组","slug":"javascript数组","permalink":"https://blog.rexhang.com/tags/javascript%E6%95%B0%E7%BB%84/"},{"name":"javascript字符串","slug":"javascript字符串","permalink":"https://blog.rexhang.com/tags/javascript%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"js小tips","slug":"js小tips","permalink":"https://blog.rexhang.com/tags/js%E5%B0%8Ftips/"},{"name":"js技巧","slug":"js技巧","permalink":"https://blog.rexhang.com/tags/js%E6%8A%80%E5%B7%A7/"},{"name":"前端框架","slug":"前端框架","permalink":"https://blog.rexhang.com/tags/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/"},{"name":"React","slug":"React","permalink":"https://blog.rexhang.com/tags/React/"},{"name":"前端多端开发兼容性","slug":"前端多端开发兼容性","permalink":"https://blog.rexhang.com/tags/%E5%89%8D%E7%AB%AF%E5%A4%9A%E7%AB%AF%E5%BC%80%E5%8F%91%E5%85%BC%E5%AE%B9%E6%80%A7/"},{"name":"ios","slug":"ios","permalink":"https://blog.rexhang.com/tags/ios/"},{"name":"macos","slug":"macos","permalink":"https://blog.rexhang.com/tags/macos/"},{"name":"apple","slug":"apple","permalink":"https://blog.rexhang.com/tags/apple/"},{"name":"苹果","slug":"苹果","permalink":"https://blog.rexhang.com/tags/%E8%8B%B9%E6%9E%9C/"},{"name":"Vue","slug":"Vue","permalink":"https://blog.rexhang.com/tags/Vue/"},{"name":"腾讯云","slug":"腾讯云","permalink":"https://blog.rexhang.com/tags/%E8%85%BE%E8%AE%AF%E4%BA%91/"}]}