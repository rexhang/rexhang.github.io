<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Rexhang的Blog</title>
  
  <subtitle>blog</subtitle>
  <link href="https://blog.rexhang.com/atom.xml" rel="self"/>
  
  <link href="https://blog.rexhang.com/"/>
  <updated>2023-07-24T17:26:46.754Z</updated>
  <id>https://blog.rexhang.com/</id>
  
  <author>
    <name>RexHang</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>如何注册ChatGPT账号</title>
    <link href="https://blog.rexhang.com/2023/07/25/articles/1/"/>
    <id>https://blog.rexhang.com/2023/07/25/articles/1/</id>
    <published>2023-07-24T17:20:17.000Z</published>
    <updated>2023-07-24T17:26:46.754Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><blockquote><p>ChatGPT（全名：Chat Generative Pre-trained Transformer），是OpenAI研发的聊天机器人程序 ，于2022年11月30日发布。ChatGPT是人工智能技术驱动的自然语言处理工具，它能够通过理解和学习人类的语言来进行对话，还能根据聊天的上下文进行互动，真正像人类一样来聊天交流，甚至能完成撰写邮件、视频脚本、文案、翻译、代码，写论文等任务。</p></blockquote><p>那么如何注册它呢，其实还是有一些小门槛的，下面就来介绍如何进行注册。</p><p><strong>准备工作</strong>:</p><ol><li><strong>科学上网</strong>条件</li><li><strong>谷歌</strong>、<strong>微软</strong>或者<strong>苹果</strong>邮箱, 其他邮箱<strong>不建议</strong></li><li><strong>国外手机号</strong>，没有也没关系，下文会推荐去一个<strong>平台</strong>使用<strong>国外的虚拟手机号</strong>来接受验证码等信息</li></ol><h3 id="第一步，设置代理"><a href="#第一步，设置代理" class="headerlink" title="第一步，设置代理"></a>第一步，设置代理</h3><p><strong>科学上网软件</strong>设置为<strong>全局模式</strong>（可以查看下面2个网站来确认自己的是否处于外网<a href="https://www.ip138.com/">网站1</a>、<a href="https://www.ipaddress.my/">网站2</a>，），国家尽量选择<strong>北美</strong>或者<strong>日本</strong>这些国家，不要选择括号内这些国家（<strong>俄罗斯、中国、北朝鲜、古巴、伊朗、叙利亚、意大利</strong>）因为这些国家<strong>禁止使用ChatGPT</strong>服务，以下是符合注册条件的的IP示例</p><img src="/images/blog/2023-07-25/image-20230724234456309.png#pic_left" alt="image-20230724234456309" style="zoom:33%;" /><h3 id="第二步-如果有国外手机号忽略此步骤-，打开虚拟电话号码注册平台"><a href="#第二步-如果有国外手机号忽略此步骤-，打开虚拟电话号码注册平台" class="headerlink" title="第二步(如果有国外手机号忽略此步骤)，打开虚拟电话号码注册平台"></a>第二步(如果有国外手机号忽略此步骤)，打开虚拟电话号码注册平台</h3><p>打开<a href="https://sms-activate.org/">虚拟电话号码注册平台</a>，进入后点击右上角<strong>登录注册</strong>，先进行账号<strong>注册</strong></p><img src="/images/blog/2023-07-25/image-20230724234814256.png#pic_left" alt="image-20230724234814256" style="zoom: 33%;" /><p>还是一样，尽可能使用<strong>准备工作中准备好的邮箱平台进行注册</strong>，注册邮箱如果长时间没收到验证信息的，请检查是否被归类到<strong>垃圾邮件</strong>了，如果一切正常，点击官方发来的邮件后，会自动打开网址，那么此时你应该已经<strong>登录成功</strong>了，如下图所示</p><img src="/images/blog/2023-07-25/image-20230724235726742.png#pic_left" alt="image-20230724235726742" style="zoom:50%;" /><p>此时，我们在左侧搜索栏直接搜索<code>openai</code>，并且点击下图中粗红色框住的部分，可能由于没有钱包余额，购买失败，请继续往下看</p><img src="/images/blog/2023-07-25/image-20230724235943340.png#pic_left" alt="image-20230724235943340" style="zoom: 50%;" /><p>商品列表中可以根据价格排序，选择最低价格的即可，推荐<strong>印度尼西亚</strong></p><img src="/images/blog/2023-07-25/image-20230725000341755.png#pic_left" alt="image-20230725000341755" style="zoom: 50%;" /><p>但是此时我们<strong>账户没余额</strong>，因此需要先<strong>充值</strong>，点击<strong>右上角用户头像旁边的加号按钮</strong>进入<strong>充值页面</strong>，拉到底部选择<strong>支付宝</strong>，进行充值付款即可(<strong>某些平台有的需要最低充值金额</strong>)，然后返回<strong>继续购买</strong></p><img src="/images/blog/2023-07-25/image-20230725002307603.png#pic_left" alt="image-20230725002307603" style="zoom: 50%;" /><p>充值完成后，右上角观察看到余额变化</p><p><img src="/images/blog/2023-07-25/image-20230725002258675.png#pic_left" alt="image-20230725002258675"></p><p>点击购物车按钮即可，点一下就行，不要多点，以免造成重复扣费！如果购买成功页面会<strong>刷出来手机号码</strong>，直接去<a href="https://chat.openai.com/auth/login">ChatGPT官网注册</a>使用这个号码即可，短信验证码也会在web端刷出来，填入即可</p><img src="/images/blog/2023-07-25/image-20230725002404205.png#pic_left" alt="image-20230725002404205" style="zoom: 50%;" /><p>下面来到上文提到的<a href="https://chat.openai.com/auth/login">ChatGPT官网注册</a>，点击注册按钮</p><img src="/images/blog/2023-07-25/image-20230725002730286.png#pic_left" alt="image-20230725002730286" style="zoom:50%;" /><p>选择<strong>三大邮箱</strong>或者准备好的<strong>国际其他平台邮箱</strong>，填入</p><img src="/images/blog/2023-07-25/image-20230725002820616.png#pic_left" alt="image-20230725002820616" style="zoom:50%;" /><p>此处我选择的<strong>谷歌邮箱</strong></p><img src="/images/blog/2023-07-25/image-20230725003000834.png#pic_left" alt="image-20230725003000834" style="zoom:50%;" /><p>填入手机号的时候<strong>注意</strong>，<strong>如果是点击上方网站直接复制的手机号码记得去掉前面的几位xxx，例如+62就去掉复制出来的前两位62，+029就去掉复制出来的前三位029，如果验证手机号是无效的，可以在web网站点击号码后面的刷新按钮，获取一个新手机号，再返回重填即可</strong>，下面的选项选择<code>NO</code>，然后<strong>点击发送SMS</strong></p><img src="/images/blog/2023-07-25/image-20230725004138170.png#pic_left" alt="image-20230725004138170" style="zoom:50%;" /><img src="/images/blog/2023-07-25/image-20230725004148726-1690216910630-1.png#pic_left" alt="image-20230725004148726" style="zoom:33%;" /><p>不出意外的话，<strong>回到短信平台</strong>验证码收到了，如下图所示，复制出来，<strong>填入<code>Enter code</code>输入框</strong>即可</p><p><img src="/images/blog/2023-07-25/image-20230725004233617.png#pic_left" alt="image-20230725004233617"></p><p>随后网站会<strong>自动跳转</strong>到主应用界面，就可以在<strong>输入框输入内容</strong>进行提问了</p><img src="/images/blog/2023-07-25/image-20230725004339759.png#pic_left" alt="image-20230725004339759" style="zoom: 33%;" /><p>至此，<code>ChatGPT</code>官网<strong>注册教程</strong>就基本完毕了，你可以愉快的使用啦，<strong>切记</strong>以后<strong>尽量使用同一个国家的节点</strong>，或者<strong>全局代理</strong>到<strong>合规的国家节点</strong>内，<a href="https://ai.com/">ChatGPT</a>只要登录后，则可直接通过<a href="https://chat.openai.com/api/auth/session">获取access_token</a>，再结合<a href="https://github.com/pengzhile/pandora">潘多拉项目</a>，达成在使用时能够<strong>免翻墙</strong>使用！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;ChatGPT（全名：Chat Generative Pre-trained Transformer），是Open</summary>
      
    
    
    
    <category term="ai" scheme="https://blog.rexhang.com/categories/ai/"/>
    
    <category term="openai" scheme="https://blog.rexhang.com/categories/ai/openai/"/>
    
    <category term="chatgpt" scheme="https://blog.rexhang.com/categories/ai/openai/chatgpt/"/>
    
    
    <category term="ai" scheme="https://blog.rexhang.com/tags/ai/"/>
    
    <category term="openai" scheme="https://blog.rexhang.com/tags/openai/"/>
    
    <category term="chatgpt" scheme="https://blog.rexhang.com/tags/chatgpt/"/>
    
  </entry>
  
  <entry>
    <title>前端技术摘要</title>
    <link href="https://blog.rexhang.com/2023/07/01/articles/1/"/>
    <id>https://blog.rexhang.com/2023/07/01/articles/1/</id>
    <published>2023-07-01T14:22:22.000Z</published>
    <updated>2023-07-21T07:17:58.429Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前端技术总结罗列-持续更新中…"><a href="#前端技术总结罗列-持续更新中…" class="headerlink" title="前端技术总结罗列(持续更新中…)"></a>前端技术总结罗列(持续更新中…)</h2><h3 id="1、localStorage、sessionStorage、cookie、session、indexDB…-跨页面共享策略？机制各有不同之处？如何跨页面通信？"><a href="#1、localStorage、sessionStorage、cookie、session、indexDB…-跨页面共享策略？机制各有不同之处？如何跨页面通信？" class="headerlink" title="1、localStorage、sessionStorage、cookie、session、indexDB… 跨页面共享策略？机制各有不同之处？如何跨页面通信？"></a>1、localStorage、sessionStorage、cookie、session、indexDB… 跨页面共享策略？机制各有不同之处？如何跨页面通信？</h3><blockquote><p><strong>postMessage、iframe、跨域策略、时效性…</strong></p></blockquote><p><img src="/images/blog/2022-10-25/1.png#pic_center" alt="图片1" title="图片1"></p><p>session: 存于服务器端，安全，前端不可改，大小几乎不限制, 可存在于redis、SQL数据库中 可用于登录<br>cookie 4kb 不安全 默认20分钟 到期后会被清除 前后端都可设置 不设置的话自然会失效消失 可存储登录token 可被浏览器请求携带(默认携带跨域不携带)，请求的时候带上凭证配置(credentials)&lt;omit(不发送)、same-orgin(同源才发送 cookies)、include(必定全部发送)&gt;: true server端也需要接受Access-Control-Allow-Credentials才可<br>sessionStorage 5MB+- 仅存在于当前会话页面 关闭后 会清除<br>localStorage 5MB+- 持久化存储 不主动清除不会消失<br>indexDB 大小默认50MB 不主动清除 除非手动 可以扩容 kv形式存储</p><hr><h3 id="2、React路由鉴权"><a href="#2、React路由鉴权" class="headerlink" title="2、React路由鉴权"></a>2、React路由鉴权</h3><blockquote><p><strong>包装组件后if return</strong></p></blockquote><hr><h3 id="3、策略模式"><a href="#3、策略模式" class="headerlink" title="3、策略模式"></a>3、策略模式</h3><blockquote><p><strong>使用js策略模式优化代码</strong></p></blockquote><hr><h3 id="4、前端跨域问题解决"><a href="#4、前端跨域问题解决" class="headerlink" title="4、前端跨域问题解决"></a>4、前端跨域问题解决</h3><blockquote><p><strong>浏览器的一种在前端客户端进行的防护策略，规定必须同源同端口&lt;协议、域名、端口&gt;</strong><br><strong>解决&lt;参考: <a href="https://blog.csdn.net/zh0623/article/details/123739455">链接</a>&gt;：</strong></p></blockquote><ol><li>jsonp <code>Script、jQuery、Axios</code></li><li>跨域资源共享（CORS）前后端共同实现 <code>简单请求和非简单请求</code></li><li>nginx反向代理接口跨域</li><li>nodejs中间件代理跨域 <code>使用node + express + http-proxy-middleware搭建一个proxy服务器</code></li><li>node + vue|react + webpack + webpack-dev-server 进行proxy配置解决跨域访问资源 因为渲染和代理都在同一处不在跨域</li><li>document.domain + iframe跨域 <code>主域相同，子域不同的跨域应用场景 eg: weixin.qq.com和im.qq.com 2边都强制设置 document.domain = qq.com 即可，iframe子窗口则可以通过window.parent.xx获取主页面中的全局变量内容了</code></li><li>location.hash + iframe跨域 <code>不展开叙述</code></li><li>window.name + iframe跨域 <code>不展开叙述</code></li><li>postMessage(data, origin) <code>主页面通过 iframeDom.contentWindow.postMessage(&#39;xx&#39;, &#39;*&#39;)发送数据，子页面(iframe)通过window.onMessage监听即可, 也可以再发给父级页面 window.parent.postMessage, 父级页面再window.onMessage监听</code></li><li>webSocket本身不存在跨域问题，所以我们可以利用webSocket来进行非同源之间的通信 <code>socket.io前后端搭建ws服务实现跨页面数据传输 本质还是搭建服务器</code></li><li>使用chrome扩展插件解决跨域问题 <code>针对特定浏览器内 解决跨域问题 因为本身扩展插件是不会被跨域策略拦截的 利用这一特性实现</code></li><li>chrome版本号49之前的跨域设置 <code>启动目标框里加上 --disable-web-security</code></li><li>前端chrome插件配置代理 + 后端接口代理请求服务实现</li></ol><hr><h3 id="5、Js-instanceof"><a href="#5、Js-instanceof" class="headerlink" title="5、Js instanceof"></a>5、Js instanceof</h3><blockquote><p><strong>用于检测构造函数的 prototype 属性是否出现在某个实例对象的原型链上 <a href="https://blog.csdn.net/weixin_40013817/article/details/103182967">参考URL</a></strong><br><strong>a instanceof A 用于检测 a是一个实例化对象 它的__proto__是否指向或者说是等于A的prototype</strong></p></blockquote><hr><h3 id="6、事件循环-任务队列-宏任务-微任务"><a href="#6、事件循环-任务队列-宏任务-微任务" class="headerlink" title="6、事件循环 任务队列 宏任务 微任务"></a>6、事件循环 任务队列 宏任务 微任务</h3><ol><li>同步任务 放入主线程中 eg: console.log(‘’);</li><li>异步任务 放入任务队列中(延迟性任务)<ul><li>宏任务 setTimeout、setInterval等(优先级低于微任务)</li><li>微任务 Promise await async Object.observe MutationObserver process.nextTick(优先级最高)等</li></ul></li><li>主线程先执行，然后微任务</li></ol><hr><h3 id="7、http请求过程"><a href="#7、http请求过程" class="headerlink" title="7、http请求过程"></a>7、http请求过程</h3><ol><li>浏览器输入网址DNS解析得到服务器IP，进行三次握手，建立TCP协议</li><li>客户端web浏览器向服务器发起请求，发送http请求和头信息发送</li><li>服务端应答客户端请求，响应头信息和浏览器所需内容</li><li>根据请求头信息是否包含keep-alive，决定是关闭TCP或保持TCP</li><li>最后客户端web浏览器得到服务端响应的结果</li></ol><hr><h3 id="8、JSBridge原理"><a href="#8、JSBridge原理" class="headerlink" title="8、JSBridge原理"></a>8、JSBridge原理</h3><blockquote><p><strong>&lt;参考: <a href="https://juejin.cn/post/6936814903021797389#heading-4">链接</a>&gt;：</strong></p></blockquote><ol><li>注入API 注入API，是通过WebView，向JavaScript的Context(window)上注入对象或方法，js直接调用注入的方法，即可执行Native的功能</li><li>拦截URL Scheme wx://ht/xxx?data=aa JS发送URL Scheme请求</li><li>重写 prompt 等原生 JS 方法</li></ol><hr><h3 id="9、Vue、React优缺点比较-渲染执行机制-生命周期"><a href="#9、Vue、React优缺点比较-渲染执行机制-生命周期" class="headerlink" title="9、Vue、React优缺点比较 渲染执行机制 生命周期"></a>9、Vue、React优缺点比较 渲染执行机制 生命周期</h3><ol><li>xxx</li></ol><hr><h3 id="10、Vue2和Vue3区别"><a href="#10、Vue2和Vue3区别" class="headerlink" title="10、Vue2和Vue3区别"></a>10、Vue2和Vue3区别</h3><ol><li>vue2的双向数据绑定是利用了es5 的一个API Object.defineProperty() 对数据进行劫持 结合发布订阅模式来实现的。vue3中使用了es6的proxyAPI对数据进行劫持后处理。</li><li>Vue2是Vue.js的早期版本，已经经过多年实践检验，是稳定的版本。Vue3是Vue.js的最新版本，在保留Vue2的优点的同时，提供了更多的新特性和改进。</li><li>Vue2使用虚拟DOM来提高渲染性能，并提供了组件化的开发模式。Vue3在此基础上进一步优化了虚拟DOM的实现，并引入了编译器和运行时编译，使得渲染性能更高、代码更小、更灵活。</li><li>Vue2提供了响应式系统和组件化的开发模式，支持使用插件扩展功能。Vue3在此基础上提供了更多的开发工具，如可观察对象和组件代码分离等，使得开发更快捷、更灵活。</li><li>总的来说，Vue3在保留Vue2的优点的同时，提供了更快的运行速度、更小的体积和更多的灵活性，可以更好地满足开发人员的需求。</li></ol><hr><h3 id="11、React-Fiber原理和作用"><a href="#11、React-Fiber原理和作用" class="headerlink" title="11、React Fiber原理和作用"></a>11、React Fiber原理和作用</h3><ol><li>概念:<ul><li>React Fiber是React执行渲染时的一种新的调度策略，因JavaScript是单线程的，一旦组件开始更新，主线程就一直被React控制，这个时候如果再次执行交互操作，就会容易导致卡顿，React Fiber就是来解决这个问题的</li><li>React Fiber就是通过对象的形式来记录组件上需要做或者已经完成的更新等详细信息，一个组件可以对应多个Fiber</li><li>React Element树在第一次渲染的时候会创建一颗结构一模一样的的Fiber节点树（Fiber是个链表，有child和sibing属性FiberTree）。不同的React Element类型对应不同的Fiber节点类型。一个React Element的工作就由它对应的Fiber节点来负责。</li><li>React Fiber这种方式，渲染过程采用切片的方式，每执行一会儿，就歇一会儿。如果有优先级更高的任务到来以后呢，就会先去执行，降低页面发生卡顿的可能性，使得React对动画等实时性要求较高的场景体验更好。</li></ul></li><li>参考:<ul><li><a href="https://blog.csdn.net/weixin_43606158/article/details/89425297">链接</a></li></ul></li></ol><hr><h3 id="12、React高版本-v-18-新增的方法及作用"><a href="#12、React高版本-v-18-新增的方法及作用" class="headerlink" title="12、React高版本(v.18)新增的方法及作用"></a>12、React高版本(v.18)新增的方法及作用</h3><ol><li>React18 通过其改进的渲染系统带来了<code>并发能力</code>，严格模式更新(更严格)</li><li><code>flushSync</code>函数来强制立即刷新更改(异步变同步)<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; flushSync &#125; <span class="keyword">from</span> <span class="string">&quot;react-dom&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> handleClick = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">flushSync(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">setA(<span class="function"><span class="params">a</span> =&gt;</span> a + <span class="number">1</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// Re-render</span></span><br><span class="line">flushSync(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">setB(<span class="function"><span class="params">b</span> =&gt;</span> b - <span class="number">1</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// Re-render</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li>并发的React, useTransition, 可以使用 useTransition() 钩子来创建一个 transition。这个钩子返回一个函数来启动一个 transition，还有一个挂起的指示器来通知你 transition 的进度。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useTransition, useState &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> App = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> [isPending, startTransition] = useTransition();</span><br><span class="line">    <span class="keyword">const</span> [value, setValue] = useState(<span class="number">0</span>);</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">handleClick</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        startTransition(<span class="function">() =&gt;</span> &#123;</span><br><span class="line"> setValue(<span class="function">(<span class="params">value</span>) =&gt;</span> value + <span class="number">1</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">    &#123;isPending &amp;&amp; <span class="xml"><span class="tag">&lt;<span class="name">Loader</span> /&gt;</span></span>&#125;</span><br><span class="line">        &lt;button onClick=&#123;handleClick&#125;&gt;&#123;value&#125;&lt;/button&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li>Suspense组件等</li></ol><hr><h3 id="13、React-Redux-原理"><a href="#13、React-Redux-原理" class="headerlink" title="13、React Redux 原理"></a>13、React Redux 原理</h3><ol><li>action<ul><li>事件处理函数，有多个</li><li>action 是一个事件处理器，结构可以是switch case的模式 定义数据合成</li><li>store.dispatch() 将 action 传到 store<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; USER_INFO &#125; <span class="keyword">from</span> <span class="string">&quot;../constants/actionTypes&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">&#x27;../store/store&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> switchUser = <span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="params">dispatch</span> =&gt;</span> &#123;</span><br><span class="line"><span class="comment">// do somethings...</span></span><br><span class="line">dispatch(&#123;</span><br><span class="line">type: USER_INFO,</span><br><span class="line">payload: &#123;</span><br><span class="line">...data,</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li>reducer<ul><li>Reducers 指定了应用状态的变化如何响应 actions并发送到 store 的</li><li>reducer函数主要接收2个参数,<code>state</code>和<code>action</code> switch action.type 做出state数据合成并返回处理后的<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; USER_INFO &#125; <span class="keyword">from</span> <span class="string">&quot;../constants/actionTypes&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> redUserInfo = (state = &#123;</span><br><span class="line">userId: <span class="number">1</span>,</span><br><span class="line">userName: <span class="string">&#x27;&#x27;</span></span><br><span class="line">&#125;, action) =&gt; &#123;</span><br><span class="line"><span class="keyword">if</span> (action === <span class="literal">undefined</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> state</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line"><span class="keyword">case</span> USER_INFO:</span><br><span class="line"><span class="keyword">return</span> &#123;</span><br><span class="line">...state,</span><br><span class="line">...action.payload,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> USER_SET:</span><br><span class="line"><span class="keyword">return</span> &#123;</span><br><span class="line">...state,</span><br><span class="line">...action.payload,</span><br><span class="line">set: <span class="literal">true</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">return</span> state</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li>store<ul><li>redux 提供一个 createStore方法 传入 reducers 并返回新的store对象</li><li>code:  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createStore &#125; <span class="keyword">from</span> <span class="string">&#x27;redux&#x27;</span></span><br><span class="line"><span class="keyword">import</span> reducers <span class="keyword">from</span> <span class="string">&#x27;../reducers/index&#x27;</span></span><br><span class="line"><span class="keyword">let</span> store = createStore(reducers, ...initState)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> store</span><br></pre></td></tr></table></figure></li></ul></li><li>Provider<ul><li>Provider 其实就只是一个外层容器，它的作用就是通过配合 connect 来达到跨层级跨组件共享传递数据。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">&#x27;../store/store&#x27;</span></span><br><span class="line">&lt;Provider store=&#123;store&#125;&gt;</span><br><span class="line">&lt;PersistGate loading=&#123;<span class="literal">null</span>&#125; persistor=&#123;persistor&#125;&gt;</span><br><span class="line">&lt;About&gt;&lt;/About&gt;</span><br><span class="line">&lt;/PersistGate&gt;</span><br><span class="line">&lt;/Provider&gt;</span><br></pre></td></tr></table></figure></li></ul></li><li>connect<ul><li>connect 的作用是连接React组件与 Redux store</li><li>它接收上面 Provider 提供的 store 里面的 state 和 dispatch，并返回一个对象，以属性形式传给我们的容器组件的props对象内<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; connect &#125; <span class="keyword">from</span> <span class="string">&#x27;react-redux&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; add, del, switchUser &#125; <span class="keyword">from</span> <span class="string">&#x27;../../store/action/numAction&#x27;</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">About</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line"><span class="keyword">const</span> &#123; add, del, item, switchUser &#125; = props</span><br><span class="line"><span class="keyword">const</span> test = <span class="function">() =&gt;</span> &#123; add(item) &#125;</span><br><span class="line"><span class="keyword">const</span> test1 = <span class="function">() =&gt;</span> &#123; del(item) &#125;</span><br><span class="line"><span class="keyword">return</span> (</span><br><span class="line">&lt;div&gt;</span><br><span class="line">&lt;h3&gt;我是About的内容&lt;/h3&gt;</span><br><span class="line">&lt;div&gt;&#123;item&#125;&lt;/div&gt;</span><br><span class="line">&lt;button onClick=&#123;<span class="function">() =&gt;</span> test()&#125;&gt;</span><br><span class="line">增加</span><br><span class="line">&lt;/button&gt;</span><br><span class="line">&lt;button onClick=&#123;<span class="function">() =&gt;</span> test1()&#125;&gt;</span><br><span class="line">减少</span><br><span class="line">&lt;/button&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> mapStateToProps = <span class="function"><span class="params">state</span> =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">return</span> &#123; <span class="attr">userInfo</span>: &#123; ...state.userInfo &#125; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> mapDispatchToProps = <span class="function"><span class="params">dispatch</span> =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">return</span> &#123;</span><br><span class="line"><span class="function"><span class="title">add</span>(<span class="params">data</span>)</span>&#123; dispatch(add(data)); &#125;,</span><br><span class="line">switchUser: <span class="function"><span class="params">data</span> =&gt;</span> dispatch(switchUser(data));,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> connect(mapStateToProps, mapDispatchToProps)(About);</span><br></pre></td></tr></table></figure></li></ul></li></ol><hr><h3 id="14、发布订阅"><a href="#14、发布订阅" class="headerlink" title="14、发布订阅"></a>14、发布订阅</h3><ol><li>new event() on emit</li><li>…</li></ol><hr><h3 id="15、ES6新增内容"><a href="#15、ES6新增内容" class="headerlink" title="15、ES6新增内容"></a>15、ES6新增内容</h3><ol><li>解构赋值，展开运算符（形参剩余量…rest），默认值定义，Promise异步方案，symbol数据类型，箭头函数</li><li>ES6新增了数组操作方法includes、map、forEach、findIndex、filter、some、every、reduce、</li></ol><hr><h3 id="16、判断当前web环境是否支持某个css属性"><a href="#16、判断当前web环境是否支持某个css属性" class="headerlink" title="16、判断当前web环境是否支持某个css属性"></a>16、判断当前web环境是否支持某个css属性</h3><ol><li>例如 判断是否支持css { position: sticky }<code>CSS.supports(&quot;position&quot;, &quot;sticky&quot;): boolean</code></li><li>…</li></ol><hr><h3 id="17、Map和Object区别"><a href="#17、Map和Object区别" class="headerlink" title="17、Map和Object区别"></a>17、Map和Object区别</h3><ol><li>键的区别(Map可以是任意数据类型，Object只能string，或者symbol)</li><li>…</li></ol><hr><h3 id="18、Map和Set区别"><a href="#18、Map和Set区别" class="headerlink" title="18、Map和Set区别"></a>18、Map和Set区别</h3><ol><li><p>共同点</p><ol><li>它们的内容都是可迭代对象</li><li>都有delete、has、clear等方法</li></ol></li><li><p>不同点</p><ol><li>Map值是双元数组，key可以为任何数据，这点区别于普通Object只能是数字或字符串(Symbol)</li><li>Set值是单个可迭代对象，key = value，因此可以直接add而不需要set(k, v)的方法</li></ol></li></ol><hr><h3 id="19、Js链式调用"><a href="#19、Js链式调用" class="headerlink" title="19、Js链式调用"></a>19、Js链式调用</h3><p>概念: 所谓的链式调用，简单粗暴的讲，就是在一个实例对象调用完一个方法后，在后边可以一直去调用其他方法，例如，<a href="https://so.csdn.net/so/search?q=Promise&spm=1001.2101.3001.7020">Promise</a>.then()的方法就是一个很好的例子，他可以在后边一直的.then下去。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 简单的链式调用 */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="title">constructor</span>(<span class="params">name, age</span>)</span> &#123;</span><br><span class="line">     <span class="built_in">this</span>.name = name</span><br><span class="line">     <span class="built_in">this</span>.age = age</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="title">info</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">     <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;<span class="built_in">this</span>.age&#125;</span>的<span class="subst">$&#123;<span class="built_in">this</span>.name&#125;</span>`</span>);</span><br><span class="line">     <span class="keyword">return</span> <span class="built_in">this</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="title">start</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">     <span class="built_in">console</span>.log(<span class="string">&#x27;开始起床！&#x27;</span>);</span><br><span class="line">     <span class="keyword">return</span> <span class="built_in">this</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="title">eat</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">     <span class="built_in">console</span>.log(<span class="string">&#x27;开始吃饭&#x27;</span>);</span><br><span class="line">     <span class="keyword">return</span> <span class="built_in">this</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="title">school</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">     <span class="built_in">console</span>.log(<span class="string">&#x27;开始上学！&#x27;</span>);</span><br><span class="line">     <span class="keyword">return</span> <span class="built_in">this</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="title">sleep</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">     <span class="built_in">console</span>.log(<span class="string">&#x27;开始睡觉&#x27;</span>);</span><br><span class="line">     <span class="keyword">return</span> <span class="built_in">this</span></span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">const</span> person = <span class="keyword">new</span> Person(<span class="string">&#x27;小红&#x27;</span>, <span class="number">36</span>);</span><br><span class="line"> person.info().start().eat().school().sleep();</span><br><span class="line"> <span class="comment">// 36的小红</span></span><br><span class="line"> <span class="comment">// 开始起床！</span></span><br><span class="line"> <span class="comment">// 开始吃饭</span></span><br><span class="line"> <span class="comment">// 开始上学！</span></span><br><span class="line"> <span class="comment">// 开始睡觉</span></span><br></pre></td></tr></table></figure><p>第二种，异步任务的处理方式</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 如果加上异步代码那该如何实现 */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">People</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">  <span class="comment">// 创建一个数组模拟任务队列</span></span><br><span class="line">  <span class="built_in">this</span>.queue = [];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 用延迟器开启一个事件的总线</span></span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 首次会调用next</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;首次会调用next&#x27;</span>)</span><br><span class="line">    <span class="built_in">this</span>.next();</span><br><span class="line">  &#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将this返回</span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">People.prototype.next = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 将队列中的第一个任务找出</span></span><br><span class="line">  <span class="keyword">const</span> fn = <span class="built_in">this</span>.queue.shift();</span><br><span class="line">  <span class="comment">// 如果有任务的话就进行调用</span></span><br><span class="line">  fn &amp;&amp; fn();</span><br><span class="line">&#125;</span><br><span class="line">People.prototype.sayHello = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> fn = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;您好，我叫&#x27;</span> + <span class="string">&quot; &quot;</span> + <span class="built_in">this</span>.name);</span><br><span class="line">    <span class="built_in">this</span>.next();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 将该任务添加到队列当中</span></span><br><span class="line">  <span class="built_in">this</span>.queue.push(fn);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br><span class="line">People.prototype.eat = <span class="function"><span class="keyword">function</span>(<span class="params">time</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> that = <span class="built_in">this</span>;</span><br><span class="line">  <span class="keyword">const</span> fn = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">`吃饭花费了 <span class="subst">$&#123;time&#125;</span>s`</span>);</span><br><span class="line">      that.next();</span><br><span class="line">    &#125;, time * <span class="number">1000</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  that.queue.push(fn);</span><br><span class="line">  <span class="keyword">return</span> that;</span><br><span class="line">&#125;</span><br><span class="line">People.prototype.taskList = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> fn = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.queue);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">this</span>.queue.push(fn);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> people = <span class="keyword">new</span> People(<span class="string">&#x27;rex&#x27;</span>);</span><br><span class="line">people.sayHello().eat(<span class="number">2</span>).taskList().queue;</span><br></pre></td></tr></table></figure><hr><h3 id="20、Set集合forEach遍历会导致无限循环问题"><a href="#20、Set集合forEach遍历会导致无限循环问题" class="headerlink" title="20、Set集合forEach遍历会导致无限循环问题"></a>20、Set集合forEach遍历会导致无限循环问题</h3><blockquote><p><strong>在调用forEach遍历Set集合的时候，如果其中1个值被删除后又被重新添加到集合,那么该访问会重新再来1次, 形成无限循环</strong></p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>])</span><br><span class="line"><span class="keyword">const</span> newSet = <span class="keyword">new</span> <span class="built_in">Set</span>(set);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(set);</span><br><span class="line"><span class="built_in">console</span>.log(newSet);</span><br><span class="line"></span><br><span class="line">newSet.forEach(<span class="function">(<span class="params">item: key值, index: &lt;索引不是从<span class="number">0</span>开始 而是 === item(key值)&gt;, s: <span class="built_in">Set</span></span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(set);</span><br><span class="line">    <span class="built_in">console</span>.log(item, index, s)</span><br><span class="line">    newSet.delete(<span class="number">2</span>);</span><br><span class="line">    <span class="comment">// newSet.add(2);</span></span><br><span class="line">    newSet.add(<span class="keyword">new</span> <span class="built_in">Date</span>().getTime());</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;我在遍历&#x27;</span>);</span><br><span class="line">&#125;)；</span><br><span class="line"><span class="built_in">console</span>.log(newSet);</span><br><span class="line"><span class="built_in">console</span>.log(set);</span><br></pre></td></tr></table></figure><hr><h3 id="21、Js柯里化"><a href="#21、Js柯里化" class="headerlink" title="21、Js柯里化"></a>21、Js柯里化</h3><blockquote><p><strong>柯里化是一种函数的转换。是指将一个函数从可调用的 <code>f(a, b, c)</code> 转换为 <code>f(a)(b)(c)</code>。</strong></p></blockquote><blockquote><p><strong>解决&lt;参考: <a href="https://blog.csdn.net/shengshengshiwo/article/details/123265644">链接</a>&gt;：</strong></p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//function s(innerVar)&#123;</span></span><br><span class="line">        <span class="comment">//num += innerVar;</span></span><br><span class="line">        <span class="comment">// arguments.callee 是一个指向正在执行的函数的指针，因此可以用它来实现对函数的调用，使用 arguments.callee 代替函数名，可以确保无论怎样调用函数都不会出问题。</span></span><br><span class="line">        <span class="comment">// 注意点: &quot;use strict&quot; 下 不可用 使用下面写的第二种</span></span><br><span class="line">        <span class="comment">//return arguments.callee;</span></span><br><span class="line">    <span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">// 不过，可以使用命名函数表达式来达成相同的结果</span></span><br><span class="line"><span class="comment">// 以上代码创建了一个名为 f()的命名函数表达式，然后将它赋值给变量 s。即便把函数赋值给了另一个变量，作用域内函数的名字 f 仍然有效</span></span><br><span class="line">    <span class="keyword">const</span> s = (<span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">innerVar</span>)</span>&#123;</span><br><span class="line">        num += innerVar;</span><br><span class="line">        <span class="keyword">return</span> f;</span><br><span class="line">    &#125;);</span><br><span class="line">    s.toString = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log( sum(<span class="number">3</span>)(<span class="number">2</span>)(<span class="number">1</span>)(<span class="number">4</span>) );</span><br><span class="line">alert(sum(<span class="number">3</span>)(<span class="number">2</span>)(<span class="number">1</span>)(<span class="number">4</span>));</span><br><span class="line"><span class="built_in">console</span>.log( sum(<span class="number">1</span>) )</span><br><span class="line"><span class="built_in">console</span>.log( sum(<span class="number">1</span>) * <span class="number">1</span> )</span><br></pre></td></tr></table></figure><p>解析:<br>s function 主要用来保存数据的累加 并 返回函数 让其能够继续被调用<br>s.toString 主要用来实现静态方法，能够访问函数内部作用域内的变量(闭包特性)<br>最后返回s方法<br>sum(1) ===&gt; 会把num = 1放到toString中返回，没有调用到s<br>sum(1)(2) ===&gt; 运行了s函数(会把2放到s函数的位参innerVar位置)，然后对num进行累加处理, num = num + innerVar, 且继续返回成可调用的s方法，接着s.toString会返回闭包中的最新num结果，以供静态调用(例如当函数进行比较时运算会调用toString方法，&lt;数据基本类型比较时可能会发生转换, 具体可参考资料&gt;)，例如alert，或者console.log( sum(1)(2) * 1 ) 使之发生数据转换得到静态化的结果值，实现功能</p><hr><h3 id="22、Js函数的指针-this"><a href="#22、Js函数的指针-this" class="headerlink" title="22、Js函数的指针(this)"></a><strong>22、Js函数的指针(this)</strong></h3><blockquote><p><strong>普通函数<function>、箭头函数&lt;()=&gt;{}&gt;的指针</strong></p></blockquote><blockquote><p><strong>1、只有一个参数的时候，参数可以不加小括号，没有参数或2个及以上参数的，必须加上小括号</strong><br><strong>2、返回语句只有一条的时候可以不写{}和return，会自动加上return的，返回多条语句时必须加上{}和return</strong><br><strong>3、箭头函数在返回对象的时候必须在对象外面加上小括号</strong></p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &#x27;use strict&#x27;;</span></span><br><span class="line"><span class="comment">// 1、普通函数this指向：</span></span><br><span class="line"><span class="comment">// 指向它的调用者，如果没有调用者则默认指向Window</span></span><br><span class="line"><span class="comment">// 2、箭头函数指向：</span></span><br><span class="line"><span class="comment">// 指向箭头函数定义的时候所处的对象，而不是其所使用的时候所处的对象，默认指向父级的this</span></span><br><span class="line"><span class="comment">// 综上：箭头函数没有自己的this，它的this是继承来的，默认指向它定义的时候所处的对象</span></span><br><span class="line"><span class="keyword">const</span> fMap = &#123;</span><br><span class="line">    <span class="function"><span class="title">name</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="comment">// this = 对象本身fMap</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>);</span><br><span class="line">&#125;,</span><br><span class="line">    age: <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// this = window</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    sex: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// this =&gt; fMap</span></span><br><span class="line">        <span class="built_in">this</span>.xx = <span class="string">&#x27;xx&#x27;</span>;</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">the4</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="comment">// this =&gt; window</span></span><br><span class="line">            <span class="built_in">console</span>.log(<span class="built_in">this</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">const</span> the5 = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">// this =&gt; sex的this = fMap</span></span><br><span class="line">            <span class="built_in">console</span>.log(<span class="built_in">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        the4();</span><br><span class="line">        the5();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">fMap.name();</span><br><span class="line">fMap.age();</span><br><span class="line">fMap.sex();</span><br><span class="line"><span class="comment">// 定义构造函数 如果函数是构造函数，那this将指的新的对象</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Persion</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// this指向p</span></span><br><span class="line">    <span class="built_in">this</span>.age = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>);</span><br><span class="line">    <span class="built_in">setInterval</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// this 指向Window</span></span><br><span class="line">        <span class="built_in">this</span>.age++;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>);</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">    <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// ★ 箭头函数从自己的作用域链上一层继承的this，所以这个this也指向p</span></span><br><span class="line">        <span class="built_in">this</span>.age++;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>);</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Persion();// this -&gt; window</span></span><br><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> Persion(); <span class="comment">// this =&gt; p;</span></span><br><span class="line">p.name = <span class="string">&#x27;rex&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(p);</span><br></pre></td></tr></table></figure><p><strong>总结:</strong></p><ul><li><p><strong>普通function函数this指向:</strong></p><ul><li>指向它的调用者，如果没有调用者则默认指向Window</li></ul></li><li><p><strong>箭头函数this指向:</strong></p><ul><li>指向箭头函数定义的时候所处的对象(默认指向父级的this)</li><li>如果没有父级程序 或者 父级程序没有指向 箭头函数的this指向是window</li><li>箭头函数没有自己的this，它的this是继承来的</li></ul></li><li><p><strong>箭头函数和普通函数的区别</strong></p><ul><li>箭头函数是匿名函数，普通函数可以是匿名函数也可以是具名函数</li><li>箭头函数不能作为构造函数使用，不能使用new关键字</li><li>箭头函数没有原型，所以没有prototype属性</li><li>call、apply、和bind无法改变箭头函数的this指向，但可以改变普通函数的this指向</li><li>箭头函数没有arguments对象，如果有外层函数，则继承外层函数的arguments，没有外层函数则会报错，箭头函数用的是rest参数（形式为: …rest）</li><li>箭头函数没有Generator，不能使用yield关键字</li><li>箭头函数没有自己的this</li></ul></li></ul><hr><h3 id="23、Vue3-composition-API-组合式API"><a href="#23、Vue3-composition-API-组合式API" class="headerlink" title="23、Vue3 composition API(组合式API)"></a><strong>23、Vue3 composition API(组合式API)</strong></h3><ol><li>类似于React的HOC高阶组件、Hooks</li><li>将组件的功能抽象为函数或对象的形式, 提高组件的可复用性和可维护性</li></ol><hr><h3 id="24、函数式编程"><a href="#24、函数式编程" class="headerlink" title="24、函数式编程"></a><strong>24、函数式编程</strong></h3><ol><li>xxx</li><li>…</li></ol><hr><h3 id="25、CI-CD"><a href="#25、CI-CD" class="headerlink" title="25、CI/CD"></a><strong>25、CI/CD</strong></h3><blockquote><p><strong>代码-编译-多环境测试部署-生产-回滚</strong><br><strong>&lt;参考: <a href="https://blog.csdn.net/pony_maggie/article/details/123762753">链接</a>&gt;：</strong></p></blockquote><ol><li>持续集成(CI)</li><li>持续部署(CD)</li></ol><hr><h3 id="26、DevOps"><a href="#26、DevOps" class="headerlink" title="26、DevOps"></a><strong>26、DevOps</strong></h3><blockquote><p><strong>DevOps是一种思想，是一种文化，主要强调软件开发测试运维的一体化，目标是减少各个部门之间的沟通成本从而实现软件的快速高质量的发布。CI/CD是指持续集成发布部署，是一套流程实现软件的构建测试部署的自动化。DevOps与CICD紧密相关，是理论与实践的结合，DevOps要实现人员一体化，必须要借助CICD工具来自动化整个流程。</strong></p></blockquote><ol><li>xxx</li><li>…</li></ol><hr><h3 id="27、ES6-Class的get-set"><a href="#27、ES6-Class的get-set" class="headerlink" title="27、ES6 Class的get set"></a><strong>27、ES6 Class的get set</strong></h3><blockquote><p><strong>get set static</strong></p></blockquote><p>不要和this.xx重名</p><ol><li>get vars(): string|xx —&gt; 只读 类似于 computed 返回值</li><li>set vars(value): void —&gt; 同computed 可以监听数据变动做出适当的相应</li><li>static method(): void —&gt; 定义静态方法, 不能在类的实例上调用静态方法, 而应该通过类本身调用。</li></ol><hr><h3 id="28、Object-defineProperty"><a href="#28、Object-defineProperty" class="headerlink" title="28、Object.defineProperty"></a><strong>28、Object.defineProperty</strong></h3><ol><li><p><code>Object.defineProperty(对象, &#39;某成员属性&#39;, &#123; ...配置项 &#125;)</code></p></li><li><p>主要配置</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    writable：是否可重写</span><br><span class="line"></span><br><span class="line">    value：  当前值</span><br><span class="line"></span><br><span class="line">    get：     读取时内部调用的函数</span><br><span class="line"></span><br><span class="line">    set：        写入时内部调用的函数</span><br><span class="line"></span><br><span class="line">    enumerable： 是否可以遍历</span><br><span class="line"></span><br><span class="line">    configurable： 是否可再次修改配置项</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><hr><h3 id="29、前端性能优化-多角度"><a href="#29、前端性能优化-多角度" class="headerlink" title="29、前端性能优化(多角度)"></a><strong>29、前端性能优化(多角度)</strong></h3><ol><li>加载优化</li><li>CSS优化</li><li>图片优化</li><li>脚本优化</li><li>渲染优化</li><li>…</li></ol><hr><h3 id="30、SSR-NEXT-js、NUXT-js"><a href="#30、SSR-NEXT-js、NUXT-js" class="headerlink" title="30、SSR(NEXT.js、NUXT.js)"></a><strong>30、SSR(NEXT.js、NUXT.js)</strong></h3><ol><li>Vue、React服务端渲染 Server Side Rendering</li><li>…</li></ol><hr><h3 id="31、算法-冒泡排序"><a href="#31、算法-冒泡排序" class="headerlink" title="31、算法: 冒泡排序"></a><strong>31、算法: 冒泡排序</strong></h3><ol><li>xxx</li><li>…</li></ol><hr><h3 id="32、求2个数组之间的【交集】【并集】【差集】"><a href="#32、求2个数组之间的【交集】【并集】【差集】" class="headerlink" title="32、求2个数组之间的【交集】【并集】【差集】"></a><strong>32、求2个数组之间的【交集】【并集】【差集】</strong></h3><ol><li>xxx</li><li>…</li></ol><hr><h3 id="33、Webpack、Vite、Rollup工作原理"><a href="#33、Webpack、Vite、Rollup工作原理" class="headerlink" title="33、Webpack、Vite、Rollup工作原理"></a><strong>33、Webpack、Vite、Rollup工作原理</strong></h3><ol><li><p>Webpack 需要查找依赖，打包所有的模块，然后才能提供服务，更新速度会随着代码体积增加越来越慢</p><ol><li>解析入口文件搜集依赖形成抽象语法关系树AST</li><li>接着解析AST加载模块，根据不同模块使用加载器进行处理</li><li>编译模块，变成可执行的js代码</li><li>打包输出(1或者多个文件 可以是css、js、等)</li><li>优化和插件系统(混淆、加密等)</li></ol></li><li><p>Vite 使用原生 ESModule 通过 script 标签动态导入，访问页面的时候加载到对应模块编译并响应</p></li><li><p>项目打包的时候最终还是需要打包成静态资源的，打包工具 Rollup</p></li></ol><hr><h3 id="34、React组件重新渲染-刷新"><a href="#34、React组件重新渲染-刷新" class="headerlink" title="34、React组件重新渲染(刷新)"></a><strong>34、React组件重新渲染(刷新)</strong></h3><blockquote><p><strong>&lt;参考: <a href="https://juejin.cn/post/7068170055111933989">链接</a>&gt;：</strong></p></blockquote><ol><li><p>类组件 <code>this.forceUpdate();</code></p></li><li><p>功能组件 函数组件:</p><ol><li><p>调用App.render</p></li><li><p>用自己的新实例替换状态对象<code>setUser(&#123; ...user &#125;);</code></p></li><li><p>让一个空的状态变量触发更新</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [, updateState] = React.useState();</span><br><span class="line"><span class="keyword">const</span> forceUpdate = React.useCallback(<span class="function">() =&gt;</span> updateState(&#123;&#125;), []);</span><br></pre></td></tr></table></figure></li></ol></li></ol><hr><h3 id="35、Keep-alive-缓存组件的一种解决方案"><a href="#35、Keep-alive-缓存组件的一种解决方案" class="headerlink" title="35、Keep-alive 缓存组件的一种解决方案"></a><strong>35、Keep-alive 缓存组件的一种解决方案</strong></h3><blockquote><p><strong>&lt;参考: <a href="https://blog.csdn.net/m0_54364474/article/details/125034224">链接</a>&gt;：</strong></p></blockquote><ol><li><p>vue 内置组件 keep-alive动态缓存方案</p></li><li><p>在组件切换过程中将<strong>状态保留在内存中</strong>，<strong>防止重复渲染DOM</strong>，减少加载时间及性能消耗，提高用户体验性</p></li><li><p>keep-alive包裹动态组件时，会<strong>缓存不活动的组件实例</strong>，而不是<strong>销毁</strong>它们。一般用法为下</p></li><li><p>例如路由，按需设置，性能达到最为均衡的状态</p></li><li><p>可以结合router来处理路由页面的缓存，在router中设置router的元信息meta : keepAlive: true</p><ul><li><code>&lt;keep-alive&gt;</code> 包裹组件(路由) 进行缓存<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;keep-alive&gt;</span><br><span class="line">&lt;router-view v-<span class="keyword">if</span>=<span class="string">&quot;$route.meta.keepAlive&quot;</span>&gt;&lt;/router-view&gt;</span><br><span class="line">&lt;/keep-alive&gt;</span><br><span class="line"><span class="comment">// 这里不需要缓存</span></span><br><span class="line">&lt;router-view v-<span class="keyword">if</span>=<span class="string">&quot;!$route.meta.keepAlive&quot;</span>&gt;&lt;/router-view&gt;</span><br></pre></td></tr></table></figure></li><li>路由配置<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    path:&quot;/list&quot;,</span><br><span class="line">    component:HomeBookList,</span><br><span class="line">    meta: &#123;</span><br><span class="line">    keepAlive: true // 需要缓存</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ol><ol start="6"><li><p>keep-alive支持三个属性，分别是</p><ol><li>include - 字符串或正则表达式。只有名称匹配的组件会被缓存。</li><li>exclude - 字符串或正则表达式。任何名称匹配的组件都不会被缓存。</li><li>max - 数字。最多可以缓存多少组件实例。</li></ol></li><li><p>通过设置: include = 变量数组, 然后监听路由 watch(to, from)，判断去到指定的路由的时候，改变这个变量数组，去掉缓存即可，</p></li><li><p>keep-alive 中创建的组件，会多出两个生命周期的钩子: <strong>activated</strong> 与 <strong>deactivated</strong></p><ol><li><strong>activated</strong>在缓存组件激活时调用</li><li><strong>deactivated</strong>在缓存组件失活时调用，取代原本的<strong>destroyed</strong></li></ol></li></ol><hr><h3 id="36、路由守卫"><a href="#36、路由守卫" class="headerlink" title="36、路由守卫"></a><strong>36、路由守卫</strong></h3><ol><li><strong>全局守卫</strong> router/index.js<ol><li>router.beforeEach(to, from, next) <strong>全局前置</strong>路由守卫，每次路由切换之前被调用，可以做**权限拦截 **需要调用next()</li><li>router.afterEach(to, from) <strong>全局后置</strong>路由守卫，每次路由切换之后调用,注意没有<strong>next</strong> 可用于切换<strong>document.title</strong></li><li>router.beforeResolve 和 beforeEach类似 也属于<strong>全局守卫</strong> 区别是 在<strong>所有组件内守卫</strong>和<strong>异步路由组件被解析之后</strong> <strong>导航确认之前</strong> 会调用</li></ol></li><li><strong>独享守卫</strong> router/index.js<ol><li>router.beforeEnter(to, from, next)针对某个路由单独设置的守卫 <strong>独享路由</strong>守卫，只有前置，没有后置，写<strong>在routes配置项里</strong>，路由进入之前会调用</li></ol></li><li><strong>组件内守卫</strong> Demo.vue<ol><li>router.beforeRouteEnter(to, from, next) 在渲染该组件的对应路由被 confirm 前调用 <strong>不可以访问本组件this对象</strong> 但是可以在<strong>next回调首个形参里面得到vm来访问this</strong>, 然后可以return false 来做拦截</li><li>router.beforeRouteUpdate(to, from, next) 在当前路由改变，且该组件<strong>被复用</strong>时调用 eg:  /item/:id 之间跳转的时候 会被调用 切换路由动态参数的时候</li><li>router.beforeRouteLeave(to, from, next) 导航<strong>离开该组件</strong>的对应路由时调用</li></ol></li></ol><hr><h3 id="37、闭包"><a href="#37、闭包" class="headerlink" title="37、闭包"></a><strong>37、闭包</strong></h3><ol><li><p>什么是「闭包」。</p><ul><li><strong>「函数」和「函数内部能访问到的变量」的总和，就是一个闭包。</strong></li></ul></li><li><p>「闭包」的作用是什么。</p><ul><li><strong>可以用来封装插件、柯里化…</strong></li></ul></li><li><p>闭包副作用</p><ol><li>内存泄漏 -&gt; 坑没空着的了</li><li>内存溢出(扩展内容非闭包导致) -&gt; 一个坑2个人爆炸了</li></ol></li></ol><hr><h3 id="38、JavaScript中window-onload和document-onload有什么区别？"><a href="#38、JavaScript中window-onload和document-onload有什么区别？" class="headerlink" title="38、JavaScript中window.onload和document.onload有什么区别？"></a><strong>38、JavaScript中window.onload和document.onload有什么区别？</strong></h3><p><strong>&lt;参考: <a href="https://zh.javascript.info/onload-ondomcontentloaded">链接</a>&gt;：</strong></p><ol><li><p>document.onload</p><ul><li><strong>在加载图像和其他外部内容之前将其触发。文件。在window.onload之前触发onload事件。</strong></li></ul></li><li><p>window.onload</p><ul><li><strong>加载整个页面（包括图像，脚本，css等）完成时，它将被触发。</strong></li></ul></li><li><p>$(document).ready() || DOMContentLoaded</p><ul><li><strong>当页面 DOM 加载完成后，ready() 里的函数便会立即执行</strong></li></ul></li><li><p>document.onload 和 document.ready</p><ol><li>onload 文档元素加载完毕后执行 只能执行一次 会覆盖 需要等待所有资源全部加载完成，</li><li>ready 或者 DOMContentLoaded 不会覆盖 都会执行 执行顺序在load之前，只需等待DOM树结构完成 即可触发</li></ol></li><li><p>document.body.onload</p><ol><li>需要在body标签内引用才有效，body内容加载完成</li></ol></li><li><p>总结:</p><ol><li><strong>使用window.onload 和 DOMContentLoaded 即可</strong></li><li><strong>DOMContentLoaded - load - beforeunload - unload</strong></li><li><strong>DOMContentLoaded 只能用 addEventListener</strong></li></ol></li></ol><hr><h3 id="39、JavaScript中事件委托-代理-的作用-JQ-bind和on的区别-addEventListener和普通on区别-捕获顺序-冒泡顺序-怎么取消冒泡"><a href="#39、JavaScript中事件委托-代理-的作用-JQ-bind和on的区别-addEventListener和普通on区别-捕获顺序-冒泡顺序-怎么取消冒泡" class="headerlink" title="39、JavaScript中事件委托(代理)的作用 JQ bind和on的区别 addEventListener和普通on区别 捕获顺序 冒泡顺序 怎么取消冒泡"></a><strong>39、JavaScript中事件委托(代理)的作用 JQ bind和on的区别 addEventListener和普通on区别 捕获顺序 冒泡顺序 怎么取消冒泡</strong></h3><blockquote><p><strong>事件委托是利用事件冒泡，只指定一个事件处理程序来管理某一类型的所有事件</strong></p></blockquote><ol><li><p>delegate 执行事件委托 指定元素类型</p><ul><li>ul.delegate(li, clickFunc)</li></ul></li><li><p>bind不能给不存在的元素绑定例如click事件 on可以代理也可以给未来的元素添加 bind只能给符合条件的元素本身添加事件</p></li><li><p>捕获行为是由上往下，而冒泡阶段是自下往上</p></li><li><p>事件流的三个阶段：冒泡阶段、捕获阶段、目标阶段</p></li><li><p>on会被覆盖 addEventListener(&gt;=IE9) 不会被覆盖</p></li></ol><hr><h3 id="40、Webpack、Vite-工作流程"><a href="#40、Webpack、Vite-工作流程" class="headerlink" title="40、Webpack、Vite 工作流程"></a><strong>40、Webpack、Vite 工作流程</strong></h3><ol><li>xxx</li><li>…</li></ol><hr><h3 id="41、Js-call-apply-bind-区别"><a href="#41、Js-call-apply-bind-区别" class="headerlink" title="41、Js call apply bind 区别"></a><strong>41、Js call apply bind 区别</strong></h3><ol><li>xxx</li><li>…</li></ol><hr><h3 id="42、Vue代码优化-下文续有性能优化"><a href="#42、Vue代码优化-下文续有性能优化" class="headerlink" title="42、Vue代码优化(下文续有性能优化)"></a><strong>42、Vue代码优化(下文续有性能优化)</strong></h3><ol><li>Object.freeze()</li><li>减少ES6代码，降低webpack编译的代码量</li></ol><hr><h3 id="43、flex布局、多端兼容、响应式布局"><a href="#43、flex布局、多端兼容、响应式布局" class="headerlink" title="43、flex布局、多端兼容、响应式布局"></a><strong>43、flex布局、多端兼容、响应式布局</strong></h3><ol><li><p>rem原理 计算方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> b = <span class="built_in">window</span>.devicePixelRatio<span class="comment">//dpr</span></span><br><span class="line"><span class="keyword">const</span> c = <span class="string">&#x27;某个自己设置的值，我们公司为375px&#x27;</span> <span class="comment">//切图稿的统一宽度</span></span><br><span class="line"><span class="keyword">const</span> d = <span class="built_in">document</span>.documentElement.clientWidth<span class="comment">//视口宽度</span></span><br><span class="line"><span class="keyword">const</span> e = <span class="string">&#x27;某个自己设置的值，我们公司为37.5px&#x27;</span> <span class="comment">//根元素font-size大小</span></span><br></pre></td></tr></table></figure><p>第一种方法是将px转化成rem再除以e</p><p>第二种方法非要用px作单位的话就把值除以c再乘以d</p></li></ol><ol start="2"><li>webpack 插件 <code>npm install px2rem-loader lib-flexible --save-dev</code></li></ol><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  module: &#123;</span><br><span class="line">    rules: [&#123;</span><br><span class="line">      test: /\.less$/,</span><br><span class="line">      use: [&#x27;style-loader&#x27;, &#x27;css-loader&#x27;, &#x27;less-loader&#x27;, &#123;</span><br><span class="line">        loader: &#x27;px2rem-loader&#x27;,</span><br><span class="line">        options: &#123;</span><br><span class="line">          remUni: 75, // 适合750的设计稿 1rem = 75px</span><br><span class="line">          remPrecision: 8 // px转rem小数点保留的位置</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;]</span><br><span class="line">    &#125;]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在项目中引入lib-flexible</p><p><code>&lt;script src=&quot;lib-flexible/flexible.js&quot;&gt;&lt;/script&gt;</code></p><p>lib-flexible应最早执行</p><p>这样就可以实现PX到REM单位的自动转化了~</p><ol start="3"><li>rem 计算原理:<ol><li><code>const w = 计算当前视口宽度(document.documentElement.clientWidth) eg: 375px </code></li><li><code>const designWidth = 750px</code></li><li><code>const dzr = w / designWidth eg: 0.5 // 设备缩放比</code></li><li>给html设置font-size = dzr =&gt; // 0.5</li><li>设计图 10px =&gt; 10px * dzr = 5px</li><li>设计图 12px =&gt; 12px * dzr = 6px</li><li>dzr = 0.3</li><li>设计图 *<em>12px =&gt; 12px * 0.3 = 3.6px*</em></li><li>非常不好计算, 因此可以在初始的时候 放大100倍 利于计算</li><li>给html设置font-size = dzr * 100 = 30px</li><li>设计图 <strong>12px =&gt; 12px * 0.3 * 100 = 360px</strong></li><li>1rem = 0.3 x 100 x 1px = 300px</li><li>12px = (1rem / 100) * 12</li><li>0.12rem</li><li>总结: 先计算1个单位像素的比例 html: 1个单位 = 缩放比，1rem = 缩放比 x 单位量</li><li>但是方便计算 会倍率 否则rem: 0.3 x 12px，不利于计算</li><li>因此先x100 html set 缩放比*100 再除100 就是 rem: 1个html x 12 相当于12个单位的量</li><li>rem = 12 / 100 = 0.12rem 因为整体x了100倍 所以直接除以100即可</li></ol></li></ol><hr><h3 id="44、created、mounted和this-nextTick-的区别"><a href="#44、created、mounted和this-nextTick-的区别" class="headerlink" title="44、created、mounted和this.$nextTick()的区别"></a><strong>44、created、mounted和this.$nextTick()的区别</strong></h3><ol><li>created: 页面渲染成htlm之前运行 可以做一些初始化操作 生命周期运行1次</li><li>mounted: 页面渲染成html后运行 可以操作一些静态dom元素 生命周期运行1次</li><li>this.$nextTick(fn) fn中可以对动态dom进行操作 生命周期运行多次</li></ol><hr><h3 id="45、浏览器垃圾回收的基本算法"><a href="#45、浏览器垃圾回收的基本算法" class="headerlink" title="45、浏览器垃圾回收的基本算法"></a><strong>45、浏览器垃圾回收的基本算法</strong></h3><ol><li>引用计数法，为0时，释放 有缺陷: 互为引用</li><li>标记清除法，先<strong>标记</strong> 后 <strong>回收</strong>, 从<strong>根部</strong>[globalThis]找有无使用处，无则回收</li></ol><hr><h3 id="46、vue2性能优化"><a href="#46、vue2性能优化" class="headerlink" title="46、vue2性能优化"></a><strong>46、vue2性能优化</strong></h3><blockquote><p><strong>解决&lt;参考: <a href="https://blog.csdn.net/pzy_666/article/details/122775331">链接</a>&gt;：</strong></p></blockquote><ol><li>Deferred 延迟 分批渲染</li><li>xxx</li></ol><hr><h3 id="47、websocket"><a href="#47、websocket" class="headerlink" title="47、websocket"></a><strong>47、websocket</strong></h3><ol><li>soket.io</li><li>xxx</li></ol><hr><h3 id="48、Web-Worker"><a href="#48、Web-Worker" class="headerlink" title="48、Web Worker"></a><strong>48、Web Worker</strong></h3><ol><li>浏览器提供的一种通信方式(API)，由主线程main script 和 worker script进行通信的 有利于性能提升</li><li>xxx</li></ol><hr><h3 id="49、算法"><a href="#49、算法" class="headerlink" title="49、算法"></a><strong>49、算法</strong></h3><ol><li>二分法排序</li><li>冒泡排序</li><li>xxx</li></ol><hr><h3 id="50、原型链的理解"><a href="#50、原型链的理解" class="headerlink" title="50、原型链的理解"></a><strong>50、原型链的理解</strong></h3><ol><li>原型链的理解prototype</li><li>xxx</li></ol><hr><h3 id="51、Vue组件重新渲染-刷新"><a href="#51、Vue组件重新渲染-刷新" class="headerlink" title="51、Vue组件重新渲染(刷新)"></a><strong>51、Vue组件重新渲染(刷新)</strong></h3><ol><li>:key 更改会刷新</li><li>v-if 会刷新</li><li>main.js 使用 Vue.forceUpdate()后 组件中使用this.$forceUpdate</li><li>刷新页面有路由的话 刷当前 this.$router.go(0)、 返回上一页 go(-1) 去另外的路由页 push(‘/login’) 或 push({ name: ‘login’ })</li></ol><hr><h3 id="52、在多个文件中import同一个文件，webpack会多次打包吗"><a href="#52、在多个文件中import同一个文件，webpack会多次打包吗" class="headerlink" title="52、在多个文件中import同一个文件，webpack会多次打包吗"></a><strong>52、在多个文件中import同一个文件，webpack会多次打包吗</strong></h3><ol><li>不会</li><li>不同文件中多次import同一个文件，webpack并不会多次打包，只会在打包后的文件中会多次引用打包后的该文件对应的函数。</li><li><a href="https://segmentfault.com/a/1190000008521430">参考</a></li></ol><hr><h3 id="53、React高阶组件HOC"><a href="#53、React高阶组件HOC" class="headerlink" title="53、React高阶组件HOC"></a><strong>53、React高阶组件HOC</strong></h3><ol><li>实际上就是一个函数或者一个类 接收一个组件作为参数 然后生成新的组件 其中包含了参数组件体</li><li>…</li></ol><hr><h3 id="54、TypeScript中type与interface的区别"><a href="#54、TypeScript中type与interface的区别" class="headerlink" title="54、TypeScript中type与interface的区别"></a><strong>54、TypeScript中type与interface的区别</strong></h3><ol><li><p><code>interface</code>用于定义一个新的对象的结构跟类型<br><code>type</code>用于给一个已存在的对象取名或者赋予别名</p></li><li><p><code>interface</code>可以重复定义一个对象，最终的结果是合集的状态</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Person &#123;</span><br><span class="line">  name: <span class="built_in">string</span></span><br><span class="line">  age: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Person &#123;</span><br><span class="line">  address: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Person2 = &#123;</span><br><span class="line">  name: <span class="built_in">string</span></span><br><span class="line">  age: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Person3 = Person2 &amp; &#123;</span><br><span class="line">  address: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>type可以定义联合类型，比如:</p></li></ol><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> language = <span class="string">&#x27;cn&#x27;</span>|<span class="string">&#x27;en&#x27;</span>|<span class="string">&#x27;jp&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="55、JWT是什么"><a href="#55、JWT是什么" class="headerlink" title="55、JWT是什么?"></a><strong>55、JWT是什么?</strong></h3><ol><li>是一种用于在前端web端进行认证和授权的令牌机制、在前端存储传递 json web tokens 来实现用户身份校验和访问控制</li><li>header、payload、signature，三段式.隔开</li><li>http请求头可带上、cookie也可以带上、?token也可带上</li></ol><h3 id="56、简述HTTP"><a href="#56、简述HTTP" class="headerlink" title="56、简述HTTP"></a><strong>56、简述HTTP</strong></h3><ol><li>主要分为以下7步骤：DNF-&gt;IP 建立TCP、发起请求、服务端接收处理请求、服务端返回结果、客户端接收结果、客户端处理结果、关闭连接，复杂情况还需要加上重定向等</li><li>三次握手 1客户端发给服务端带有一把确认的钥匙，2服务端收到了你的钥匙并给你客户端发起一个确认，3.客户端从服务端得到了钥匙的确认信息</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前端技术总结罗列-持续更新中…&quot;&gt;&lt;a href=&quot;#前端技术总结罗列-持续更新中…&quot; class=&quot;headerlink&quot; title=&quot;前端技术总结罗列(持续更新中…)&quot;&gt;&lt;/a&gt;前端技术总结罗列(持续更新中…)&lt;/h2&gt;&lt;h3 id=&quot;1、localStor</summary>
      
    
    
    
    <category term="大前端" scheme="https://blog.rexhang.com/categories/%E5%A4%A7%E5%89%8D%E7%AB%AF/"/>
    
    <category term="面试经" scheme="https://blog.rexhang.com/categories/%E5%A4%A7%E5%89%8D%E7%AB%AF/%E9%9D%A2%E8%AF%95%E7%BB%8F/"/>
    
    
    <category term="javascript" scheme="https://blog.rexhang.com/tags/javascript/"/>
    
    <category term="前端技术" scheme="https://blog.rexhang.com/tags/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>如何编写web前端开发岗简历</title>
    <link href="https://blog.rexhang.com/2022/12/15/articles/2/"/>
    <id>https://blog.rexhang.com/2022/12/15/articles/2/</id>
    <published>2022-12-15T04:10:01.000Z</published>
    <updated>2022-12-15T03:16:34.572Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><strong>如何编写web前端开发岗简历</strong></p></blockquote><ol><li><strong>编写简历时，首先要包括你的个人信息，包括姓名、联系方式、电子邮箱和地址。接下来，你可以简要介绍你的教育背景和工作经验。</strong></li><li><strong>在简历中提及你对 Web 前端开发的经验。你可以提到你掌握的主要技术，例如 HTML、CSS 和 JavaScript，并列出你的项目经验。此外，你还可以提到你对用户体验和交互设计的兴趣和经验。</strong></li><li><strong>另外，你可以在简历中提到你的专业技能和特长，例如掌握的其他编程语言和框架，或者对数据分析和可视化的经验。这些内容可以帮助雇主了解你的能力，并决定是否与你进一步沟通。</strong></li><li><strong>最后，你可以在简历中列出你的证书和荣誉，以及参加过的培训和活动。这些内容有助于雇主了解你的专业知识和技能水平，并评估你是否符合他们的招聘标准。</strong></li><li><strong>总之，在编写简历时，要注意清晰、简洁、准确地展示你的个人信息和专业技能，以便雇主能够快速了解你，并决定是否与你进一步沟通</strong></li></ol><hr><ol><li><strong>个人信息，包括姓名、电话号码、电子邮件地址和社交媒体链接。</strong></li><li><strong>教育经历，包括毕业院校、学位和专业。</strong></li><li><strong>工作经历，包括公司名称、职位名称和工作描述。</strong></li><li><strong>技能清单，包括掌握的语言、框架和工具。</strong></li><li><strong>项目经验，包括项目名称、描述和贡献。</strong></li><li><strong>证书或其他资格证明。</strong></li></ol><p><strong>编写简历时，要尽量详细且简洁，将你的能力和经验介绍给招聘方。为了让你的简历更加出色，还可以添加下列内容：</strong></p><ol><li><strong>个人简介，包括你的专业方向、兴趣爱好和个人特点。</strong></li><li><strong>其他语言能力，如果你会一种或多种外语，可以在简历中提及。</strong></li><li><strong>兴趣爱好或个人项目，如果你有一些有趣的兴趣爱好或个人项目，可以在简历中提及。</strong></li></ol><p><strong>总之，编写简历时要注意交代清楚你的能力和经验，并以简洁易读的方式展现出来。</strong></p><hr><ol><li><strong>编写一份web前端开发岗简历，首先应该包含您的个人信息，包括姓名、联系方式和电子邮件地址。接下来，应该概述您的专业技能和工作经验，并突出您在web前端开发方面的专业知识和经验。</strong></li><li><strong>在描述您的专业技能时，应该清楚地说明您掌握的技术和工具，例如HTML、CSS、JavaScript、jQuery、Bootstrap等。此外，还应该简要说明您了解的开发框架和库，例如React、Vue、Angular等。</strong></li><li><strong>在描述您的工作经验时，应该简要介绍您曾经参与的项目，包括项目的主要功能、您负责的工作内容和您贡献的主要技术。此外，还应该提及您的工作态度和工作能力，例如认真负责、注重团队合作、熟练掌握代码调试等。</strong></li><li><strong>在编写完简历之后，应该仔细检查语法和拼写错误，并确保简历内容简洁明了，表达出您的专业知识和工作经验。此外，还应该考虑简历的整体布局和设计，以确保简历能够吸引招聘方的眼球。</strong></li></ol><hr><ol><li><strong>在简历开头写明自己的个人信息，包括姓名、电话号码、电子邮件地址、个人网站等。</strong></li><li><strong>接下来，写出自己的教育背景，包括所就读的大学和专业。如果有相关的证书或培训课程，也可以在这一部分提及。</strong></li><li><strong>在工作经验部分，按照时间倒序列出自己的工作经历。对于每个工作经历，可以描述工作内容、工作职责和所取得的成就。</strong></li><li><strong>在技能部分，列出自己在web前端开发方面的技能，包括熟悉的编程语言、框架和工具。还可以提及自己对用户体验和可用性的关注程度。</strong></li><li><strong>在简历末尾，可以附上作品集，展示自己在web前端开发方面的能力。这一部分可以包括项目链接、设计稿和截图等。</strong></li><li><strong>在简历最后，可以写一段自荐信，介绍自己的工作理念和为公司所做的贡献。</strong></li></ol><p><strong>总的来说，编写web前端开发岗简历时，应该注重个人信息的准确性、工作经历的详实性</strong></p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;如何编写web前端开发岗简历&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;编写简历时，首先要包括你的个人信息，包括姓名、联系方式、电子邮箱和地址。接下来，你可以简要介绍你的教育背景和工作经</summary>
      
    
    
    
    <category term="面试经" scheme="https://blog.rexhang.com/categories/%E9%9D%A2%E8%AF%95%E7%BB%8F/"/>
    
    <category term="前端" scheme="https://blog.rexhang.com/categories/%E9%9D%A2%E8%AF%95%E7%BB%8F/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="JavaScript" scheme="https://blog.rexhang.com/categories/%E9%9D%A2%E8%AF%95%E7%BB%8F/%E5%89%8D%E7%AB%AF/JavaScript/"/>
    
    
    <category term="面试经" scheme="https://blog.rexhang.com/tags/%E9%9D%A2%E8%AF%95%E7%BB%8F/"/>
    
    <category term="前端" scheme="https://blog.rexhang.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="JavaScript" scheme="https://blog.rexhang.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>json-server的使用(接口数据mock好帮手)</title>
    <link href="https://blog.rexhang.com/2022/12/15/articles/1/"/>
    <id>https://blog.rexhang.com/2022/12/15/articles/1/</id>
    <published>2022-12-15T04:00:20.000Z</published>
    <updated>2022-12-15T03:16:34.572Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><blockquote><p>json-server: 接口数据mock好帮手</p></blockquote><p>新建文件&lt;db.json&gt;, 内容如下:</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;posts&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">&quot;id&quot;</span>: <span class="number">1</span>,</span><br><span class="line">            <span class="attr">&quot;title&quot;</span>: <span class="string">&quot;json-server&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;author&quot;</span>: <span class="string">&quot;typicode&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">&quot;comments&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">&quot;id&quot;</span>: <span class="number">1</span>,</span><br><span class="line">            <span class="attr">&quot;body&quot;</span>: <span class="string">&quot;some comment&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;postId&quot;</span>: <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">&quot;profile&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;typicode&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;users&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">&quot;id&quot;</span>: <span class="number">1</span>,</span><br><span class="line">            <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;rexhang&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;guid&quot;</span>: <span class="string">&quot;ee7a6768-bb2c-423c-ac06-5c7905c035b5&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;time&quot;</span>: <span class="string">&quot;Wed, 14 Dec 1970 13:20:02 GMT&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p>安装&amp;启动</p><ol><li><p><code>npm install -g json-server</code></p></li><li><p>默认启动在<strong>localhost:3000</strong>端口，<strong>参数</strong>: 可以监听文件变化 <strong>–watch</strong>, 可以指定端口号 <strong>–port</strong>, 可以指定host <strong>–host</strong></p></li><li><p><code>json-server --watch db.json --port 8111 --host 127.0.0.1</code></p></li><li><p>然后会以<strong>JSON成员</strong>为键名，生成若干个请求地址，<a href="http://127.0.0.1:8111/JSON_KEY">http://127.0.0.1:8111/JSON_KEY</a></p></li></ol></li><li><p>请求方法(实现CURD) with <a href="https://marketplace.visualstudio.com/items?itemName=humao.rest-client"><strong>REST Client(Ext)</strong></a> -&gt; <a href="https://github.com/Huachao/vscode-restclient"><strong>直达官网</strong></a></p><ol><li><p><strong>Create</strong></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">###</span><br><span class="line">POST http://127.0.0.1:8111/users</span><br><span class="line">content-type: application/json</span><br><span class="line">   </span><br><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;rexhang&quot;,</span><br><span class="line">  &quot;guid&quot;: &quot;&#123;&#123;$guid&#125;&#125;&quot;,</span><br><span class="line">  &quot;time&quot;: &quot;&#123;&#123;$datetime rfc1123|iso8601&#125;&#125;&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>Update</strong></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">###</span><br><span class="line">PATCH http://127.0.0.1:8111/users/1</span><br><span class="line">content-type: application/json</span><br><span class="line">   </span><br><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;rexhang&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>Read</strong></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">###</span><br><span class="line">GET http://127.0.0.1:8111/profile</span><br></pre></td></tr></table></figure><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">###</span><br><span class="line">GET http://127.0.0.1:8111/users</span><br><span class="line">?id=1</span><br><span class="line">&amp;name=rexhang</span><br></pre></td></tr></table></figure></li><li><p><strong>Delete</strong></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">###</span><br><span class="line">DELETE http://127.0.0.1:8111/users/1</span><br></pre></td></tr></table></figure></li></ol></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;json-server: 接口数据mock好帮手&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;新建文件&amp;lt;db.</summary>
      
    
    
    
    <category term="前端" scheme="https://blog.rexhang.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="开发工具" scheme="https://blog.rexhang.com/categories/%E5%89%8D%E7%AB%AF/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"/>
    
    <category term="node" scheme="https://blog.rexhang.com/categories/%E5%89%8D%E7%AB%AF/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/node/"/>
    
    
    <category term="开发工具" scheme="https://blog.rexhang.com/tags/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"/>
    
    <category term="devtools" scheme="https://blog.rexhang.com/tags/devtools/"/>
    
    <category term="node" scheme="https://blog.rexhang.com/tags/node/"/>
    
  </entry>
  
  <entry>
    <title>使用mask实现视频弹幕人物遮罩过滤，就是牛逼</title>
    <link href="https://blog.rexhang.com/2022/09/30/articles/2/"/>
    <id>https://blog.rexhang.com/2022/09/30/articles/2/</id>
    <published>2022-09-30T08:17:28.000Z</published>
    <updated>2022-10-25T14:41:49.323Z</updated>
    
    <content type="html"><![CDATA[<p>经常看一些<a href="https://lol.qq.com/">LOL</a>比赛直播的小伙伴，肯定都知道，在一些弹幕网站（<a href="https://www.bilibili.com/">Bilibili</a>、<a href="https://www.huya.com/">虎牙</a>）中，当人物与弹幕出现在一起的时候，弹幕会“巧妙”的躲到人物的下面，看着非常的智能。</p><p>简单的一个截图例子：</p><p><img src="/images/blog/2022-09-30/1.webp#pic_center" alt="图片" title="图片"></p><p>其实，这里是运用了 CSS 中的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/mask">mask</a> 属性实现的。</p><h4 id="mask-简单用法介绍"><a href="#mask-简单用法介绍" class="headerlink" title="mask 简单用法介绍"></a>mask 简单用法介绍</h4><hr><p>这里只简单介绍下 mask 的基本用法：</p><p>最基本，使用 mask 的方式是借助图片，类似这样：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="comment">/* Image values */</span></span><br><span class="line"><span class="attribute">mask</span>: <span class="built_in">url</span>(mask.png);                       <span class="comment">/* 使用位图来做遮罩 */</span></span><br><span class="line"><span class="attribute">mask</span>: <span class="built_in">url</span>(masks.svg#star);                 <span class="comment">/* 使用 SVG 图形中的形状来做遮罩 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，使用图片的方式后文会再讲。借助图片的方式其实比较繁琐，因为我们首先还得准备相应的图片素材，除了图片，mask 还可以接受一个类似 background 的参数，也就是渐变。</p><p>类似如下使用方法：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="attribute">mask</span>: <span class="built_in">linear-gradient</span>(#<span class="number">000</span>, transparent)                      <span class="comment">/* 使用渐变来做遮罩 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那该具体怎么使用呢？一个非常简单的例子，上述我们创造了一个从黑色到透明渐变色，我们将它运用到实际中，代码类似这样：</p><p>下面这样一张图片，<strong>叠加上一个从透明到黑色的渐变</strong>，</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="attribute">background</span>: <span class="built_in">url</span>(image.png) ;</span><br><span class="line"><span class="attribute">mask</span>: <span class="built_in">linear-gradient</span>(<span class="number">90deg</span>, transparent, #fff);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/blog/2022-09-30/2.webp#pic_center" alt="图片" title="图片"></p><p>应用了 mask 之后，就会变成这样：</p><p><img src="/images/blog/2022-09-30/3.webp#pic_center" alt="图片" title="图片"></p><p>这个 DEMO，可以先简单了解到 mask 的基本用法。</p><p>这里得到了使用 mask 最重要结论：<strong>添加了 mask 属性的元素，其内容会与 mask 表示的渐变的 transparent 的重叠部分，并且重叠部分将会变得透明。</strong></p><p>值得注意的是，上面的渐变使用的是 <code>linear-gradient(90deg, transparent, #fff)</code>，这里的 <code>#fff</code> 纯色部分其实换成任意颜色都可以，不影响效果。</p><h4 id="使用-mask-实现人物遮罩过滤"><a href="#使用-mask-实现人物遮罩过滤" class="headerlink" title="使用 mask 实现人物遮罩过滤"></a>使用 mask 实现人物遮罩过滤</h4><hr><p>了解了 mask 的用法后，接下来，我们运用 mask，简单实现视频弹幕中，弹幕碰到人物，自动被隐藏过滤的例子。</p><p>首先，我简单的模拟了一个召唤师峡谷，以及一些基本的弹幕：</p><p><img src="/images/blog/2022-09-30/4.webp#pic_center" alt="图片" title="图片"></p><p>方便示意，这里使用了一张静态图，表示了召唤师峡谷的地图，并非真的视频，而弹幕则是一条一条的 <code>&lt;p&gt;</code> 元素，和实际情况一致。伪代码大概是这样：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 地图 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;g-map&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 包裹所有弹幕的容器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;g-barrage-container&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 所有弹幕 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;g-barrage&quot;</span>&gt;</span>6666<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">...</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;g-barrage&quot;</span>&gt;</span>6666<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>为了模拟实际情况，我们再用一个 div 添加一个实际的人物，如果不做任何处理，其实就是我们看视频打开弹幕的感受，人物被视频所遮挡：</p><p><img src="/images/blog/2022-09-30/5.webp#pic_center" alt="图片" title="图片"></p><p>注意，这里我添加了一个人物亚索，并且用 animation 模拟了简单的运动，在运动的过程中，人物是被弹幕给遮挡住的。</p><p>接下来，就可以请出 mask 了。</p><p>我们利用 mask 制作一个 <code>radial-gradient</code> ，使得人物附近为 <code>transparent</code>，并且根据人物运动的 animation，给 mask 的 <code>mask-position</code> 也添加上相同的 animation 即可。最终可以得到这样的效果：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.g-barrage-container</span> &#123;</span><br><span class="line"><span class="attribute">position</span>: absolute;</span><br><span class="line"><span class="attribute">mask</span>: <span class="built_in">radial-gradient</span>(circle at <span class="number">100px</span> <span class="number">100px</span>, transparent <span class="number">60px</span>, #fff <span class="number">80px</span>, #fff <span class="number">100%</span>);</span><br><span class="line"><span class="attribute">animation</span>: mask <span class="number">10s</span> infinite alternate;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@keyframes</span> mask &#123;</span><br><span class="line">100% &#123;</span><br><span class="line"><span class="attribute">mask-position</span>: <span class="number">85vw</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/blog/2022-09-30/6.webp#pic_center" alt="图片" title="图片"></p><p>实际上就是给放置弹幕的容器，添加一个 <code>mask</code> 属性，把人物所在的位置标识出来，并且根据人物的运动不断的去变换这个 mask 即可。我们把 mask 换成 background，原理一看就懂。</p><h5 id="把-mask-替换成-background-示意图："><a href="#把-mask-替换成-background-示意图：" class="headerlink" title="把 mask 替换成 background 示意图："></a>把 mask 替换成 background 示意图：</h5><p><img src="/images/blog/2022-09-30/7.webp#pic_center" alt="图片" title="图片"></p><p>background 透明的地方，即 mask 中为 transparent 的部分，实际就是弹幕会被隐藏遮罩的部分，而其他白色部分，弹幕不会被隐藏，正是完美的利用了 mask 的特性。</p><p>其实这项技术和视频本身是无关的，我们只需要根据视频计算需要屏蔽掉弹幕的位置，得到相应的 mask 参数即可。如果去掉背景和运动的人物，只保留弹幕和 mask，是这样的：</p><p><img src="/images/blog/2022-09-30/8.webp#pic_center" alt="图片" title="图片"></p><p><strong>需要明确的是，使用 mask，不是将弹幕部分给遮挡住，而是利用 mask，指定弹幕容器之下，哪些部分正常展示，哪些部分透明隐藏。</strong></p><h4 id="实际生产环境中的运用"><a href="#实际生产环境中的运用" class="headerlink" title="实际生产环境中的运用"></a>实际生产环境中的运用</h4><hr><p>当然，上面我们简单的还原了利用 mask 实现弹幕遮罩过滤的效果。但是实际情况比上述的场景复杂的多，因为人物英雄的位置是不确定的，每一刻都在变化。所以在实际生产环境中，mask 图片的参数，其实是由后端实时对视频进行处理计算出来的，然后传给前端，前端再进行渲染。</p><p>对于运用了这项技术的直播网站，我们可以审查元素，看到包裹弹幕的容器的 mask 属性，每时每刻都在发生变化：</p><p><img src="/images/blog/2022-09-30/9.webp#pic_center" alt="图片" title="图片"></p><p>返回回来的其实是一个 SVG 图片，大概长这个样子：</p><p><img src="/images/blog/2022-09-30/10.webp#pic_center" alt="图片" title="图片"></p><p>这样，根据视频人物的实时位置变化，不断计算新的 mask，再实时作用于弹幕容器之上，实现遮罩过滤。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;经常看一些&lt;a href=&quot;https://lol.qq.com/&quot;&gt;LOL&lt;/a&gt;比赛直播的小伙伴，肯定都知道，在一些弹幕网站（&lt;a href=&quot;https://www.bilibili.com/&quot;&gt;Bilibili&lt;/a&gt;、&lt;a href=&quot;https://www.hu</summary>
      
    
    
    
    <category term="大前端" scheme="https://blog.rexhang.com/categories/%E5%A4%A7%E5%89%8D%E7%AB%AF/"/>
    
    <category term="css3" scheme="https://blog.rexhang.com/categories/%E5%A4%A7%E5%89%8D%E7%AB%AF/css3/"/>
    
    
    <category term="css3" scheme="https://blog.rexhang.com/tags/css3/"/>
    
    <category term="mask" scheme="https://blog.rexhang.com/tags/mask/"/>
    
    <category term="遮罩" scheme="https://blog.rexhang.com/tags/%E9%81%AE%E7%BD%A9/"/>
    
  </entry>
  
  <entry>
    <title>CocosCreator实现不规则区域点击</title>
    <link href="https://blog.rexhang.com/2022/09/30/articles/1/"/>
    <id>https://blog.rexhang.com/2022/09/30/articles/1/</id>
    <published>2022-09-30T07:36:22.000Z</published>
    <updated>2022-10-25T14:41:49.321Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、问题背景"><a href="#一、问题背景" class="headerlink" title="一、问题背景"></a>一、问题背景</h3><p>在<code>CocosCreator中</code>，点击图片透明区域依然触发节点的点击事件。但在web开发中，可以使用Inkscape、SvgPathEditor等矢量图编辑器转为SVG，或者直接从figma中导出SVG，然后监听不规则图形事件。</p><p>以地图边界高亮为例：<a href="https://www.jianshu.com/p/0df99fe9951f">html 类似地图的不规则图形事件处理</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">svg &#123; <span class="attr">height</span>: 50vw; &#125;</span><br><span class="line">path &#123; <span class="attr">fill</span>: #d3d3d3; transition: .6s fill; opacity: <span class="number">0.6</span>;&#125;</span><br><span class="line">path:hover &#123; <span class="attr">fill</span>: #eee;opacity: <span class="number">0.6</span>; &#125;</span><br></pre></td></tr></table></figure><p>但CocosCreator中Sprite目前支持的格式为jpg和png，未直接支持SVG。</p><h3 id="二、方案调研"><a href="#二、方案调研" class="headerlink" title="二、方案调研"></a>二、方案调研</h3><h4 id="图像模板-image-stencil-mask"><a href="#图像模板-image-stencil-mask" class="headerlink" title="图像模板(image_stencil) mask"></a>图像模板(image_stencil) mask</h4><blockquote><p><a href="https://forum.cocos.org/t/topic/54706">如何控制只让图像遮罩的可视区域响应点击</a></p></blockquote><p><a href="https://docs.cocos.com/creator/2.4/manual/zh/components/mask.html">图像模板</a>可以根据设置的透明度阈值，只有当模板像素的 alpha 值大于该阈值时，才会绘制内容。</p><p><img src="https://img-blog.csdnimg.cn/2feaf42ea8864863ada2f494fa3a7da7.png#pic_center" alt="图片" title="图片"></p><p>但是该方式点击透明区域，依然会触发该节点的事件。</p><p>通过查看2.4.7版本 <a href="https://github.com/cocos/cocos-engine/blob/2.4.7/cocos2d/core/components/CCMask.js#L439">CCMask.js</a> 的源码 ，可以看到在碰撞检测中，图像模板类型的mask的命中方式与矩形保持一致，只有椭圆才是单独检测，故该方式并不能解决问题。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">_hitTest (cameraPt) &#123;</span><br><span class="line"><span class="keyword">let</span> node = <span class="built_in">this</span>.node;</span><br><span class="line"><span class="keyword">let</span> size = node.getContentSize(),</span><br><span class="line">w = size.width,</span><br><span class="line">h = size.height,</span><br><span class="line">testPt = _vec2_temp;</span><br><span class="line"></span><br><span class="line">node._updateWorldMatrix();</span><br><span class="line"><span class="comment">// If scale is 0, it can&#x27;t be hit.</span></span><br><span class="line"><span class="keyword">if</span> (!Mat4.invert(_mat4_temp, node._worldMatrix)) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">Vec2.transformMat4(testPt, cameraPt, _mat4_temp);</span><br><span class="line">testPt.x += node._anchorPoint.x * w;</span><br><span class="line">testPt.y += node._anchorPoint.y * h;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> result = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">this</span>.type === MaskType.RECT || <span class="built_in">this</span>.type === MaskType.IMAGE_STENCIL) &#123;</span><br><span class="line">result = testPt.x &gt;= <span class="number">0</span> &amp;&amp; testPt.y &gt;= <span class="number">0</span> &amp;&amp; testPt.x &lt;= w &amp;&amp; testPt.y &lt;= h;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">this</span>.type === MaskType.ELLIPSE) &#123;</span><br><span class="line"><span class="keyword">let</span> rx = w / <span class="number">2</span>, ry = h / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">let</span> px = testPt.x - <span class="number">0.5</span> * w, py = testPt.y - <span class="number">0.5</span> * h;</span><br><span class="line">result = px * px / (rx * rx) + py * py / (ry * ry) &lt; <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">this</span>.inverted) &#123;</span><br><span class="line">result = !result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="多边形mask"><a href="#多边形mask" class="headerlink" title="多边形mask"></a>多边形mask</h4><blockquote><p><a href="https://forum.cocos.org/t/topic/101732">1.Creator | 编辑器中可操作顶点的多边形遮罩</a><br><a href="https://forum.cocos.org/t/mask-graphic/79967">2.【组件分享】使用Mask+Graphic魔改的多边形遮罩组件</a><br><a href="https://forum.cocos.org/t/mask-polygoncollider/40853">3.[ Mask + PolygonCollider 简易自定义多边形遮罩制作 ]</a></p></blockquote><p>沿着mask的思路，在论坛上找到了多边形mask的实现方式。大致都是在CCMask源码的基础上，增加多边形的节点添加和碰撞检测，其中一位作者实现的组件非常吸睛，GitHub上共有400余Star，目前<a href="https://store.cocos.com/app/detail/2714">cocos商店</a>已有该组件。感兴趣可阅读源码。</p><p>效果如下：</p><p><img src="https://img-blog.csdnimg.cn/4e5244270dda45ff80b98fd19c7b3a46.png#pic_center" alt="图片" title="图片"></p><p>比较有意思是其碰撞检测（点是否在多边形内），采用<a href="https://www.cnblogs.com/luxiaoxun/p/3722358.html">射线法</a>判断。</p><ul><li><p>定义：从目标点出发引一条射线，看这条射线和多边形所有边的交点数目。如果有奇数个交点，则说明在内部，如果有偶数个交点，则说明在外部。</p></li><li><p>具体步骤：将测试点的Y坐标与多边形的每一个点进行比较，会得到一个测试点所在的行与多边形边的交点的列表。在下图的这个例子中有8条边与测试点所在的行相交，而有6条边没有相交。如果测试点的两边点的个数都是奇数个则该测试点在多边形内，否则在多边形外。在这个例子中测试点的左边有5个交点，右边有三个交点，它们都是奇数，所以点在多边形内。</p></li></ul><p><img src="https://img-blog.csdnimg.cn/d0a357861d6c4b7eb9b8794c2372ea3a.png#pic_center" alt="图片" title="图片"></p><ul><li>算法实现：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">isInPolygon</span>(<span class="params">checkPoint: cc.Vec2, polygonPoints: cc.Vec2[]</span>)</span> &#123;</span><br><span class="line"><span class="keyword">let</span> counter = <span class="number">0</span>, <span class="attr">i</span>: number, <span class="attr">xinters</span>: number;</span><br><span class="line"><span class="keyword">let</span> p1: cc.Vec2, <span class="attr">p2</span>: cc.Vec2;</span><br><span class="line"><span class="keyword">let</span> pointCount = polygonPoints.length;</span><br><span class="line">p1 = polygonPoints[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= pointCount; i++) &#123;</span><br><span class="line">p2 = polygonPoints[i % pointCount];</span><br><span class="line"><span class="keyword">if</span> (</span><br><span class="line">checkPoint.x &gt; <span class="built_in">Math</span>.min(p1.x, p2.x) &amp;&amp;</span><br><span class="line">checkPoint.x &lt;= <span class="built_in">Math</span>.max(p1.x, p2.x)</span><br><span class="line">) &#123;</span><br><span class="line"><span class="keyword">if</span> (checkPoint.y &lt;= <span class="built_in">Math</span>.max(p1.y, p2.y)) &#123;</span><br><span class="line"><span class="keyword">if</span> (p1.x != p2.x) &#123;</span><br><span class="line">xinters = (checkPoint.x - p1.x) * (p2.y - p1.y) / (p2.x - p1.x) + p1.y;</span><br><span class="line"><span class="keyword">if</span> (p1.y == p2.y || checkPoint.y &lt;= xinters) &#123;</span><br><span class="line">counter++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">p1 = p2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> (counter &amp; <span class="number">1</span>) !== <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="多边形mesh"><a href="#多边形mesh" class="headerlink" title="多边形mesh"></a>多边形mesh</h4><blockquote><p><a href="https://forum.cocos.org/t/mask-mesh-gizmo/88288">多边形裁剪图片(非mask,使用mesh)，新增 gizmo 支持</a><br><a href="https://github.com/baiyuwubing/cocos-creator-examples/tree/master/meshTexture">https://github.com/baiyuwubing/cocos-creator-examples/tree/master/meshTexture</a></p></blockquote><p>2年前开发，已停止维护，使用不佳，节点关联顺序容易紊乱。根据作者的描述，可以解决mask过多带来性能影响。</p><p><img src="https://img-blog.csdnimg.cn/56f4f806f5884c65a27ca7b18b48394b.png#pic_center" alt="图片" title="图片"></p><h4 id="像素点计算"><a href="#像素点计算" class="headerlink" title="像素点计算"></a>像素点计算</h4><blockquote><p><a href="https://forum.cocos.org/t/topic/135539">creator 2.4.8中获取像素信息</a></p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> getPixelData = <span class="function">(<span class="params">node: cc.Node, x: number, y: number</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> pixelsData = getPixelsData(node);</span><br><span class="line">  <span class="keyword">const</span> startIndex =</span><br><span class="line">    node.width * <span class="number">4</span> * <span class="built_in">Math</span>.floor(node.height - y) + <span class="number">4</span> * <span class="built_in">Math</span>.floor(x);</span><br><span class="line">  <span class="keyword">const</span> pixelData = pixelsData.slice(startIndex, startIndex + <span class="number">4</span>);</span><br><span class="line">  <span class="keyword">return</span> pixelData;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> isPixelTransparent = <span class="function">(<span class="params">node: cc.Node, x: number, y: number</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> pixelData = getPixelData(node, x, y);</span><br><span class="line">  <span class="keyword">return</span> pixelData[<span class="number">3</span>] === <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> getPixelsData = <span class="function">(<span class="params">node: cc.Node</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (!cc.isValid(node)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 节点宽度</span></span><br><span class="line">  <span class="keyword">const</span> width = <span class="built_in">Math</span>.floor(node.width);</span><br><span class="line">  <span class="keyword">const</span> height = <span class="built_in">Math</span>.floor(node.height);</span><br><span class="line">  <span class="comment">// 创建临时摄像机用于渲染目标节点</span></span><br><span class="line">  <span class="keyword">const</span> cameraNode = <span class="keyword">new</span> cc.Node();</span><br><span class="line">  cameraNode.parent = node;</span><br><span class="line">  <span class="keyword">const</span> camera = cameraNode.addComponent(cc.Camera);</span><br><span class="line">  <span class="comment">// eslint-disable-next-line no-bitwise</span></span><br><span class="line">  camera.clearFlags |= cc.Camera.ClearFlags.COLOR;</span><br><span class="line">  camera.backgroundColor = cc.color(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">  camera.zoomRatio = cc.winSize.height / height;</span><br><span class="line">  <span class="comment">// 将节点渲染到 RenderTexture中</span></span><br><span class="line">  <span class="keyword">const</span> renderTexture = <span class="keyword">new</span> cc.RenderTexture();</span><br><span class="line">  renderTexture.initWithSize(</span><br><span class="line">    width,</span><br><span class="line">    height,</span><br><span class="line">    cc.RenderTexture.DepthStencilFormat.RB_FMT_S8</span><br><span class="line">  );</span><br><span class="line">  camera.targetTexture = renderTexture;</span><br><span class="line">  camera.render(node);</span><br><span class="line">  <span class="keyword">const</span> pixelData = renderTexture.readPixels();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> pixelData;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 点击事件是否合法，非透明像素 */</span></span><br><span class="line"><span class="function"><span class="title">isValidTouch</span>(<span class="params">e: cc.Event.EventTouch</span>)</span> &#123;</span><br><span class="line"><span class="keyword">const</span> touchLocation = e.touch.getLocation();</span><br><span class="line"><span class="comment">/** 相对节点左下角的相对坐标，即图片内的坐标 */</span></span><br><span class="line"><span class="keyword">const</span> locationInNode = <span class="built_in">this</span>.node.convertToNodeSpaceAR(touchLocation);</span><br><span class="line"><span class="comment">/** 非本节点内 透传 */</span></span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">this</span>.node.getBoundingBoxToWorld().contains(touchLocation)) &#123;</span><br><span class="line"><span class="built_in">this</span>.setSwallowTouches(<span class="literal">false</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123; anchorX, anchorY, width, height &#125; = <span class="built_in">this</span>.node;</span><br><span class="line"><span class="keyword">const</span> x = locationInNode.x + anchorX * width;</span><br><span class="line"><span class="keyword">const</span> y = -(locationInNode.y - anchorY * height);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> isValid = !isPixelTransparent(<span class="built_in">this</span>.node, x, y);</span><br><span class="line"></span><br><span class="line"><span class="built_in">this</span>.setSwallowTouches(isValid);</span><br><span class="line"><span class="keyword">return</span> isValid;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 设置是否阻止点击事件透传 */</span></span><br><span class="line"><span class="function"><span class="title">setSwallowTouches</span>(<span class="params">bool: boolean</span>)</span> &#123;</span><br><span class="line">(<span class="built_in">this</span>.node <span class="keyword">as</span> any)._touchListener.setSwallowTouches(bool);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方案对比"><a href="#方案对比" class="headerlink" title="方案对比"></a>方案对比</h3><table><thead><tr><th>方案名称</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>图像模板mask</td><td>- 适合图片快速裁剪渲染</td><td>- 不满足要求</td></tr><tr><td>多边形mask</td><td>- 适用于多边形定制化裁剪</td><td>- 参考文章 [@]Mask组件多边形方案性影响手机Web性能。多边形mask使用过多，低端机性能下降严重（碰撞检测占主要原因）<br /> - 手动描边</td></tr><tr><td>多边形mesh</td><td>- 根据作者描述，比mask性能更优</td><td>- 手动描边</td></tr><tr><td>像素点计算</td><td>- 颗粒度精细，能精确到像素点 <br /> - 无需特殊处理图片</td><td>- 图片过大时，可能带来性能问题</td></tr></tbody></table><h3 id="可能的最佳实践？"><a href="#可能的最佳实践？" class="headerlink" title="可能的最佳实践？"></a>可能的最佳实践？</h3><p>在论坛中看到有个大佬在尝试svg拓展 <a href="https://forum.cocos.org/t/topic/100568">Creator + SVG 解析渲染扩展组件</a> ，已上架cocos商店【价值80¥】</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;一、问题背景&quot;&gt;&lt;a href=&quot;#一、问题背景&quot; class=&quot;headerlink&quot; title=&quot;一、问题背景&quot;&gt;&lt;/a&gt;一、问题背景&lt;/h3&gt;&lt;p&gt;在&lt;code&gt;CocosCreator中&lt;/code&gt;，点击图片透明区域依然触发节点的点击事件。但在web开</summary>
      
    
    
    
    <category term="大前端" scheme="https://blog.rexhang.com/categories/%E5%A4%A7%E5%89%8D%E7%AB%AF/"/>
    
    <category term="游戏引擎" scheme="https://blog.rexhang.com/categories/%E5%A4%A7%E5%89%8D%E7%AB%AF/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"/>
    
    
    <category term="cocos2d" scheme="https://blog.rexhang.com/tags/cocos2d/"/>
    
    <category term="CocosCreator" scheme="https://blog.rexhang.com/tags/CocosCreator/"/>
    
    <category term="游戏引擎" scheme="https://blog.rexhang.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"/>
    
  </entry>
  
  <entry>
    <title>JS中非常实用的『一行代码』</title>
    <link href="https://blog.rexhang.com/2022/08/04/articles/1/"/>
    <id>https://blog.rexhang.com/2022/08/04/articles/1/</id>
    <published>2022-08-04T04:03:28.000Z</published>
    <updated>2023-07-21T07:17:58.428Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>导读: 最近在国外技术社区看到了一些关于 <code>一行代码</code> 的文章📄，感觉很有意思，就整理了下来并且自己额外补充了一部分分享给大家🤜，希望对各位读者们有所帮助💕。</p></blockquote><h5 id="最近一次更新时间-2022-08-21-12-00-15"><a href="#最近一次更新时间-2022-08-21-12-00-15" class="headerlink" title="最近一次更新时间 2022-08-21 12:00:15"></a>最近一次更新时间 2022-08-21 12:00:15</h5><hr><p>这些方法使用到了一些API，简化了操作，但是有些方法写一行属实不太优雅，所以这里主要还是学习API的使用小技巧。</p><h4 id="一、日期处理"><a href="#一、日期处理" class="headerlink" title="一、日期处理"></a>一、日期处理</h4><ol><li>检查日期是否有效<br>该方法用于检测给出的日期是否有效</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> isDateValid = <span class="function">(<span class="params">...val</span>) =&gt;</span> !<span class="built_in">Number</span>.isNaN( <span class="keyword">new</span> <span class="built_in">Date</span>(...val).valueOf() );</span><br><span class="line"><span class="comment">// how to use</span></span><br><span class="line">isDateValid(<span class="string">&quot;December 17, 1995 03:24:00&quot;</span>); <span class="comment">// =&gt; true</span></span><br></pre></td></tr></table></figure><ol start="2"><li>计算两个日期之间的间隔<br>该方法用于计算两个日期之间的间隔时间(day)</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> dayDif = <span class="function">(<span class="params">date1, date2</span>) =&gt;</span> <span class="built_in">Math</span>.ceil( <span class="built_in">Math</span>.abs( date1.getTime() - date2.getTime() ) / <span class="number">86400000</span>);</span><br><span class="line"><span class="comment">// how to use</span></span><br><span class="line">dayDif(<span class="keyword">new</span> <span class="built_in">Date</span>(<span class="string">&quot;2022-08-01&quot;</span>), <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="string">&quot;2022-08-04&quot;</span>)); <span class="comment">// =&gt; 3</span></span><br></pre></td></tr></table></figure><ol start="3"><li>查找日期位于一年中的第几天<br>该方法用于检测给出的日期位于今年的第几天</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> dayOfYear = <span class="function"><span class="params">date</span> =&gt;</span> <span class="built_in">Math</span>.floor( ( date - <span class="keyword">new</span> <span class="built_in">Date</span>(date.getFullYear(), <span class="number">0</span>, <span class="number">0</span>) ) / <span class="number">1000</span> / <span class="number">60</span> / <span class="number">60</span> / <span class="number">24</span> )</span><br><span class="line"><span class="comment">// how to use</span></span><br><span class="line">dayOfYear(<span class="keyword">new</span> <span class="built_in">Date</span>(<span class="string">&quot;2022-08-01&quot;</span>)); <span class="comment">// =&gt; 213</span></span><br><span class="line">dayOfYear(<span class="keyword">new</span> <span class="built_in">Date</span>(<span class="string">&quot;2022-01-01&quot;</span>)); <span class="comment">// =&gt; 1</span></span><br></pre></td></tr></table></figure><ol start="4"><li>时间格式化<br>该方法用于转换时间</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> timeFromDate = <span class="function"><span class="params">date</span> =&gt;</span> date.toTimeString().slice(<span class="number">0</span>, <span class="number">8</span>);</span><br><span class="line"><span class="comment">// how to use</span></span><br><span class="line">timeFromDate(<span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2022</span>, <span class="number">08</span>, <span class="number">04</span>, <span class="number">12</span>, <span class="number">30</span>, <span class="number">0</span>)); <span class="comment">// =&gt; &#x27;12:30:00&#x27;</span></span><br><span class="line">timeFromDate(<span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2022</span>, <span class="number">08</span>, <span class="number">04</span>, <span class="number">12</span>, <span class="number">30</span>, <span class="number">60</span>)); <span class="comment">// =&gt; &#x27;12:31:00&#x27;</span></span><br><span class="line">timeFromDate(<span class="keyword">new</span> <span class="built_in">Date</span>()); <span class="comment">// =&gt; 此刻的时间</span></span><br></pre></td></tr></table></figure><h4 id="二、字符串处理"><a href="#二、字符串处理" class="headerlink" title="二、字符串处理"></a>二、字符串处理</h4><ol><li>字符串首字母大写<br>该方法用于将英文字符串的首字母大写处理</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> capitalize = <span class="function"><span class="params">str</span> =&gt;</span> str.charAt(<span class="number">0</span>).toUpperCase() + str.slice(<span class="number">1</span>);</span><br><span class="line"><span class="comment">// how to use</span></span><br><span class="line">capitalize(<span class="string">&quot;hello world&quot;</span>); <span class="comment">// =&gt; Hello world</span></span><br></pre></td></tr></table></figure><ol start="2"><li>翻转字符串<br>该方法用于将一个字符串进行翻转操作并返回翻转后的内容</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> reverse = <span class="function"><span class="params">str</span> =&gt;</span> str.split(<span class="string">&#x27;&#x27;</span>).reverse().join(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line"><span class="comment">// how to use</span></span><br><span class="line">reverse(<span class="string">&quot;hello world&quot;</span>); <span class="comment">// =&gt; dlrow olleh</span></span><br></pre></td></tr></table></figure><ol start="3"><li>随机字符串<br>该方法用于生成一个随机的字符串并返回</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> randomString = <span class="function">() =&gt;</span> <span class="built_in">Math</span>.random().toString(<span class="number">36</span>).slice(<span class="number">2</span>);</span><br><span class="line"><span class="comment">// how to use</span></span><br><span class="line">randomString(); <span class="comment">// =&gt; anyString</span></span><br></pre></td></tr></table></figure><ol start="4"><li>去除字符串中的HTML<br>该方法用于去除字符串中的HTML元素</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> stripHtml = <span class="function"><span class="params">html</span> =&gt;</span> (<span class="keyword">new</span> DOMParser().parseFromString(html, <span class="string">&#x27;text/html&#x27;</span>)).body.textContent || <span class="string">&#x27;&#x27;</span>;</span><br><span class="line"><span class="comment">// how to use</span></span><br><span class="line">stripHtml(<span class="string">&quot;&lt;div&gt;Beware of the missing closing tag&lt;/div&gt;hello world&lt;i&gt;!&lt;i&gt;&quot;</span>); <span class="comment">// =&gt; &#x27;Beware of the missing closing taghello world!&#x27;</span></span><br></pre></td></tr></table></figure><ol start="5"><li>获取URL的search参数并json化<br>该方法用于获取当前访问的URL中的search内容并解析成JSON键值对形式</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> urlParams = <span class="function"><span class="params">search</span> =&gt;</span> <span class="built_in">Object</span>.fromEntries(<span class="keyword">new</span> URLSearchParams(search));</span><br><span class="line"><span class="comment">// how to use</span></span><br><span class="line">urlParams(location.search); <span class="comment">// =&gt; &#123; id: &#x27;1&#x27;, name: &#x27;rexhang&#x27; &#125;</span></span><br></pre></td></tr></table></figure><ol start="6"><li>去除数字之外的所有字符<br>该方法用于去除数字之外的所有字符</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> toNumber = <span class="function"><span class="params">str</span> =&gt;</span> <span class="built_in">Number</span>(str.replace(<span class="regexp">/\D/g</span>, <span class="string">&#x27;&#x27;</span>));</span><br><span class="line"><span class="comment">// how to use</span></span><br><span class="line"><span class="keyword">const</span> str = <span class="string">&#x27;hello 123 is god 456&#x27;</span>;</span><br><span class="line">toNumber(str); <span class="comment">// =&gt; 123456</span></span><br></pre></td></tr></table></figure><ol start="7"><li>空值(null | undefined)合并运算符<br>该方法用于更简短的定义空值情况下的时候, null 或者 undefined 会认定为判断范围， 其余认为正常赋值</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> aa = isA ?? <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">const</span> bb = isB ?? <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> cc = isC ?? <span class="string">&#x27;ok&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> dd = isD ?? <span class="string">&#x27;done&#x27;</span>;</span><br><span class="line"><span class="comment">// how to use</span></span><br><span class="line"><span class="keyword">const</span> isA = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">const</span> isB = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> isC = <span class="literal">undefined</span>;</span><br><span class="line"><span class="keyword">const</span> isD = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">const</span> aa = isA ?? <span class="string">&#x27;...&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> bb = isB ?? <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> cc = isC ?? <span class="string">&#x27;ok&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> dd = isD ?? <span class="string">&#x27;done&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(aa, bb, cc, dd);</span><br></pre></td></tr></table></figure><h4 id="二、数组处理"><a href="#二、数组处理" class="headerlink" title="二、数组处理"></a>二、数组处理</h4><ol><li>从数组中移除重复项<br>该方法用于从数组中移除重复项</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> removeDuplicates = <span class="function"><span class="params">arr</span> =&gt;</span> [...new <span class="built_in">Set</span>(arr)];</span><br><span class="line"><span class="comment">// how to use</span></span><br><span class="line">removeDuplicates([<span class="number">1</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">5</span>]); <span class="comment">// =&gt; [1, 3, 4, 5]</span></span><br></pre></td></tr></table></figure><ol start="2"><li>打乱数组顺序<br>该方法用于打乱数组顺序，随机取random后的数组</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> randomArr = <span class="function"><span class="params">arr</span> =&gt;</span> arr.sort(<span class="function">() =&gt;</span> <span class="number">0.5</span> - <span class="built_in">Math</span>.random());</span><br><span class="line"><span class="comment">// how to use</span></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="string">&#x27;🙂&#x27;</span>, <span class="string">&#x27;66&#x27;</span>, <span class="literal">true</span>, <span class="number">11</span>, &#123;<span class="attr">name</span>: <span class="string">&#x27;rexhang&#x27;</span>&#125;];</span><br><span class="line"><span class="built_in">console</span>.log(randomArr(arr)); <span class="comment">// random arr, eg: [&#x27;66&#x27;, 11, true, &#123;name: &#x27;rexhang&#x27;&#125;, &#x27;🙂&#x27;];</span></span><br></pre></td></tr></table></figure><ol start="3"><li>从数组中随机去一个值<br>该方法用于从数组中随机去一个值</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> takeARandomItem = <span class="function"><span class="params">arr</span> =&gt;</span> arr[<span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * arr.length)]</span><br><span class="line"><span class="comment">// how to use</span></span><br><span class="line"><span class="keyword">const</span> eles = [<span class="string">&#x27;🙂&#x27;</span>, <span class="string">&#x27;66&#x27;</span>, <span class="literal">true</span>, <span class="number">11</span>, &#123;<span class="attr">name</span>: <span class="string">&#x27;rexhang&#x27;</span>&#125;];</span><br><span class="line"><span class="built_in">console</span>.log(takeARandomItem(eles)); <span class="comment">// random item of arr, eg: &#x27;🙂&#x27;;</span></span><br></pre></td></tr></table></figure><ol start="4"><li>从数组中取出最大/小值(仅限数字|字符串数字)<br>该方法用于从数组中取出最大/小值(仅限数字|字符串数字)</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> getMaxMinValue = <span class="function"><span class="params">arr</span> =&gt;</span> (&#123;</span><br><span class="line">    max: <span class="built_in">Math</span>.max(...arr),</span><br><span class="line">    min: <span class="built_in">Math</span>.min(...arr),</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// how to use</span></span><br><span class="line"><span class="keyword">const</span> items = [<span class="number">11</span>, <span class="number">12</span>, <span class="number">11</span>, <span class="number">1</span>, <span class="string">&#x27;0&#x27;</span>];</span><br><span class="line"><span class="built_in">console</span>.log(getMaxMinValue(items)); <span class="comment">// &#123; max: 12, min: 0 &#125;</span></span><br></pre></td></tr></table></figure><ol start="5"><li>判断数组是否为空<br>该方法用于判断数组是否为空</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> isNotEmpty = <span class="function"><span class="params">arr</span> =&gt;</span> <span class="built_in">Array</span>.isArray(arr) &amp;&amp; !!arr.length;</span><br><span class="line"><span class="comment">// how to use</span></span><br><span class="line">isNotEmpty([<span class="number">1</span>, <span class="number">3</span>]); <span class="comment">// =&gt; true</span></span><br><span class="line">isNotEmpty([]); <span class="comment">// =&gt; true</span></span><br><span class="line">isNotEmpty(<span class="string">&quot;[1, 3]&quot;</span>); <span class="comment">// =&gt; 非数组返回false</span></span><br></pre></td></tr></table></figure><hr><h4 id="长期且持续更新中…"><a href="#长期且持续更新中…" class="headerlink" title="长期且持续更新中…"></a>长期且持续更新中…</h4>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;导读: 最近在国外技术社区看到了一些关于 &lt;code&gt;一行代码&lt;/code&gt; 的文章📄，感觉很有意思，就整理了下来并且自己额外补充了一部分分享给大家🤜，希望对各位读者们有所帮助💕。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h5 id=&quot;最近一次</summary>
      
    
    
    
    <category term="大前端" scheme="https://blog.rexhang.com/categories/%E5%A4%A7%E5%89%8D%E7%AB%AF/"/>
    
    <category term="效率" scheme="https://blog.rexhang.com/categories/%E5%A4%A7%E5%89%8D%E7%AB%AF/%E6%95%88%E7%8E%87/"/>
    
    <category term="前端开发" scheme="https://blog.rexhang.com/categories/%E5%A4%A7%E5%89%8D%E7%AB%AF/%E6%95%88%E7%8E%87/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="javascript" scheme="https://blog.rexhang.com/tags/javascript/"/>
    
    <category term="javascript数组" scheme="https://blog.rexhang.com/tags/javascript%E6%95%B0%E7%BB%84/"/>
    
    <category term="javascript字符串" scheme="https://blog.rexhang.com/tags/javascript%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
    <category term="js小tips" scheme="https://blog.rexhang.com/tags/js%E5%B0%8Ftips/"/>
    
    <category term="js技巧" scheme="https://blog.rexhang.com/tags/js%E6%8A%80%E5%B7%A7/"/>
    
  </entry>
  
  <entry>
    <title>一套面向常规统计图表，以数据驱动的高交互可视化图形语法 - G2</title>
    <link href="https://blog.rexhang.com/2022/08/04/articles/2/"/>
    <id>https://blog.rexhang.com/2022/08/04/articles/2/</id>
    <published>2022-08-04T01:27:08.000Z</published>
    <updated>2022-10-25T14:41:49.322Z</updated>
    
    <content type="html"><![CDATA[<h1 align="center"><b>G2</b></h1><div align="center"><p>一套面向常规统计图表，以数据驱动的高交互可视化图形语法。</p><p><a href="https://travis-ci.org/antvis/g2"><img src="https://img.shields.io/travis/antvis/g2.svg"></a> <img src="https://github.com/antvis/G2/workflows/CI/badge.svg" alt="CI"> <a href="https://coveralls.io/github/antvis/G2?branch=master"><img src="https://coveralls.io/repos/github/antvis/G2/badge.svg?branch=master" alt="Coverage Status"></a> <a href="https://www.npmjs.com/package/@antv/g2"><img src="https://img.shields.io/npm/v/@antv/g2.svg" alt="NPM Package"></a> <a href="https://npmjs.org/package/@antv/g2"><img src="http://img.shields.io/npm/dm/@antv/g2.svg" alt="NPM Downloads"></a> <img src="https://img.shields.io/badge/dependencies-up%20to%20date-brightgreen.svg" alt="Dependencies"> <a href="http://isitmaintained.com/project/antvis/g2" title="Percentage of issues still open"><img src="http://isitmaintained.com/badge/open/antvis/g2.svg" alt="Percentage of issues still open"></a> <a href="https://github.com/antvis/g2/pulls"><img src="https://img.shields.io/badge/PRs-welcome-brightgreen.svg?style=shields" alt="PRs Welcome"></a></p><p><img src="https://img.shields.io/badge/language-TypeScript-red.svg"> <img src="https://img.shields.io/badge/license-MIT-000000.svg"></p><p><a href="https://twitter.com/AntV_Alipay"><img src="https://img.shields.io/twitter/follow/AntV_Alipay.svg?label=AntV&style=social"></a></p></div><p align="center">  <a href="https://g2.antv.vision/zh">网站</a> •  <a href="https://g2.antv.vision/zh/docs/manual/about-g2">教程文档</a> •  <a href="https://www.yuque.com/antv">博客</a> •  <a href="https://github.com/antvis/G2Plot">G2Plot</a></p><p>G2 是一套基于图形语法理论的可视化底层引擎，以数据驱动，提供图形语法与交互语法，具有高度的易用性和扩展性。使用 G2，你可以无需关注图表各种繁琐的实现细节，一条语句即可使用 Canvas 或 SVG 构建出各种各样的可交互的统计图表。</p><h2 id="📺-线上示例"><a href="#📺-线上示例" class="headerlink" title="📺 线上示例"></a>📺 线上示例</h2><p><a href="https://g2.antv.vision/zh/examples/gallery"><img src="https://user-images.githubusercontent.com/6628666/75466330-fe1d0c00-59c4-11ea-91ba-506f60ef8af4.png" style='width: 100%'/></a></p><h2 id="✨-特性"><a href="#✨-特性" class="headerlink" title="✨ 特性"></a>✨ 特性</h2><ul><li>💯 完善的图形语法：数据到图形的映射，能够绘制出所有的图表。</li><li>🤩 全新的交互语法：通过触发和反馈机制可以组合出各种交互行为，对数据进行探索。</li><li>🦍 强大的 View 模块：可支持开发个性化的数据多维分析图形。</li><li>👬 双引擎渲染：Canvas 或 SVG 任意切换。</li><li>💄 可视化组件体系：面向交互、体验优雅。</li><li>🛡 全面拥抱 TypeScript：提供完整的类型定义文件。</li></ul><h2 id="📦-安装"><a href="#📦-安装" class="headerlink" title="📦 安装"></a>📦 安装</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install @antv/g2</span><br></pre></td></tr></table></figure><h2 id="🔨-快速上手"><a href="#🔨-快速上手" class="headerlink" title="🔨 快速上手"></a>🔨 快速上手</h2><img src="https://gw.alipayobjects.com/mdn/rms_2274c3/afts/img/A*8qbLQb7A0loAAAAAAAAAAABkARQnAQ" style="width: 600px"><p>在绘图前我们需要为 G2 准备一个 DOM 容器：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;c1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Chart &#125; <span class="keyword">from</span> <span class="string">&#x27;@antv/g2&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> data = [</span><br><span class="line">  &#123; <span class="attr">genre</span>: <span class="string">&#x27;Sports&#x27;</span>, <span class="attr">sold</span>: <span class="number">275</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">genre</span>: <span class="string">&#x27;Strategy&#x27;</span>, <span class="attr">sold</span>: <span class="number">115</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">genre</span>: <span class="string">&#x27;Action&#x27;</span>, <span class="attr">sold</span>: <span class="number">120</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">genre</span>: <span class="string">&#x27;Shooter&#x27;</span>, <span class="attr">sold</span>: <span class="number">350</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">genre</span>: <span class="string">&#x27;Other&#x27;</span>, <span class="attr">sold</span>: <span class="number">150</span> &#125;,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="comment">// Step 1: 创建 Chart 对象</span></span><br><span class="line"><span class="keyword">const</span> chart = <span class="keyword">new</span> Chart(&#123;</span><br><span class="line">  container: <span class="string">&#x27;c1&#x27;</span>, <span class="comment">// 指定图表容器 ID</span></span><br><span class="line">  width: <span class="number">600</span>, <span class="comment">// 指定图表宽度</span></span><br><span class="line">  height: <span class="number">300</span>, <span class="comment">// 指定图表高度</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Step 2: 载入数据源</span></span><br><span class="line">chart.data(data);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Step 3: 创建图形语法，绘制柱状图</span></span><br><span class="line">chart.interval().position(<span class="string">&#x27;genre*sold&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Step 4: 渲染图表</span></span><br><span class="line">chart.render();</span><br></pre></td></tr></table></figure><h2 id="⌨️-本地开发"><a href="#⌨️-本地开发" class="headerlink" title="⌨️ 本地开发"></a>⌨️ 本地开发</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装依赖</span></span><br><span class="line">$ npm install</span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行测试用例</span></span><br><span class="line">$ npm run <span class="built_in">test</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 打开 electron 运行测试用例，监听文件变化构建</span></span><br><span class="line">$ npm run test-live</span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行 CI</span></span><br><span class="line">$ npm run ci</span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行网站</span></span><br><span class="line">$ npm start</span><br></pre></td></tr></table></figure><h2 id="🏷️-版本"><a href="#🏷️-版本" class="headerlink" title="🏷️ 版本"></a>🏷️ 版本</h2><ul><li>v3.5.x: <a href="https://github.com/antvis/G2/tree/v3.5.x">https://github.com/antvis/G2/tree/v3.5.x</a></li><li>v4.0.x: <a href="https://github.com/antvis/G2/tree/v4.0.x">https://github.com/antvis/G2/tree/v4.0.x</a></li></ul><blockquote><p>你也可以在业务中使用基于 G2 封装的常规统计图表 <strong><a href="https://github.com/antvis/G2Plot">G2Plot</a></strong> ，可以使用配置的方式快速生成一个通用图表，降低开发者的使用成本。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 align=&quot;center&quot;&gt;
&lt;b&gt;G2&lt;/b&gt;
&lt;/h1&gt;

&lt;div align=&quot;center&quot;&gt;

&lt;p&gt;一套面向常规统计图表，以数据驱动的高交互可视化图形语法。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://travis-ci.org/antvis/g2&quot;&gt;</summary>
      
    
    
    
    <category term="大前端" scheme="https://blog.rexhang.com/categories/%E5%A4%A7%E5%89%8D%E7%AB%AF/"/>
    
    <category term="图表" scheme="https://blog.rexhang.com/categories/%E5%A4%A7%E5%89%8D%E7%AB%AF/%E5%9B%BE%E8%A1%A8/"/>
    
    <category term="G2" scheme="https://blog.rexhang.com/categories/%E5%A4%A7%E5%89%8D%E7%AB%AF/%E5%9B%BE%E8%A1%A8/G2/"/>
    
    
    <category term="javascript" scheme="https://blog.rexhang.com/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>React代码整洁优化实践</title>
    <link href="https://blog.rexhang.com/2022/08/02/articles/1/"/>
    <id>https://blog.rexhang.com/2022/08/02/articles/1/</id>
    <published>2022-08-02T14:16:48.000Z</published>
    <updated>2022-10-25T14:41:49.322Z</updated>
    
    <content type="html"><![CDATA[<h5 id="整洁的代码不仅仅是正常运行的代码，更是要求易于阅读、简单易懂、组织整齐。"><a href="#整洁的代码不仅仅是正常运行的代码，更是要求易于阅读、简单易懂、组织整齐。" class="headerlink" title="整洁的代码不仅仅是正常运行的代码，更是要求易于阅读、简单易懂、组织整齐。"></a>整洁的代码不仅仅是正常运行的代码，更是要求易于阅读、简单易懂、组织整齐。</h5><h5 id="在本文中，我会们将示例几种代码整洁案例。"><a href="#在本文中，我会们将示例几种代码整洁案例。" class="headerlink" title="在本文中，我会们将示例几种代码整洁案例。"></a>在本文中，我会们将示例几种代码整洁案例。</h5><h5 id="在阅读这些建议时，要记住这些只是建议！-如果你不同意它们中的任何一个，那也完全没关系。"><a href="#在阅读这些建议时，要记住这些只是建议！-如果你不同意它们中的任何一个，那也完全没关系。" class="headerlink" title="在阅读这些建议时，要记住这些只是建议！ 如果你不同意它们中的任何一个，那也完全没关系。"></a>在阅读这些建议时，要记住这些只是建议！ 如果你不同意它们中的任何一个，那也完全没关系。</h5><h5 id="以下这些实践，个人觉得对我自己编写-React-代码很有帮助。"><a href="#以下这些实践，个人觉得对我自己编写-React-代码很有帮助。" class="headerlink" title="以下这些实践，个人觉得对我自己编写 React 代码很有帮助。"></a>以下这些实践，个人觉得对我自己编写 React 代码很有帮助。</h5><h2 id="1-仅对一个条件进行渲染"><a href="#1-仅对一个条件进行渲染" class="headerlink" title="1. 仅对一个条件进行渲染"></a>1. 仅对一个条件进行渲染</h2><blockquote><p>如果需要在条件为<code>true</code>时渲染某些内容，而在条件为<code>false</code>时不渲染任何内容，不推荐使用三元表达式，改用<strong>与运算符</strong><code>&amp;&amp;</code>，它可以方便地条件渲染一个元素。</p></blockquote><p>优化前:</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> TopNav = <span class="function">(<span class="params">props: &#123; showSearch?: boolean &#125;</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">const</span> &#123; showSearch = <span class="literal">false</span> &#125; = props;</span><br><span class="line"><span class="keyword">return</span> (</span><br><span class="line">&lt;div className=<span class="string">&quot;doc-head&quot;</span>&gt;</span><br><span class="line">&#123;<span class="comment">/* 三元表达式进行条件渲染 */</span>&#125;</span><br><span class="line">&#123;showSearch ? <span class="xml"><span class="tag">&lt;<span class="name">SearchBox</span> <span class="attr">placeholder</span>=<span class="string">&quot;输入关键词搜索&quot;</span> <span class="attr">onSearch</span>=<span class="string">&#123;(keyword)</span> =&gt;</span> window.location.assign(`/privatecloud/search?q=$&#123;keyword&#125;`)&#125; style=&#123;&#123; marginRight: 100 &#125;&#125; /&gt;</span> : <span class="literal">null</span>&#125;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>优化后:</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> TopNav = <span class="function">(<span class="params">props: &#123; showSearch?: boolean &#125;</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">const</span> &#123; showSearch = <span class="literal">false</span> &#125; = props;</span><br><span class="line"><span class="keyword">return</span> (</span><br><span class="line">&lt;div className=<span class="string">&quot;doc-head&quot;</span>&gt;</span><br><span class="line">&#123;<span class="comment">/* 与运算符&amp;&amp;进行条件渲染 */</span>&#125;</span><br><span class="line">&#123;showSearch &amp;&amp; <span class="xml"><span class="tag">&lt;<span class="name">SearchBox</span> <span class="attr">placeholder</span>=<span class="string">&quot;输入关键词搜索&quot;</span> <span class="attr">onSearch</span>=<span class="string">&#123;(keyword)</span> =&gt;</span> window.location.assign(`/privatecloud/search?q=$&#123;keyword&#125;`)&#125; style=&#123;&#123; marginRight: 100 &#125;&#125; /&gt;</span>&#125;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="2-每一个条件都可能进行渲染"><a href="#2-每一个条件都可能进行渲染" class="headerlink" title="2. 每一个条件都可能进行渲染"></a>2. 每一个条件都可能进行渲染</h2><blockquote><p>如果需要在条件为 true 时渲染某些内容，而在条件为 false 时渲染其他内容。推荐使用<code>三元表达式</code>！</p></blockquote><p>优化前:</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="comment">/* 条件 True 和 False 都要渲染内容 */</span>&#125;</span><br><span class="line">&#123; good &amp;&amp; <span class="xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Good!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span> &#125;</span><br><span class="line">&#123; !good &amp;&amp; &lt;p&gt;&lt;b&gt;Not Good!&lt;b&gt;&lt;/p&gt; &#125;</span><br></pre></td></tr></table></figure><p>优化后:</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="comment">/* 三元表达式 */</span></span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">good ? (</span><br><span class="line">&lt;p&gt;Good!&lt;/p&gt;</span><br><span class="line">) : (</span><br><span class="line">&lt;p&gt;</span><br><span class="line">&lt;b&gt;Not Good!&lt;/b&gt;</span><br><span class="line">&lt;/p&gt;</span><br><span class="line">);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-组件-Boolean-props-传参"><a href="#3-组件-Boolean-props-传参" class="headerlink" title="3. 组件 Boolean props 传参"></a>3. 组件 Boolean props 传参</h2><blockquote><p>组件接收参数的属性值为布尔类型, 并且传入 true 值时，可以省略填写值，并不会影响组件内取到 true 值</p></blockquote><p>优化前:</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;Hello disabled=&#123;<span class="literal">true</span>&#125; /&gt;</span><br><span class="line">&lt;Hello disabled=&#123;<span class="literal">false</span>&#125; /&gt;</span><br></pre></td></tr></table></figure><p>优化后:</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;Hello disabled /&gt;</span><br><span class="line">&lt;Hello disabled=&#123;<span class="literal">false</span>&#125; /&gt;</span><br></pre></td></tr></table></figure><h2 id="4-组件-String-props-传参"><a href="#4-组件-String-props-传参" class="headerlink" title="4. 组件 String props 传参"></a>4. 组件 String props 传参</h2><blockquote><p>组件 Props 值为 String, 推荐使用双引号包裹，不使用花括号或反引号。</p></blockquote><p>优化前:</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;Hello personName=&#123;<span class="string">&quot;Jim&quot;</span>&#125; /&gt;</span><br><span class="line">&lt;Hello personName=&#123;<span class="string">&#x27;Tom&#x27;</span>&#125; /&gt;</span><br><span class="line">&lt;Hello personName=&#123;<span class="string">`Ken`</span>&#125; /&gt;</span><br></pre></td></tr></table></figure><p>优化后:</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;Hello personName=<span class="string">&quot;Jim&quot;</span> /&gt;</span><br><span class="line">&lt;Hello personName=<span class="string">&quot;Tom&quot;</span> /&gt;</span><br><span class="line">&lt;Hello personName=<span class="string">&quot;Ken&quot;</span> /&gt;</span><br></pre></td></tr></table></figure><h2 id="5-Event-handler-functions"><a href="#5-Event-handler-functions" class="headerlink" title="5. Event handler functions"></a>5. Event handler functions</h2><blockquote><p>如果一个事件函数只接受一个参数，不需要传入匿名函数：onChange={ e =&gt; handleChange(e) }，推荐这种写法(直接等于函数)： onChange={ handleChange } 。</p></blockquote><p>优化前:</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> handleChange = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="built_in">console</span>.info(e.target.value);</span><br><span class="line">&#125;;</span><br><span class="line">&lt;input id=<span class="string">&quot;name&quot;</span> value=&#123;inputValue&#125; onChange=&#123;<span class="function">(<span class="params">e</span>) =&gt;</span> handleChange(e)&#125; /&gt;;</span><br></pre></td></tr></table></figure><p>优化后:</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> handleChange = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="built_in">console</span>.info(e.target.value);</span><br><span class="line">&#125;;</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* 事件只有一个参数，不需要匿名函数*/</span></span><br><span class="line">&#125;</span><br><span class="line">&lt;input id=<span class="string">&quot;name&quot;</span> value=&#123;inputValue&#125; onChange=&#123;handleChange&#125; /&gt;;</span><br></pre></td></tr></table></figure><h2 id="6-components-as-props"><a href="#6-components-as-props" class="headerlink" title="6. components as props"></a>6. components as props</h2><blockquote><p>将组件作为参数传递给另一个组件时，如果该组件不接受任何参数，则无需将该传递的组件包装在函数中。</p></blockquote><p>优化前:</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;Hello ClockComponent=&#123;<span class="function">() =&gt;</span> <span class="xml"><span class="tag">&lt;<span class="name">Clock</span> <span class="attr">timestamp</span>=<span class="string">&#123;new</span> <span class="attr">Date</span>()<span class="attr">.getTime</span>()&#125; /&gt;</span></span>&#125; /&gt;</span><br><span class="line">&lt;Hello ClockComponent=&#123;<span class="function">() =&gt;</span> <span class="xml"><span class="tag">&lt;<span class="name">Clock</span> /&gt;</span></span>&#125; /&gt;</span><br></pre></td></tr></table></figure><p>优化后:</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;Hello ClockComponent=&#123;<span class="function">() =&gt;</span> <span class="xml"><span class="tag">&lt;<span class="name">Clock</span> <span class="attr">timestamp</span>=<span class="string">&#123;new</span> <span class="attr">Date</span>()<span class="attr">.getTime</span>()&#125; /&gt;</span></span>&#125; /&gt;</span><br><span class="line">&lt;Hello ClockComponent=&#123;Clock&#125; /&gt;</span><br></pre></td></tr></table></figure><h2 id="7-设置-state-依赖先前的-state"><a href="#7-设置-state-依赖先前的-state" class="headerlink" title="7. 设置 state 依赖先前的 state"></a>7. 设置 state 依赖先前的 state</h2><blockquote><p>如果新 state 依赖于先前 state，则始终将 state 设置为先前 state 的函数。可以批处理 React 状态更新。</p></blockquote><p>优化前:</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> Hello = <span class="function">() =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">const</span> [cout, setCount] = useState &lt; number &gt; <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 依赖先前/上一个的state值 (异步调用)</span></span><br><span class="line"><span class="keyword">const</span> handleClick = <span class="function">(<span class="params">e</span>) =&gt;</span> setCount(cout + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 期望执行2次 首次执行理应 cout = 2</span></span><br><span class="line"><span class="keyword">const</span> handleClickRunDouble = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="comment">// 执行第二个handleClick执行的时候第一个count设置未完成(异步的)，所以还是 count = 0 = 0 + 1 = 1 因此 首次的点击得到的值 = 1 而并非2, 如果需要实现2 那么就得利用setState的批处理方式</span></span><br><span class="line">handleClick(e);</span><br><span class="line">handleClick(e);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> (</span><br><span class="line">&lt;div&gt;</span><br><span class="line">&lt;button onclick=&#123;handleClick&#125;&gt;click here&lt;/button&gt;</span><br><span class="line">&lt;span&gt;&#123;count&#125;&lt;/span&gt;</span><br><span class="line">&lt;button onclick=&#123;handleClickRunDouble&#125;&gt;click here &amp; lunch <span class="number">2</span> times&lt;/button&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>优化后:</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> Hello = <span class="function">() =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">const</span> [cout, setCount] = useState &lt; number &gt; <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* 将set调用设置为批处理模式 使用set方法提供的callback内的数值 */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> handleClick = <span class="function">(<span class="params">e</span>) =&gt;</span> setCount(<span class="function">(<span class="params">c</span>) =&gt;</span> c + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 首次调用后会输出最新的值 count = 2;</span></span><br><span class="line"><span class="keyword">const</span> handleClickRunDouble = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">handleClick(e);</span><br><span class="line">handleClick(e);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> (</span><br><span class="line">&lt;div&gt;</span><br><span class="line">&lt;button onclick=&#123;handleClick&#125;&gt;click here&lt;/button&gt;</span><br><span class="line">&lt;span&gt;&#123;count&#125;&lt;/span&gt;</span><br><span class="line">&lt;button onclick=&#123;handleClickRunDouble&#125;&gt;click here &amp; lunch <span class="number">2</span> times&lt;/button&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>以上 7 个就是我推荐和总结的几个<code>React</code><strong>代码整洁优化实践</strong> 。</p><p>最后，祝大家<strong>开发愉快</strong>！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h5 id=&quot;整洁的代码不仅仅是正常运行的代码，更是要求易于阅读、简单易懂、组织整齐。&quot;&gt;&lt;a href=&quot;#整洁的代码不仅仅是正常运行的代码，更是要求易于阅读、简单易懂、组织整齐。&quot; class=&quot;headerlink&quot; title=&quot;整洁的代码不仅仅是正常运行的代码，更是要</summary>
      
    
    
    
    <category term="大前端" scheme="https://blog.rexhang.com/categories/%E5%A4%A7%E5%89%8D%E7%AB%AF/"/>
    
    <category term="面试经" scheme="https://blog.rexhang.com/categories/%E5%A4%A7%E5%89%8D%E7%AB%AF/%E9%9D%A2%E8%AF%95%E7%BB%8F/"/>
    
    
    <category term="javascript" scheme="https://blog.rexhang.com/tags/javascript/"/>
    
    <category term="React" scheme="https://blog.rexhang.com/tags/React/"/>
    
    <category term="前端框架" scheme="https://blog.rexhang.com/tags/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>数组的一些常用方法及使用区别</title>
    <link href="https://blog.rexhang.com/2021/05/14/articles/1/"/>
    <id>https://blog.rexhang.com/2021/05/14/articles/1/</id>
    <published>2021-05-13T16:22:22.000Z</published>
    <updated>2022-10-25T14:41:49.325Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h3><p>push pop unshift shift splice slice split join 方法及使用区别</p><h3 id="二、示例"><a href="#二、示例" class="headerlink" title="二、示例"></a>二、示例</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// push pop unshift shift splice slice split join</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// push、unshift向数组的 尾部/头部 添加若干元素，并返回 数组的 新长度</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> a = arr.push(<span class="string">&#x27;X&#x27;</span>, <span class="string">&#x27;Y&#x27;</span>, <span class="string">&#x27;Z&#x27;</span>); <span class="comment">// -&gt; new length</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> b = arr.unshift(<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>); <span class="comment">// -&gt; new length</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(b);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr);</span><br><span class="line"></span><br><span class="line"><span class="comment">// pop、shift向数组的 尾部/头部 删除一个元素 并返回 数组中 被删除的元素</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> c = arr.pop(); <span class="comment">// -&gt; last item</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> d = arr.shift(); <span class="comment">// -&gt; first item</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(c);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(d);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> e = arr.push();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> f = [].pop();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> g = [].shift();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(e);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(f);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(g);</span><br><span class="line"></span><br><span class="line"><span class="comment">// splice 向/从数组中添加/删除项目，然后返回被删除的项目集合[?1, ?2]。 -1开始反方向删除(末尾第一个) 即便是负数 也都是从左到右删除单位</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> h = arr.splice(-<span class="number">2</span>, <span class="number">2</span>, <span class="string">&#x27;rex&#x27;</span>, <span class="string">&#x27;hang&#x27;</span>, <span class="string">&#x27;gu&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(h);</span><br><span class="line"></span><br><span class="line"><span class="comment">// slice 只对数组范围做截取 并返回 截取的内容</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> i = arr.slice(<span class="number">1</span>, -<span class="number">2</span>); <span class="comment">// 区间 -&gt; (?] 不包含末尾</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(i);</span><br><span class="line"></span><br><span class="line"><span class="comment">// split 用于 把一个有标记的字符串 分割成 标准数组</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> j = <span class="string">&#x27;a|b|c&#x27;</span>.split(<span class="string">&#x27;|&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(j);</span><br><span class="line"></span><br><span class="line"><span class="comment">// join 用于 把一个标准数组 变成 固定符号分隔的 字符串</span></span><br><span class="line"><span class="keyword">const</span> k = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>].join(<span class="string">&#x27;|&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(k);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr);</span><br></pre></td></tr></table></figure><p>控制台输出内容如图所示:<br><img src="/images/blog/2021-05-14/1.png" alt="效果图显示失败" title="运行效果如图"></p><p>看完上述例子后，我想大家都应该大致明白了这些方法的使用区别。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;一、前言&quot;&gt;&lt;a href=&quot;#一、前言&quot; class=&quot;headerlink&quot; title=&quot;一、前言&quot;&gt;&lt;/a&gt;一、前言&lt;/h3&gt;&lt;p&gt;push pop unshift shift splice slice split join 方法及使用区别&lt;/p&gt;
&lt;h3</summary>
      
    
    
    
    <category term="大前端" scheme="https://blog.rexhang.com/categories/%E5%A4%A7%E5%89%8D%E7%AB%AF/"/>
    
    <category term="面试经" scheme="https://blog.rexhang.com/categories/%E5%A4%A7%E5%89%8D%E7%AB%AF/%E9%9D%A2%E8%AF%95%E7%BB%8F/"/>
    
    
    <category term="javascript" scheme="https://blog.rexhang.com/tags/javascript/"/>
    
    <category term="javascript数组" scheme="https://blog.rexhang.com/tags/javascript%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>探讨下前端开发过程中在苹果系统下的一些兼容性小坑以及解决方案</title>
    <link href="https://blog.rexhang.com/2021/01/12/articles/1/"/>
    <id>https://blog.rexhang.com/2021/01/12/articles/1/</id>
    <published>2021-01-12T13:20:30.000Z</published>
    <updated>2022-10-25T14:41:49.324Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>导读: 本文会长期更新，目前仅写出已收集并且经过验证的案例分享🙉</p></blockquote><p>大家在做前端开发过程中势必会和H5打交道<code>&lt;这里指的H5仅表示在苹果系统下运行的H5&gt;</code>，在原本不应该出现的<strong>异常行为</strong>经常会搞得稀里糊涂，遂去各类搜索引擎搜索结局方案，本文故此摘录各类表现在苹果环境下的开发“异常行为”，并且给出大概可行的兼容方案来帮助大家单项搜集的烦恼</p><h3 id="可能存在兼容性问题搜集"><a href="#可能存在兼容性问题搜集" class="headerlink" title="可能存在兼容性问题搜集"></a>可能存在兼容性问题搜集</h3><hr><h4 id="1-Date-parse"><a href="#1-Date-parse" class="headerlink" title="1.Date.parse()"></a>1.Date.parse()</h4><blockquote><p>parse() 方法可解析一个日期时间字符串，并返回 1970/1/1 午夜距离该日期时间的毫秒数。<a href="https://www.w3school.com.cn/js/jsref_parse.asp">W3C参考文档</a></p></blockquote><p>代码部分:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Date</span>.parse(<span class="string">&quot;2020-02-02 00:00:00&quot;</span>)</span><br></pre></td></tr></table></figure><p>可能会在苹果环境中出现<code>NaN</code>的返回结果</p><p>解决方案是:</p><ol><li>不使用<strong>具体时间</strong> =&gt; <code>Date.parse(&quot;2020-02-02&quot;)</code></li><li>使用“**/<strong>”代替“</strong>-**”来分割日期 =&gt; <code>Date.parse(&quot;2020/02/02 00:00:00&quot;)</code></li><li>替换字符串为第二种方案 =&gt; <code>Date.parse(&quot;2020-02-02 00:00:00&quot;.replace(/-/g, &#39;/&#39;))</code></li></ol><h4 id="2-window-open"><a href="#2-window-open" class="headerlink" title="2.window.open()"></a>2.window.open()</h4><blockquote><p>open() 方法用于打开一个新的浏览器窗口或查找一个已命名的窗口。<a href="https://www.w3school.com.cn/jsref/met_win_open.asp">W3C参考文档</a></p></blockquote><p>代码部分:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.open(<span class="string">&#x27;//rexhang.com&#x27;</span>);</span><br></pre></td></tr></table></figure><p>可能会在苹果环境中出现被阻止打开的情况，这是由于苹果安全策略进行了拦截</p><p>解决方案是:</p><ol><li>使用<code>window.location.href = &#39;//rexhang.com&#39;</code>代替</li><li>使用<code>window.location.replace(&#39;//rexhang.com&#39;)</code>代替</li></ol><h4 id="3-待博主更新…"><a href="#3-待博主更新…" class="headerlink" title="3.待博主更新…"></a>3.待博主更新…</h4><h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><hr><p>这样的坑还有许多许多不仅仅是ios还有android也会存在一些兼容性问题，本文会长期更新，尽可能搜集更多的兼容案例，如有更多案例本文未提到的，希望大家踊跃提出，反馈在下方评论里，多谢大家~</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;导读: 本文会长期更新，目前仅写出已收集并且经过验证的案例分享🙉&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;大家在做前端开发过程中势必会和H5打交道&lt;code&gt;&amp;lt;这里指的H5仅表示在苹果系统下运行的H5&amp;gt;&lt;/code&gt;，在原本不应该出</summary>
      
    
    
    
    <category term="大前端" scheme="https://blog.rexhang.com/categories/%E5%A4%A7%E5%89%8D%E7%AB%AF/"/>
    
    <category term="兼容性" scheme="https://blog.rexhang.com/categories/%E5%A4%A7%E5%89%8D%E7%AB%AF/%E5%85%BC%E5%AE%B9%E6%80%A7/"/>
    
    <category term="心得" scheme="https://blog.rexhang.com/categories/%E5%A4%A7%E5%89%8D%E7%AB%AF/%E5%85%BC%E5%AE%B9%E6%80%A7/%E5%BF%83%E5%BE%97/"/>
    
    
    <category term="javascript" scheme="https://blog.rexhang.com/tags/javascript/"/>
    
    <category term="前端多端开发兼容性" scheme="https://blog.rexhang.com/tags/%E5%89%8D%E7%AB%AF%E5%A4%9A%E7%AB%AF%E5%BC%80%E5%8F%91%E5%85%BC%E5%AE%B9%E6%80%A7/"/>
    
    <category term="ios" scheme="https://blog.rexhang.com/tags/ios/"/>
    
    <category term="macos" scheme="https://blog.rexhang.com/tags/macos/"/>
    
    <category term="apple" scheme="https://blog.rexhang.com/tags/apple/"/>
    
    <category term="苹果" scheme="https://blog.rexhang.com/tags/%E8%8B%B9%E6%9E%9C/"/>
    
  </entry>
  
  <entry>
    <title>Vue双向绑定的原理</title>
    <link href="https://blog.rexhang.com/2021/01/10/articles/2/"/>
    <id>https://blog.rexhang.com/2021/01/10/articles/2/</id>
    <published>2021-01-10T07:56:57.000Z</published>
    <updated>2022-10-25T14:41:49.322Z</updated>
    
    <content type="html"><![CDATA[<h3 id="双向绑定原理及简单实现"><a href="#双向绑定原理及简单实现" class="headerlink" title="双向绑定原理及简单实现"></a>双向绑定原理及简单实现</h3><p>Vue是采用数据劫持结合发布者-订阅者模式的方式，通过new Proxy()来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。</p><blockquote><p>Vue3.x与Vue2.x的区别仅是数据劫持的方式由Object.defineProperty更改为Proxy代理，其他代码不变<br>Vue最核心的功能有两个，一是响应式的数据绑定系统，二是组件系统。本文仅探究双向绑定是怎样实现的。以及实现一个简化版的**<code>Vue-lite</code>**</p></blockquote><h4 id="一、访问器属性"><a href="#一、访问器属性" class="headerlink" title="一、访问器属性"></a>一、访问器属性</h4><p>访问器属性是对象中的一种特殊属性，它不能直接在对象中设置，而必须通过<code>defineProperty()</code>方法单独定义。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">&#x27;hello&#x27;</span>, &#123;</span><br><span class="line">    set: <span class="function"><span class="params">newVal</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;set方法被调用了&#x27;</span>);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;newVal=&#x27;</span>+newVal);</span><br><span class="line">    &#125;,</span><br><span class="line">    get: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;get方法被调用了&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">obj.hello = <span class="string">&#x27;xxx&#x27;</span>; <span class="comment">// 会触发访问器属性中的set方法 参数是xxx</span></span><br><span class="line">obj.hello <span class="comment">// 会触发访问器属性中的get方法</span></span><br></pre></td></tr></table></figure><p>其中**get(),set()**方法就是实现双向绑定的关键</p><h4 id="二、极简双向绑定的实现"><a href="#二、极简双向绑定的实现" class="headerlink" title="二、极简双向绑定的实现"></a>二、极简双向绑定的实现</h4><p>html部分:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;zh&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>Vue-lite<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;inputs&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">&quot;tips&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;btn&quot;</span>&gt;</span>设置新值<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;./js/Vue-lite.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Vue-lite.js:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> inputs = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;#inputs&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> tips = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;#tips&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> btn = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;#btn&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> obj = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">&#x27;hello&#x27;</span>, &#123;</span><br><span class="line">    set: <span class="function"><span class="params">newVal</span> =&gt;</span> &#123;</span><br><span class="line">        inputs.value = newVal;</span><br><span class="line">        tips.innerHTML = newVal;</span><br><span class="line">    &#125;,</span><br><span class="line">    get: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;get方法被调用了&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;123&#x27;</span>; <span class="comment">// 可以对值进行修改</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">obj.hello = <span class="string">&#x27;xxx&#x27;</span>; <span class="comment">// 会触发访问器属性中的set方法 参数是xxx</span></span><br><span class="line"><span class="built_in">console</span>.log(obj.hello); <span class="comment">// 会触发访问器属性中的get方法</span></span><br><span class="line">inputs.addEventListener(<span class="string">&#x27;keyup&#x27;</span>, <span class="function"><span class="params">e</span>=&gt;</span>&#123;</span><br><span class="line">    obj.hello = e.target.value;</span><br><span class="line">&#125;);</span><br><span class="line">btn.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="params">e</span>=&gt;</span>&#123;</span><br><span class="line">    obj.hello = <span class="string">&#x27;233&#x27;</span>; <span class="comment">// set数据</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 实现了 model =&gt; view 以及 view =&gt; model 的双向绑定。</span></span><br><span class="line"><span class="comment">// 以上就是 Vue2.x 实现双向绑定的基本原理。</span></span><br></pre></td></tr></table></figure><p>此例实现的效果是：随文本框输入文字的变化，span 中会同步显示相同的文字内容；在js或控制台显式的修改 obj.hello 的值，视图会相应更新。这样就实现了 model =&gt; view 以及 view =&gt; model 的双向绑定，就是Vue实现双向绑定的最基本原理。</p><h4 id="三、细节优化"><a href="#三、细节优化" class="headerlink" title="三、细节优化"></a>三、细节优化</h4><p>上述示例仅仅是为了说明原理。我们最终要实现的是：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span>&gt;</span>姓名: <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">v-mode</span>=<span class="string">&quot;name&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>您输入的name是: &#123;&#123;name&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">    data: &#123;</span><br><span class="line">        name: <span class="string">&#x27;rexhang&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>首先做下需要实现功能点:</p><ol><li>输入框以及文本节点与 data 中的数据绑定</li><li>输入框内容变化时，data 中的数据同步变化。即 view =&gt; model 的变化</li><li>data 中的数据变化时，文本节点的内容同步变化。即 model =&gt; view 的变化</li></ol><p>html:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;name&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line">    &#123;&#123;name&#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;./js/Vue-lite.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">        el: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line">        data: &#123;</span><br><span class="line"><span class="javascript">            name: <span class="string">&#x27;rexhang&#x27;</span></span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Vue-lite.js:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">nodeToFragment</span>(<span class="params">node, vm</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// createDocumentFragment()方法，是用来创建一个虚拟的节点对象，或者说，是用来创建文档碎片节点。它可以包含各种类型的节点，在创建之初是空的。</span></span><br><span class="line">    <span class="keyword">let</span> virtualDOM = <span class="built_in">document</span>.createDocumentFragment();</span><br><span class="line">    <span class="keyword">let</span> child;</span><br><span class="line">    <span class="keyword">while</span>( child = node.firstChild)&#123;</span><br><span class="line">        compile(child, vm)</span><br><span class="line">        virtualDOM.appendChild(child);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> virtualDOM;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compile</span> (<span class="params">node, vm</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> reg = <span class="regexp">/\&#123;\&#123;(.*)\&#125;\&#125;/</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(node);</span><br><span class="line">    <span class="built_in">console</span>.log(node.nodeType);</span><br><span class="line">    <span class="keyword">if</span> (node.nodeType === <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="comment">// 节点类型是元素</span></span><br><span class="line">        <span class="keyword">const</span> attr = node.attributes;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; attr.length; i++)&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(attr[i].nodeName);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(attr[i].nodeName === <span class="string">&#x27;v-model&#x27;</span>)&#123;</span><br><span class="line">                <span class="comment">// 提取v-model的value</span></span><br><span class="line">                <span class="keyword">const</span> name = attr[i].nodeValue;</span><br><span class="line"></span><br><span class="line">                node.addEventListener(<span class="string">&#x27;input&#x27;</span>, <span class="function"><span class="params">e</span>=&gt;</span>&#123;</span><br><span class="line">                    vm[name] = e.target.value;</span><br><span class="line">                &#125;);</span><br><span class="line">                <span class="comment">// 将data的值赋给该node</span></span><br><span class="line">                <span class="comment">// node.value = vm.data[name];</span></span><br><span class="line">                node.value = vm[name];</span><br><span class="line">                node.removeAttribute(<span class="string">&#x27;v-model&#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (node.nodeType === <span class="number">3</span>)&#123;</span><br><span class="line">        <span class="comment">// 节点类型是text</span></span><br><span class="line">        <span class="keyword">if</span>(reg.test(node.nodeValue))&#123;</span><br><span class="line">            <span class="comment">// 正则来获取匹配到的字符串&#123;&#123;name&#125;&#125; =&gt; name</span></span><br><span class="line">            <span class="keyword">let</span> name = node.nodeValue.match(reg)[<span class="number">1</span>].trim();</span><br><span class="line">            <span class="comment">// 将data的值赋给该node</span></span><br><span class="line">            <span class="comment">// node.nodeValue = vm.data[name];</span></span><br><span class="line">            <span class="comment">// node.nodeValue = vm[name];</span></span><br><span class="line">            <span class="built_in">console</span>.log(vm, node, name);</span><br><span class="line">            <span class="keyword">new</span> Watcher(vm, node, name);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">defineReactive</span>(<span class="params">obj, key, val</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> dep = <span class="keyword">new</span> Dep();</span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(obj, key, &#123;</span><br><span class="line">        set: <span class="function"><span class="params">newVal</span> =&gt;</span>　&#123;</span><br><span class="line">            <span class="keyword">if</span>(newVal === val) <span class="keyword">return</span>;</span><br><span class="line">            val = newVal;</span><br><span class="line">            <span class="built_in">console</span>.log(val);</span><br><span class="line">            dep.notify();</span><br><span class="line">        &#125;,</span><br><span class="line">        get: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(Dep.target) dep.addSub(Dep.target);</span><br><span class="line">            <span class="keyword">return</span> val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">observe</span> (<span class="params">obj, vm</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">Object</span>.keys(obj).forEach(<span class="function"><span class="params">key</span>=&gt;</span>&#123;</span><br><span class="line">        defineReactive(vm, key, obj[key]);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> dep = <span class="keyword">new</span> Dep();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> pub = &#123;</span><br><span class="line">    publish: <span class="function">()=&gt;</span>&#123;</span><br><span class="line">        dep.notify();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> sub1 = &#123; <span class="attr">update</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="number">1</span>); &#125; &#125;</span><br><span class="line"><span class="keyword">const</span> sub2 = &#123; <span class="attr">update</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="number">2</span>); &#125; &#125;</span><br><span class="line"><span class="keyword">const</span> sub3 = &#123; <span class="attr">update</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="number">3</span>); &#125; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Dep</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// this.subs = [sub1, sub2, sub3];</span></span><br><span class="line">    <span class="built_in">this</span>.subs = [];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Dep.prototype.notify = function()&#123;</span></span><br><span class="line"><span class="comment">//     this.subs.forEach(sub=&gt;&#123;</span></span><br><span class="line"><span class="comment">//         sub.update();</span></span><br><span class="line"><span class="comment">//     &#125;)</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">Dep.prototype.addSub = <span class="function"><span class="keyword">function</span>(<span class="params">sub</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.subs.push(sub)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Dep.prototype.notify = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.subs.forEach(<span class="function"><span class="params">sub</span>=&gt;</span>&#123;</span><br><span class="line">        sub.update();</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pub.publish();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Watcher</span>(<span class="params">vm, node, name</span>)</span>&#123;</span><br><span class="line">    Dep.target = <span class="built_in">this</span>;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">    <span class="built_in">this</span>.node = node;</span><br><span class="line">    <span class="built_in">this</span>.vm = vm;</span><br><span class="line">    <span class="built_in">this</span>.update();</span><br><span class="line">    Dep.target = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Watcher.prototype = &#123;</span><br><span class="line">    update: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.get();</span><br><span class="line">        <span class="built_in">this</span>.node.nodeValue = <span class="built_in">this</span>.value;</span><br><span class="line">    &#125;,</span><br><span class="line">    get: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.value = <span class="built_in">this</span>.vm[<span class="built_in">this</span>.name];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Vue</span>(<span class="params">opt</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.data = opt.data;</span><br><span class="line">    observe(<span class="built_in">this</span>.data, <span class="built_in">this</span>);</span><br><span class="line">    <span class="keyword">const</span> rootDom = opt.el;</span><br><span class="line">    <span class="keyword">const</span> dom = nodeToFragment(<span class="built_in">document</span>.querySelector(rootDom), <span class="built_in">this</span>);</span><br><span class="line">    <span class="comment">// 编译完成，将dom返回到app中</span></span><br><span class="line">    <span class="built_in">document</span>.querySelector(rootDom).appendChild(dom);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终实现效果:<br><img src="/images/blog/2021-01-10/1.gif" alt="效果图显示失败" title="运行效果如图"></p><h4 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h4><blockquote><ul><li><strong><code>Object.defineProperty</code></strong> 来进行数据中转(劫持)，从而实现事件的发布和后续触发订阅者的监听来实现数据绑定</li><li>实现一个监听器 <strong><code>observe</code></strong> 用来劫持并监听所有属性，如有变动，就通知订阅者</li><li>实现一个订阅者 <strong><code>Watcher</code></strong> 每个Watcher都绑定一个更新函数，可以把收到的属性变化通知并执行相应的函数，更新视图</li><li>实现一个解析器 <strong><code>compile</code></strong> 可以循环解析全部节点获取相关指令，初始化数据，初始化订阅</li></ul></blockquote><p><a href="https://www.cnblogs.com/kidney/p/6052935.html?utm_source=gold_browser_extension" title="点击跳转到参考链接">原文参考</a> <a href="https://blog.csdn.net/weixin_44489221/article/details/102668017" title="点击跳转到参考链接">Vue3.x双向绑定原理的实现参考</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;双向绑定原理及简单实现&quot;&gt;&lt;a href=&quot;#双向绑定原理及简单实现&quot; class=&quot;headerlink&quot; title=&quot;双向绑定原理及简单实现&quot;&gt;&lt;/a&gt;双向绑定原理及简单实现&lt;/h3&gt;&lt;p&gt;Vue是采用数据劫持结合发布者-订阅者模式的方式，通过new Pro</summary>
      
    
    
    
    <category term="大前端" scheme="https://blog.rexhang.com/categories/%E5%A4%A7%E5%89%8D%E7%AB%AF/"/>
    
    <category term="面试经" scheme="https://blog.rexhang.com/categories/%E5%A4%A7%E5%89%8D%E7%AB%AF/%E9%9D%A2%E8%AF%95%E7%BB%8F/"/>
    
    
    <category term="javascript" scheme="https://blog.rexhang.com/tags/javascript/"/>
    
    <category term="前端框架" scheme="https://blog.rexhang.com/tags/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/"/>
    
    <category term="Vue" scheme="https://blog.rexhang.com/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>几种判断数组的方法</title>
    <link href="https://blog.rexhang.com/2021/01/10/articles/1/"/>
    <id>https://blog.rexhang.com/2021/01/10/articles/1/</id>
    <published>2021-01-09T16:01:22.000Z</published>
    <updated>2022-10-25T14:41:49.323Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h3><p>众所周知，js是门“动态”、“弱类型”编程语言，这意味着在js中可以任性定义变量，同时，“任性”也意味着需常在项目开发中对变量做类型判断，曾几何时，对数组变量的类型判断是件很痛苦的事情，开发人员想出多种方案来对数组做出准确的类型判断，但效果不佳，直到ES5标准“入主中原”，判断数组类型有了标准的isArray()官方利剑，才降伏了数组类型判断这条恶龙，世间得一清，但在此之前开发者是如何判断数组类型的？判断数组类型为何会如此玄学？为何要判断数组类型？带着这些疑问，吾跋山涉水，探寻各方资料，整理消化后遂成此文，以记之。</p><h3 id="二、判断js数组类型为何麻烦？"><a href="#二、判断js数组类型为何麻烦？" class="headerlink" title="二、判断js数组类型为何麻烦？"></a>二、判断js数组类型为何麻烦？</h3><h4 id="1、语言本身的“缺陷”"><a href="#1、语言本身的“缺陷”" class="headerlink" title="1、语言本身的“缺陷”"></a>1、语言本身的“缺陷”</h4><p>js是门“动态”“弱类型”编程语言，这意味着js在定义和使用变量时可以“任性”，在ES6之前，我们定义变量一般使用“var”来定义：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;jack&#x27;</span>;</span><br><span class="line">name = <span class="number">20</span>;</span><br><span class="line">name = [<span class="string">&#x27;aa&#x27;</span>];</span><br></pre></td></tr></table></figure><p>在上述例子中，name变量初始定义为字符串类型，而后变为数字类型，最后摇身一变成为数组类型，这种任性摇摆的特性就是其“动态”特性，在java中我们定义一个字符串变量须如此定义：String name = ‘jack’，java通过一个String前缀“显式的”、“强制的”指定name变量为字符串类型，之后不得对该name变量进行类型变换(如果执行name = 22将会报type类型转换错误)，但js采用的是弱类型定义方案，在定义变量时使用var声明了一个变量，弱化了类型前缀的限制，并没强制锁死变量类型，之后可以随意更改其类型。动态弱类型这种声明变量的方案用起来可以随性而为，无须顾虑太多，随性的代码书写如若不加管制必将招致灾难性的代码bug。</p><h4 id="2、js类型判断的“不足”"><a href="#2、js类型判断的“不足”" class="headerlink" title="2、js类型判断的“不足”"></a>2、js类型判断的“不足”</h4><p>其实动态弱类型的语言特性并不是决定js判断数组类型麻烦的必然原因，js语言因为历史原因，其创造者在开发之初将其定位为简单的网页小助手语言，为了轻巧、快速的完成小任务开发选择了“动态弱类型”的语言方案，PHP亦为动态弱类型语言，但在处理类型判断时，PHP用一个<code>gettype()</code>方法可以轻松、精准的搞定(<strong>PHP作为世界上世界上最好的语言还是有点东西的</strong>🤣)，PHP有<code>gettype()</code>这枚银弹，js有吗，嗯，算有吧，js最常用的是用<code>typeof</code>操作符来获取数据类型，看<code>typeof</code>这个名字是不是感觉很厉害？感觉会跟PHP一样轻松简单？但随后你会发现：<code>typeof</code>操作符是个很局限的类型获取方案，用它对基本数据类型做判断还算过得去，但在涉及到引用类型判断这种细活时就显得很low了…</p><h3 id="三、判断js数组类型的几个“方案”"><a href="#三、判断js数组类型的几个“方案”" class="headerlink" title="三、判断js数组类型的几个“方案”"></a>三、判断js数组类型的几个“方案”</h3><h3 id="1-typeof-❌"><a href="#1-typeof-❌" class="headerlink" title="1.typeof ❌"></a>1.<del><code>typeof</code></del> ❌</h3><blockquote><p>typeof在判断基础数据类型时尚有问题，更别说用来判断子孙繁多的引用类型了，typeof在判断引用类型时一刀切的统统返回object, 如</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> arr = [];</span><br><span class="line"><span class="keyword">var</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">typeof</span> obj; <span class="comment">// object</span></span><br><span class="line"><span class="keyword">typeof</span> arr; <span class="comment">// object</span></span><br><span class="line"><span class="keyword">typeof</span> map; <span class="comment">// object</span></span><br></pre></td></tr></table></figure><p>故此，不适应于判断数据，<strong>PASS</strong></p><h3 id="2-data-instanceof-Array-❌"><a href="#2-data-instanceof-Array-❌" class="headerlink" title="2.data instanceof Array ❌"></a>2.<del><code>data instanceof Array</code></del> ❌</h3><blockquote><p>instanceof是js用来判断继承关系的运算符（js基于原型链实现继承，故instanceof判断的就是对应的类是否存在于变量的原型链上），根据这个特性可以如此来判断数组类型：</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="built_in">console</span>.log(arr <span class="keyword">instanceof</span> <span class="built_in">Array</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>控制台打印显示如下:</p><p><img src="/images/blog/2021-01-10/1.png" alt="效果图显示失败" title="运行效果如图"></p><p>从打印的结果可以看到Array存在于数组[1, 2, 3]的原型链上，故[1, 2, 3] instanceof Array === true; 利用instanceof的这个特性可以判断数组类型，但是instanceof运算符有个弊端 就是<code>arr instanceof Object</code>也是返回<code>true</code>:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr2 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="built_in">console</span>.log(arr2 <span class="keyword">instanceof</span> <span class="built_in">Object</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>控制台打印显示如下:</p><p><img src="/images/blog/2021-01-10/2.png" alt="效果图显示失败" title="运行效果如图"></p><p>故此，不适应于判断数据，<strong>PASS</strong></p><h3 id="3-constructor-✔"><a href="#3-constructor-✔" class="headerlink" title="3.constructor ✔"></a>3.<code>constructor</code> ✔</h3><blockquote><p>在<strong>JavaScript</strong>中, <code>constructor</code>属性会返回对象的构造函数。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="built_in">console</span>.log(arr.constructor === <span class="built_in">Array</span>); <span class="comment">// true</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="built_in">console</span>.log(arr.constructor === <span class="built_in">Object</span>); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>控制台打印显示如下:</p><p><img src="/images/blog/2021-01-10/3.png" alt="效果图显示失败" title="运行效果如图"></p><p>从打印结果显示，是满足我们的数据类型判断的，并且没有出现第二种判断方式<code>instanceof</code>方法的问题，<strong>因此是可以采用的</strong>。</p><h3 id="4-Object-prototype-toString-✔"><a href="#4-Object-prototype-toString-✔" class="headerlink" title="4.Object.prototype.toString() ✔"></a>4.<code>Object.prototype.toString()</code> ✔</h3><blockquote><p>Object.prototype.toString()能获取到变量的“类目名”，在js中万物皆为对象，万物皆有“类目名”，每个变量、对象、数组等都有一个唯一的类目名（这个类目名类似于人类给各类动植物起的“学名”），该方案通过获取目标变量的类目名([object Array])进行判断，如果类目名一致则证明目标变量为数组类型：</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="built_in">console</span>.log( <span class="built_in">Object</span>.prototype.toString.call(arr) === <span class="string">&#x27;[object Array]&#x27;</span> ); <span class="comment">// [object Array]: string; 返回 true</span></span><br></pre></td></tr></table></figure><p>Tips: 这种方法获取各种类型数据都有与之对应的字符串匹配值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.prototype.toString.call([]); <span class="comment">// &quot;[object Array]&quot;</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(&#123;&#125;); <span class="comment">// &quot;[object Object]&quot;</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="string">&#x27;&#x27;</span>); <span class="comment">// &quot;[object String]&quot;</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="number">1</span>); <span class="comment">// &quot;[object Number]&quot;</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;&#125;); <span class="comment">// &quot;[object Function]&quot;</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(); <span class="comment">// &quot;[object Undefined]&quot;</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="literal">null</span>); <span class="comment">// &quot;[object Null]&quot;</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="built_in">document</span>); <span class="comment">// &quot;[object HTMLDocument]&quot;</span></span><br></pre></td></tr></table></figure><p>从打印结果显示，是满足我们的数据类型判断的，<strong>因此是可以采用的</strong>。</p><h3 id="5-Array-isArray-✔"><a href="#5-Array-isArray-✔" class="headerlink" title="5.Array.isArray() ✔"></a>5.<code>Array.isArray()</code> ✔</h3><blockquote><p>该方法是ES5标准规定的判断数组类型的标准方法，虽然Object.prototype.toString()方法可用来判断数组类型，但未免显得有点hack，又因自家typeof类型操作符给予厚望，辱没众望，如果随便更改typeof的返回结果势必会导致天下大乱，instanceof运算符又存在不同frame的局限性难堪大任，ES5不得不亡羊补牢的设计了isArray()方法来“增量”的解决数组判断难题。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.isArray([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Array</span>.isArray(&#123;&#125;); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>从打印结果显示，是满足我们的数据类型判断的，<strong>因此是可以采用的</strong>。</p><h3 id="四、为何要判断数组类型？"><a href="#四、为何要判断数组类型？" class="headerlink" title="四、为何要判断数组类型？"></a>四、为何要判断数组类型？</h3><p>前面说过js属于动态弱类型语言，可能某个变量用着用着就莫名其妙的变了类型（自己不小心更改类型，引入的第三方代码库，因为同名变量改变了类型），如果你设想的是某个变量为数组类型，但因某个逻辑变成了基本类型，这时如果调用数组的方法注定会报错，凡此种种导致的问题，数不胜数，具体的问题实践多了懂得就懂。</p><h3 id="五、结语"><a href="#五、结语" class="headerlink" title="五、结语"></a>五、结语</h3><p>近几年前端项目愈发复杂庞大，为更好的构建高性能的前端项目，诞生了“react、angular、vue”等数据驱动型解决方案，大量的数据、大量的组件和类对数据类型的判断需求愈发频繁，但因为js动态弱类型语言特性，加之其类型判断的坑爹性，所以各路开发者希望完善和升级js，在ES6标准中，新的const变量定义方案能很好的应对变量动态性问题，微软开发的“typescript”能够实现强类型变量定义，可应对弱类型定义问题。这些方案极大的减少了早期js变量任性定义带来的各种问题，虽然判断数组类型在未来开发中可能会成为历史云烟，但理解其相关的基础和历史演变却是一件很【浪漫】的事情，因为在理解了它的相关坑爹性和进化史有助于我们更好的思考和优化。爱之深，责之切，希望js能在未来变得更加锋利可靠，也希望少为一些坑爹特性而想出一些hack方案(额，比如——&gt;Object.prototype.toString()方法)。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;一、前言&quot;&gt;&lt;a href=&quot;#一、前言&quot; class=&quot;headerlink&quot; title=&quot;一、前言&quot;&gt;&lt;/a&gt;一、前言&lt;/h3&gt;&lt;p&gt;众所周知，js是门“动态”、“弱类型”编程语言，这意味着在js中可以任性定义变量，同时，“任性”也意味着需常在项目开发中对变</summary>
      
    
    
    
    <category term="大前端" scheme="https://blog.rexhang.com/categories/%E5%A4%A7%E5%89%8D%E7%AB%AF/"/>
    
    <category term="面试经" scheme="https://blog.rexhang.com/categories/%E5%A4%A7%E5%89%8D%E7%AB%AF/%E9%9D%A2%E8%AF%95%E7%BB%8F/"/>
    
    
    <category term="javascript" scheme="https://blog.rexhang.com/tags/javascript/"/>
    
    <category term="javascript数组" scheme="https://blog.rexhang.com/tags/javascript%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>javascript函数防抖与节流</title>
    <link href="https://blog.rexhang.com/2021/01/05/articles/2/"/>
    <id>https://blog.rexhang.com/2021/01/05/articles/2/</id>
    <published>2021-01-04T18:03:33.000Z</published>
    <updated>2022-10-25T14:41:49.323Z</updated>
    
    <content type="html"><![CDATA[<h3 id="概念和例子"><a href="#概念和例子" class="headerlink" title="概念和例子"></a>概念和例子</h3><h4 id="函数防抖-debounce"><a href="#函数防抖-debounce" class="headerlink" title="函数防抖(debounce)"></a>函数防抖(debounce)</h4><blockquote><p>在事件被触发n秒后再执行回调，如果在这n秒内又被触发，则重新计时。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 模拟一段ajax请求</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ajax</span>(<span class="params">content</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;ajax request &#x27;</span> + content)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> inputa = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;unDebounce&#x27;</span>)</span><br><span class="line"></span><br><span class="line">inputa.addEventListener(<span class="string">&#x27;keyup&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">    ajax(e.target.value)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>运行效果如图:</p><p><img src="/images/blog/2021-01-05/165a252be5c94d6b.gif" alt="效果图显示失败" title="运行效果如图"></p><p>可以看到，我们只要按下键盘，就会触发这次ajax请求。不仅从资源上来说是很浪费的行为，而且实际应用中，用户也是输出完整的字符后，才会请求。下面我们优化一下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 模拟一段ajax请求</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ajax</span>(<span class="params">content</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;ajax request &#x27;</span> + content)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">fun, delay</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">args</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> that = <span class="built_in">this</span></span><br><span class="line">        <span class="keyword">let</span> _args = args</span><br><span class="line">        <span class="built_in">clearTimeout</span>(fun.id)</span><br><span class="line">        fun.id = <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            fun.call(that, _args)</span><br><span class="line">        &#125;, delay)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">let</span> inputb = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;debounce&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> debounceAjax = debounce(ajax, <span class="number">500</span>)</span><br><span class="line"></span><br><span class="line">inputb.addEventListener(<span class="string">&#x27;keyup&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">    debounceAjax(e.target.value)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>运行效果如图:</p><p><img src="/images/blog/2021-01-05/165a252b4b429b56.gif" alt="效果图显示失败" title="运行效果如图"></p><p>可以看到，我们加入了防抖以后，当你在频繁的输入时，并不会发送请求，只有当你在指定间隔内没有输入时，才会执行函数。如果停止输入但是在指定间隔内又输入，会重新触发计时。</p><blockquote><p>个人理解 函数防抖就是法师发技能的时候要读条，技能读条没完再按技能就会重新读条。</p></blockquote><h4 id="函数节流-throttle"><a href="#函数节流-throttle" class="headerlink" title="函数节流(throttle)"></a>函数节流(throttle)</h4><blockquote><p>规定在一个单位时间内，只能触发一次函数。如果这个单位时间内触发多次函数，只有一次生效。</p></blockquote><p>看代码:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">fun, delay</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> last, deferTimer</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">args</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> that = <span class="built_in">this</span></span><br><span class="line">        <span class="keyword">let</span> _args = <span class="built_in">arguments</span></span><br><span class="line">        <span class="keyword">let</span> now = +<span class="keyword">new</span> <span class="built_in">Date</span>()</span><br><span class="line">        <span class="keyword">if</span> (last &amp;&amp; now &lt; last + delay) &#123;</span><br><span class="line">            <span class="built_in">clearTimeout</span>(deferTimer)</span><br><span class="line">            deferTimer = <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                last = now</span><br><span class="line">                fun.apply(that, _args)</span><br><span class="line">            &#125;, delay)</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            last = now</span><br><span class="line">            fun.apply(that,_args)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> throttleAjax = throttle(ajax, <span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> inputc = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;throttle&#x27;</span>)</span><br><span class="line">inputc.addEventListener(<span class="string">&#x27;keyup&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">    throttleAjax(e.target.value)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>看一下运行结果:</p><p><img src="/images/blog/2021-01-05/165a252b4c1a9686.gif" alt="效果图显示失败" title="运行效果如图"></p><p>可以看到，我们在不断输入时，ajax会按照我们设定的时间，每1s执行一次。</p><blockquote><p>个人理解 函数节流就是fps游戏的射速，就算一直按着鼠标射击，也只会在规定射速内射出子弹。</p></blockquote><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>函数防抖和函数节流都是防止某一时间频繁触发，但是这两兄弟之间的原理却不一样。</li><li>函数防抖是某一段时间内只执行一次，而函数节流是间隔时间执行。</li></ul><h4 id="结合应用场景"><a href="#结合应用场景" class="headerlink" title="结合应用场景"></a>结合应用场景</h4><ul><li>防抖(debounce)<ul><li>search搜索联想，用户在不断输入值时，用防抖来节约请求资源。</li><li>window触发resize的时候，不断的调整浏览器窗口大小会不断的触发这个事件，用防抖来让其只触发一次</li></ul></li><li>节流（throttle）<ul><li>鼠标不断点击触发，mousedown(单位时间内只触发一次)</li><li>监听滚动事件，比如是否滑到底部自动加载更多，用throttle来判断</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;概念和例子&quot;&gt;&lt;a href=&quot;#概念和例子&quot; class=&quot;headerlink&quot; title=&quot;概念和例子&quot;&gt;&lt;/a&gt;概念和例子&lt;/h3&gt;&lt;h4 id=&quot;函数防抖-debounce&quot;&gt;&lt;a href=&quot;#函数防抖-debounce&quot; class=&quot;header</summary>
      
    
    
    
    <category term="大前端" scheme="https://blog.rexhang.com/categories/%E5%A4%A7%E5%89%8D%E7%AB%AF/"/>
    
    <category term="面试经" scheme="https://blog.rexhang.com/categories/%E5%A4%A7%E5%89%8D%E7%AB%AF/%E9%9D%A2%E8%AF%95%E7%BB%8F/"/>
    
    
    <category term="javascript" scheme="https://blog.rexhang.com/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>如何创建一个TC的免费托管服务</title>
    <link href="https://blog.rexhang.com/2021/01/05/articles/1/"/>
    <id>https://blog.rexhang.com/2021/01/05/articles/1/</id>
    <published>2021-01-04T17:06:21.000Z</published>
    <updated>2022-10-25T14:41:49.324Z</updated>
    
    <content type="html"><![CDATA[<h3 id="首先"><a href="#首先" class="headerlink" title="首先"></a>首先</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;需要先全局安装cli, 本地预先安装好nodejs以及git</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm i -g @cloudbase/cli hexo-cli</span><br></pre></td></tr></table></figure><h3 id="然后"><a href="#然后" class="headerlink" title="然后"></a>然后</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;初始化一个hexo项目目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo init</span><br></pre></td></tr></table></figure><p>初始化完毕后, 启动服务本地编写文章</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo s</span><br></pre></td></tr></table></figure><h3 id="发布"><a href="#发布" class="headerlink" title="发布"></a>发布</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;发布就很简单了，获取授权，生成静态代码，使用cli推送到远程托管</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ cloudbase login</span><br><span class="line">$ hexo g</span><br><span class="line">$ cloudbase hosting deploy public -e [EnvID]</span><br></pre></td></tr></table></figure><h3 id="tips"><a href="#tips" class="headerlink" title="tips"></a>tips</h3><ul><li>环境ID(EnvID)获取方法: <a href="https://console.cloud.tencent.com/tcb/env/index?rid=4&tdl_anchor=qcloud&tdl_site=free">链接</a></li><li>创建环境指引: <a href="https://cloud.tencent.com/document/product/876/47006">链接</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;首先&quot;&gt;&lt;a href=&quot;#首先&quot; class=&quot;headerlink&quot; title=&quot;首先&quot;&gt;&lt;/a&gt;首先&lt;/h3&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;需要先全局安装cli, 本地预先安装好nodejs以及git&lt;/p&gt;
&lt;figure cla</summary>
      
    
    
    
    <category term="腾讯云" scheme="https://blog.rexhang.com/categories/%E8%85%BE%E8%AE%AF%E4%BA%91/"/>
    
    <category term="操作技巧" scheme="https://blog.rexhang.com/categories/%E8%85%BE%E8%AE%AF%E4%BA%91/%E6%93%8D%E4%BD%9C%E6%8A%80%E5%B7%A7/"/>
    
    
    <category term="腾讯云" scheme="https://blog.rexhang.com/tags/%E8%85%BE%E8%AE%AF%E4%BA%91/"/>
    
  </entry>
  
</feed>
