<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Chapter 3. Types, Values, and Variables | 《JavaScript 权威指南第七版》中文翻译</title>
    <meta name="generator" content="VuePress 1.9.10">
    
    <meta name="description" content="">
    
    <link rel="preload" href="/ebook/doc-jstdg7/assets/css/0.styles.2be65113.css" as="style"><link rel="preload" href="/ebook/doc-jstdg7/assets/js/app.c9a3fcc3.js" as="script"><link rel="preload" href="/ebook/doc-jstdg7/assets/js/2.d222cfdb.js" as="script"><link rel="preload" href="/ebook/doc-jstdg7/assets/js/1.7462a745.js" as="script"><link rel="preload" href="/ebook/doc-jstdg7/assets/js/34.6342948c.js" as="script"><link rel="prefetch" href="/ebook/doc-jstdg7/assets/js/10.93b4f749.js"><link rel="prefetch" href="/ebook/doc-jstdg7/assets/js/11.5e44f9f1.js"><link rel="prefetch" href="/ebook/doc-jstdg7/assets/js/12.65d08f50.js"><link rel="prefetch" href="/ebook/doc-jstdg7/assets/js/13.6bcb3793.js"><link rel="prefetch" href="/ebook/doc-jstdg7/assets/js/14.1f3b8559.js"><link rel="prefetch" href="/ebook/doc-jstdg7/assets/js/15.de05e356.js"><link rel="prefetch" href="/ebook/doc-jstdg7/assets/js/16.4a1dc3df.js"><link rel="prefetch" href="/ebook/doc-jstdg7/assets/js/17.0a3a3e12.js"><link rel="prefetch" href="/ebook/doc-jstdg7/assets/js/18.81a56757.js"><link rel="prefetch" href="/ebook/doc-jstdg7/assets/js/19.ca0120fa.js"><link rel="prefetch" href="/ebook/doc-jstdg7/assets/js/20.03b27e97.js"><link rel="prefetch" href="/ebook/doc-jstdg7/assets/js/21.e943f9a6.js"><link rel="prefetch" href="/ebook/doc-jstdg7/assets/js/22.1395e8d5.js"><link rel="prefetch" href="/ebook/doc-jstdg7/assets/js/23.58e9e744.js"><link rel="prefetch" href="/ebook/doc-jstdg7/assets/js/24.bd12211b.js"><link rel="prefetch" href="/ebook/doc-jstdg7/assets/js/25.4f749cef.js"><link rel="prefetch" href="/ebook/doc-jstdg7/assets/js/26.1e53a1a7.js"><link rel="prefetch" href="/ebook/doc-jstdg7/assets/js/27.3390ad8d.js"><link rel="prefetch" href="/ebook/doc-jstdg7/assets/js/28.33090939.js"><link rel="prefetch" href="/ebook/doc-jstdg7/assets/js/29.3f6c68a4.js"><link rel="prefetch" href="/ebook/doc-jstdg7/assets/js/3.a04e1a1f.js"><link rel="prefetch" href="/ebook/doc-jstdg7/assets/js/30.2c1bccf9.js"><link rel="prefetch" href="/ebook/doc-jstdg7/assets/js/31.65f5d502.js"><link rel="prefetch" href="/ebook/doc-jstdg7/assets/js/32.62613211.js"><link rel="prefetch" href="/ebook/doc-jstdg7/assets/js/33.663d7953.js"><link rel="prefetch" href="/ebook/doc-jstdg7/assets/js/35.f60ecfb8.js"><link rel="prefetch" href="/ebook/doc-jstdg7/assets/js/36.4c626f38.js"><link rel="prefetch" href="/ebook/doc-jstdg7/assets/js/37.5a0f22a8.js"><link rel="prefetch" href="/ebook/doc-jstdg7/assets/js/38.dfc2e895.js"><link rel="prefetch" href="/ebook/doc-jstdg7/assets/js/39.83c2ffdc.js"><link rel="prefetch" href="/ebook/doc-jstdg7/assets/js/4.e26ea152.js"><link rel="prefetch" href="/ebook/doc-jstdg7/assets/js/40.769847d8.js"><link rel="prefetch" href="/ebook/doc-jstdg7/assets/js/5.179c23af.js"><link rel="prefetch" href="/ebook/doc-jstdg7/assets/js/6.1bf2641a.js"><link rel="prefetch" href="/ebook/doc-jstdg7/assets/js/7.f48746dc.js"><link rel="prefetch" href="/ebook/doc-jstdg7/assets/js/vendors~docsearch.68b347c4.js">
    <link rel="stylesheet" href="/ebook/doc-jstdg7/assets/css/0.styles.2be65113.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/ebook/doc-jstdg7/" class="home-link router-link-active"><!----> <span class="site-name">《JavaScript 权威指南第七版》中文翻译</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"> <a href="https://github.com/rexhang/rexhang.github.io/ebook/doc-jstdg7" target="_blank" rel="noopener noreferrer" class="repo-link">
    gitee
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"> <a href="https://github.com/rexhang/rexhang.github.io/ebook/doc-jstdg7" target="_blank" rel="noopener noreferrer" class="repo-link">
    gitee
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav>  <ul class="sidebar-links"><li><a href="/ebook/doc-jstdg7/" aria-current="page" class="sidebar-link">目录</a></li><li><a href="/ebook/doc-jstdg7/ch1.html" class="sidebar-link">Chapter 1. Introduction to JavaScript</a></li><li><a href="/ebook/doc-jstdg7/ch2.html" class="sidebar-link">Chapter 2. Lexical Structure</a></li><li><a href="/ebook/doc-jstdg7/ch3.html" aria-current="page" class="active sidebar-link">Chapter 3. Types, Values, and Variables</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/ebook/doc-jstdg7/ch3.html#_3-1-overview-and-definitions" class="sidebar-link">3.1 Overview and Definitions</a></li><li class="sidebar-sub-header"><a href="/ebook/doc-jstdg7/ch3.html#_3-2-number" class="sidebar-link">3.2 Number</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/ebook/doc-jstdg7/ch3.html#_3-2-1-integer-literals" class="sidebar-link">3.2.1 Integer Literals</a></li><li class="sidebar-sub-header"><a href="/ebook/doc-jstdg7/ch3.html#_3-2-2-floating-point-literals" class="sidebar-link">3.2.2 Floating-Point Literals</a></li><li class="sidebar-sub-header"><a href="/ebook/doc-jstdg7/ch3.html#_3-2-3-arithmetic-in-javascript" class="sidebar-link">3.2.3 Arithmetic in JavaScript</a></li><li class="sidebar-sub-header"><a href="/ebook/doc-jstdg7/ch3.html#_3-2-4-binary-floating-point-and-rounding-errors" class="sidebar-link">3.2.4 Binary Floating-Point and Rounding Errors</a></li><li class="sidebar-sub-header"><a href="/ebook/doc-jstdg7/ch3.html#_3-2-5-arbitrary-precision-integers-with-bigint" class="sidebar-link">3.2.5 Arbitrary Precision Integers with BigInt</a></li><li class="sidebar-sub-header"><a href="/ebook/doc-jstdg7/ch3.html#_3-2-6-dates-and-times" class="sidebar-link">3.2.6 Dates and Times</a></li></ul></li><li class="sidebar-sub-header"><a href="/ebook/doc-jstdg7/ch3.html#_3-3-text" class="sidebar-link">3.3 Text</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/ebook/doc-jstdg7/ch3.html#_3-3-1-string-literals" class="sidebar-link">3.3.1 String Literals</a></li><li class="sidebar-sub-header"><a href="/ebook/doc-jstdg7/ch3.html#_3-3-2-escape-sequences-in-string-literals" class="sidebar-link">3.3.2 Escape Sequences in String Literals</a></li><li class="sidebar-sub-header"><a href="/ebook/doc-jstdg7/ch3.html#_3-3-3-working-with-strings" class="sidebar-link">3.3.3 Working with Strings</a></li><li class="sidebar-sub-header"><a href="/ebook/doc-jstdg7/ch3.html#_3-3-4-template-literals" class="sidebar-link">3.3.4 Template Literals</a></li><li class="sidebar-sub-header"><a href="/ebook/doc-jstdg7/ch3.html#_3-3-5-pattern-matching" class="sidebar-link">3.3.5 Pattern Matching</a></li></ul></li><li class="sidebar-sub-header"><a href="/ebook/doc-jstdg7/ch3.html#_3-4-boolean-values" class="sidebar-link">3.4 Boolean Values</a></li><li class="sidebar-sub-header"><a href="/ebook/doc-jstdg7/ch3.html#_3-5-null-and-undefined" class="sidebar-link">3.5 null and undefined</a></li><li class="sidebar-sub-header"><a href="/ebook/doc-jstdg7/ch3.html#_3-6-symbols" class="sidebar-link">3.6 Symbols</a></li><li class="sidebar-sub-header"><a href="/ebook/doc-jstdg7/ch3.html#_3-7-the-global-object" class="sidebar-link">3.7 The Global Object</a></li><li class="sidebar-sub-header"><a href="/ebook/doc-jstdg7/ch3.html#_3-8-immutable-primitive-values-and-mutable-object-references" class="sidebar-link">3.8 Immutable Primitive Values and Mutable Object References</a></li><li class="sidebar-sub-header"><a href="/ebook/doc-jstdg7/ch3.html#_3-9-type-conversions" class="sidebar-link">3.9 Type Conversions</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/ebook/doc-jstdg7/ch3.html#_3-9-1-conversions-and-equality" class="sidebar-link">3.9.1 Conversions and Equality</a></li><li class="sidebar-sub-header"><a href="/ebook/doc-jstdg7/ch3.html#_3-9-2-explicit-conversions" class="sidebar-link">3.9.2 Explicit Conversions</a></li><li class="sidebar-sub-header"><a href="/ebook/doc-jstdg7/ch3.html#_3-9-3-object-to-primitive-conversions" class="sidebar-link">3.9.3 Object to Primitive Conversions</a></li></ul></li><li class="sidebar-sub-header"><a href="/ebook/doc-jstdg7/ch3.html#_3-10-variable-declaration-and-assignment" class="sidebar-link">3.10 Variable Declaration and Assignment</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/ebook/doc-jstdg7/ch3.html#_3-10-1-declarations-with-let-and-const" class="sidebar-link">3.10.1 Declarations with let and const</a></li><li class="sidebar-sub-header"><a href="/ebook/doc-jstdg7/ch3.html#_3-10-2-variable-declarations-with-var" class="sidebar-link">3.10.2 Variable Declarations with var</a></li><li class="sidebar-sub-header"><a href="/ebook/doc-jstdg7/ch3.html#_3-10-3-destructuring-assignment" class="sidebar-link">3.10.3 Destructuring Assignment</a></li></ul></li><li class="sidebar-sub-header"><a href="/ebook/doc-jstdg7/ch3.html#_3-11-summary" class="sidebar-link">3.11 Summary</a></li></ul></li><li><a href="/ebook/doc-jstdg7/ch4.html" class="sidebar-link">Chapter 4. Expressions and Operators</a></li><li><a href="/ebook/doc-jstdg7/ch5.html" class="sidebar-link">Chapter 5. Statements</a></li><li><a href="/ebook/doc-jstdg7/ch6.html" class="sidebar-link">Chapter 6. Objects</a></li><li><a href="/ebook/doc-jstdg7/ch7.html" class="sidebar-link">Chapter 7. Arrays</a></li><li><a href="/ebook/doc-jstdg7/ch8.html" class="sidebar-link">Chapter 8. Functions</a></li><li><a href="/ebook/doc-jstdg7/ch9.html" class="sidebar-link">Chapter 9. Classes</a></li><li><a href="/ebook/doc-jstdg7/ch10.html" class="sidebar-link">Chapter 10. Modules</a></li><li><a href="/ebook/doc-jstdg7/ch11.html" class="sidebar-link">Chapter 11. The JavaScript Standard Library</a></li><li><a href="/ebook/doc-jstdg7/ch12.html" class="sidebar-link">Chapter 12. Iterators and Generators</a></li><li><a href="/ebook/doc-jstdg7/ch13.html" class="sidebar-link">Chapter 13. Asynchronous JavaScript</a></li><li><a href="/ebook/doc-jstdg7/ch14.html" class="sidebar-link">Chapter 14. Metaprogramming</a></li><li><a href="/ebook/doc-jstdg7/ch15.html" class="sidebar-link">Chapter 15. JavaScript in Web Browsers</a></li><li><a href="/ebook/doc-jstdg7/ch16.html" class="sidebar-link">Chapter 16. Server-Side JavaScript with Node</a></li><li><a href="/ebook/doc-jstdg7/ch17.html" class="sidebar-link">Chapter 17. JavaScript Tools and Extensions</a></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="chapter-3-types-values-and-variables"><a href="#chapter-3-types-values-and-variables" class="header-anchor">#</a> Chapter 3. Types, Values, and Variables</h1> <p>Computer programs work by manipulating values, such as the number 3.14 or the text “Hello World.” The kinds of values that can be represented and manipulated in a programming language are known as types, and one of the most fundamental characteristics of a programming language is the set of types it supports. When a program needs to retain a value for future use, it assigns the value to (or “stores” the value in) a variable. Variables have names, and they allow use of those names in our programs to refer to values. The way that variables work is another fundamental characteristic of any programming language. This chapter explains types, values, and variables in JavaScript. It begins with an overview and some definitions.</p> <h2 id="_3-1-overview-and-definitions"><a href="#_3-1-overview-and-definitions" class="header-anchor">#</a> 3.1 Overview and Definitions</h2> <p>JavaScript types can be divided into two categories: primitive types and object types. JavaScript’s primitive types include numbers, strings of text (known as strings), and Boolean truth values (known as booleans). A significant portion of this chapter is dedicated to a detailed explanation of the numeric (§3.2) and string (§3.3) types in JavaScript. Booleans are covered in §3.4.</p> <p>The special JavaScript values null and undefined are primitive values, but they are not numbers, strings, or booleans. Each value is typically considered to be the sole member of its own special type. §3.5 has more about null and undefined. ES6 adds a new special-purpose type, known as Symbol, that enables the definition of language extensions without harming backward compatibility. Symbols are covered briefly in §3.6.</p> <p>Any JavaScript value that is not a number, a string, a boolean, a symbol, null, or undefined is an object. An object (that is, a member of the type object) is a collection of properties where each property has a name and a value (either a primitive value or another object). One very special object, the global object, is covered in §3.7, but more general and more detailed coverage of objects is in Chapter 6.</p> <p>An ordinary JavaScript object is an unordered collection of named values. The language also defines a special kind of object, known as an array, that represents an ordered collection of numbered values. The JavaScript language includes special syntax for working with arrays, and arrays have some special behavior that distinguishes them from ordinary objects. Arrays are the subject of Chapter 7.</p> <p>In addition to basic objects and arrays, JavaScript defines a number of other useful object types. A Set object represents a set of values. A Map object represents a mapping from keys to values. Various “typed array” types facilitate operations on arrays of bytes and other binary data. The RegExp type represents textual patterns and enables sophisticated matching, searching, and replacing operations on strings. The Date type represents dates and times and supports rudimentary date arithmetic. Error and its subtypes represent errors that can arise when executing JavaScript code. All of these types are covered in Chapter 11.</p> <p>JavaScript differs from more static languages in that functions and classes are not just part of the language syntax: they are themselves values that can be manipulated by JavaScript programs. Like any JavaScript value that is not a primitive value, functions and classes are a specialized kind of object. They are covered in detail in Chapters 8 and 9.</p> <p>The JavaScript interpreter performs automatic garbage collection for memory management. This means that a JavaScript programmer generally does not need to worry about destruction or deallocation of objects or other values. When a value is no longer reachable—when a program no longer has any way to refer to it—the interpreter knows it can never be used again and automatically reclaims the memory it was occupying. (JavaScript programmers do sometimes need to take care to ensure that values do not inadvertently remain reachable—and therefore nonreclaimable—longer than necessary.)</p> <p>JavaScript supports an object-oriented programming style. Loosely, this means that rather than having globally defined functions to operate on values of various types, the types themselves define methods for working with values. To sort the elements of an array a, for example, we don’t pass a to a sort() function. Instead, we invoke the sort() method of a:</p> <div class="language-js extra-class"><pre class="language-js"><code>a<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment">// The object-oriented version of sort(a).</span>
</code></pre></div><p>Method definition is covered in Chapter 9. Technically, it is only JavaScript objects that have methods. But numbers, strings, boolean, and symbol values behave as if they have methods. In JavaScript, null and undefined are the only values that methods cannot be invoked on.</p> <p>JavaScript’s object types are mutable and its primitive types are immutable. A value of a mutable type can change: a JavaScript program can change the values of object properties and array elements. Numbers, booleans, symbols, null, and undefined are immutable—it doesn’t even make sense to talk about changing the value of a number, for example. Strings can be thought of as arrays of characters, and you might expect them to be mutable. In JavaScript, however, strings are immutable: you can access the text at any index of a string, but JavaScript provides no way to alter the text of an existing string. The differences between mutable and immutable values are explored further in §3.8.</p> <p>JavaScript liberally converts values from one type to another. If a program expects a string, for example, and you give it a number, it will automatically convert the number to a string for you. And if you use a non-boolean value where a boolean is expected, JavaScript will convert accordingly. The rules for value conversion are explained in §3.9. JavaScript’s liberal value conversion rules affect its definition of equality, and the == equality operator performs type conversions as described in §3.9.1. (In practice, however, the == equality operator is deprecated in favor of the strict equality operator ===, which does no type conversions. See §4.9.1 for more about both operators.)</p> <p>Constants and variables allow you to use names to refer to values in your programs. Constants are declared with const and variables are declared with let (or with var in older JavaScript code). JavaScript constants and variables are untyped: declarations do not specify what kind of values will be assigned. Variable declaration and assignment are covered in §3.10.</p> <p>As you can see from this long introduction, this is a wide-ranging chapter that explains many fundamental details about how data is represented and manipulated in JavaScript. We’ll begin by diving right in to the details of JavaScript numbers and text.</p> <h2 id="_3-2-number"><a href="#_3-2-number" class="header-anchor">#</a> 3.2 Number</h2> <p>JavaScript’s primary numeric type, Number, is used to represent integers and to approximate real numbers. JavaScript represents numbers using the 64-bit floating-point format defined by the IEEE 754 standard,1 which means it can represent numbers as large as ±1.7976931348623157 × 10308 and as small as ±5 × 10−324.</p> <p>The JavaScript number format allows you to exactly represent all integers between −9,007,199,254,740,992 (−253) and 9,007,199,254,740,992 (253), inclusive. If you use integer values larger than this, you may lose precision in the trailing digits. Note, however, that certain operations in JavaScript (such as array indexing and the bitwise operators described in Chapter 4) are performed with 32-bit integers. If you need to exactly represent larger integers, see §3.2.5.</p> <p>When a number appears directly in a JavaScript program, it’s called a numeric literal. JavaScript supports numeric literals in several formats, as described in the following sections. Note that any numeric literal can be preceded by a minus sign (-) to make the number negative.</p> <h3 id="_3-2-1-integer-literals"><a href="#_3-2-1-integer-literals" class="header-anchor">#</a> 3.2.1 Integer Literals</h3> <p>In a JavaScript program, a base-10 integer is written as a sequence of digits. For example:</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token number">0</span>
<span class="token number">3</span>
<span class="token number">10000000</span>
</code></pre></div><p>In addition to base-10 integer literals, JavaScript recognizes hexadecimal (base-16) values. A hexadecimal literal begins with 0x or 0X, followed by a string of hexadecimal digits. A hexadecimal digit is one of the digits 0 through 9 or the letters a (or A) through f (or F), which represent values 10 through 15. Here are examples of hexadecimal integer literals:</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token number">0xff</span>       <span class="token comment">// =&gt; 255: (15*16 + 15)</span>
<span class="token number">0xBADCAFE</span>  <span class="token comment">// =&gt; 195939070</span>
</code></pre></div><p>In ES6 and later, you can also express integers in binary (base 2) or octal (base 8) using the prefixes 0b and 0o (or 0B and 0O) instead of 0x:</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token number">0b10101</span>  <span class="token comment">// =&gt; 21:  (1*16 + 0*8 + 1*4 + 0*2 + 1*1)</span>
<span class="token number">0o377</span>    <span class="token comment">// =&gt; 255: (3*64 + 7*8 + 7*1)</span>
</code></pre></div><h3 id="_3-2-2-floating-point-literals"><a href="#_3-2-2-floating-point-literals" class="header-anchor">#</a> 3.2.2 Floating-Point Literals</h3> <p>Floating-point literals can have a decimal point; they use the traditional syntax for real numbers. A real value is represented as the integral part of the number, followed by a decimal point and the fractional part of the number.</p> <p>Floating-point literals may also be represented using exponential notation: a real number followed by the letter e (or E), followed by an optional plus or minus sign, followed by an integer exponent. This notation represents the real number multiplied by 10 to the power of the exponent.</p> <p>More succinctly, the syntax is:</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token punctuation">[</span>digits<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">.</span>digits<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token constant">E</span><span class="token operator">|</span>e<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token operator">+</span><span class="token operator">|</span><span class="token operator">-</span><span class="token punctuation">)</span><span class="token punctuation">]</span>digits<span class="token punctuation">]</span>
</code></pre></div><p>For example:</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token number">3.14</span>
<span class="token number">2345.6789</span>
<span class="token number">.333333333333333333</span>
<span class="token number">6.02e23</span>        <span class="token comment">// 6.02 × 10²³</span>
<span class="token number">1.4738223E-32</span>  <span class="token comment">// 1.4738223 × 10⁻³²</span>
</code></pre></div><p>SEPARATORS IN NUMERIC LITERALS
You can use underscores within numeric literals to break long literals up into chunks that are easier to read:</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> billion <span class="token operator">=</span> <span class="token number">1_000_000_000</span><span class="token punctuation">;</span>   <span class="token comment">// Underscore as a thousands separator.</span>
<span class="token keyword">let</span> bytes <span class="token operator">=</span> <span class="token number">0x89_AB_CD_EF</span><span class="token punctuation">;</span>     <span class="token comment">// As a bytes separator.</span>
<span class="token keyword">let</span> bits <span class="token operator">=</span> <span class="token number">0b0001_1101_0111</span><span class="token punctuation">;</span>   <span class="token comment">// As a nibble separator.</span>
<span class="token keyword">let</span> fraction <span class="token operator">=</span> <span class="token number">0.123_456_789</span><span class="token punctuation">;</span>  <span class="token comment">// Works in the fractional part, too.</span>
</code></pre></div><p>At the time of this writing in early 2020, underscores in numeric literals are not yet formally standardized as part of JavaScript. But they are in the advanced stages of the standardization process and are implemented by all major browsers and by Node.</p> <h3 id="_3-2-3-arithmetic-in-javascript"><a href="#_3-2-3-arithmetic-in-javascript" class="header-anchor">#</a> 3.2.3 Arithmetic in JavaScript</h3> <p>JavaScript programs work with numbers using the arithmetic operators . that the language provides. These include + for addition, - for subtraction, * for multiplication, / for division, and % for modulo (remainder after division). ES2016 adds ** for exponentiation. Full details on these and other operators can be found in Chapter 4.</p> <p>In addition to these basic arithmetic operators, JavaScript supports more complex mathematical operations through a set of functions and constants defined as properties of the Math object:</p> <div class="language-js extra-class"><pre class="language-js"><code>Math<span class="token punctuation">.</span><span class="token function">pow</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">53</span><span class="token punctuation">)</span>           <span class="token comment">// =&gt; 9007199254740992: 2 to the power 53</span>
Math<span class="token punctuation">.</span><span class="token function">round</span><span class="token punctuation">(</span><span class="token number">.6</span><span class="token punctuation">)</span>           <span class="token comment">// =&gt; 1.0: round to the nearest integer</span>
Math<span class="token punctuation">.</span><span class="token function">ceil</span><span class="token punctuation">(</span><span class="token number">.6</span><span class="token punctuation">)</span>            <span class="token comment">// =&gt; 1.0: round up to an integer</span>
Math<span class="token punctuation">.</span><span class="token function">floor</span><span class="token punctuation">(</span><span class="token number">.6</span><span class="token punctuation">)</span>           <span class="token comment">// =&gt; 0.0: round down to an integer</span>
Math<span class="token punctuation">.</span><span class="token function">abs</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">5</span><span class="token punctuation">)</span>             <span class="token comment">// =&gt; 5: absolute value</span>
Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span>y<span class="token punctuation">,</span>z<span class="token punctuation">)</span>          <span class="token comment">// Return the largest argument</span>
Math<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span>y<span class="token punctuation">,</span>z<span class="token punctuation">)</span>          <span class="token comment">// Return the smallest argument</span>
Math<span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token comment">// Pseudo-random number x where 0 &lt;= x &lt; 1.0</span>
Math<span class="token punctuation">.</span><span class="token constant">PI</span>                  <span class="token comment">// π: circumference of a circle / diameter</span>
Math<span class="token punctuation">.</span><span class="token constant">E</span>                   <span class="token comment">// e: The base of the natural logarithm</span>
Math<span class="token punctuation">.</span><span class="token function">sqrt</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span>             <span class="token comment">// =&gt; 3**0.5: the square root of 3</span>
Math<span class="token punctuation">.</span><span class="token function">pow</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token operator">/</span><span class="token number">3</span><span class="token punctuation">)</span>         <span class="token comment">// =&gt; 3**(1/3): the cube root of 3</span>
Math<span class="token punctuation">.</span><span class="token function">sin</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>              <span class="token comment">// Trigonometry: also Math.cos, Math.atan, etc.</span>
Math<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span>             <span class="token comment">// Natural logarithm of 10</span>
Math<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token operator">/</span>Math<span class="token punctuation">.</span><span class="token constant">LN10</span>  <span class="token comment">// Base 10 logarithm of 100</span>
Math<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">512</span><span class="token punctuation">)</span><span class="token operator">/</span>Math<span class="token punctuation">.</span><span class="token constant">LN2</span>   <span class="token comment">// Base 2 logarithm of 512</span>
Math<span class="token punctuation">.</span><span class="token function">exp</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span>              <span class="token comment">// Math.E cubed</span>
</code></pre></div><p>ES6 defines more functions on the Math object:</p> <div class="language-js extra-class"><pre class="language-js"><code>Math<span class="token punctuation">.</span><span class="token function">cbrt</span><span class="token punctuation">(</span><span class="token number">27</span><span class="token punctuation">)</span>    <span class="token comment">// =&gt; 3: cube root</span>
Math<span class="token punctuation">.</span><span class="token function">hypot</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span> <span class="token comment">// =&gt; 5: square root of sum of squares of all arguments</span>
Math<span class="token punctuation">.</span><span class="token function">log10</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span>  <span class="token comment">// =&gt; 2: Base-10 logarithm</span>
Math<span class="token punctuation">.</span><span class="token function">log2</span><span class="token punctuation">(</span><span class="token number">1024</span><span class="token punctuation">)</span>  <span class="token comment">// =&gt; 10: Base-2 logarithm</span>
Math<span class="token punctuation">.</span><span class="token function">log1p</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span>    <span class="token comment">// Natural log of (1+x); accurate for very small x</span>
Math<span class="token punctuation">.</span><span class="token function">expm1</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span>    <span class="token comment">// Math.exp(x)-1; the inverse of Math.log1p()</span>
Math<span class="token punctuation">.</span><span class="token function">sign</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span>     <span class="token comment">// -1, 0, or 1 for arguments &lt;, ==, or &gt; 0</span>
Math<span class="token punctuation">.</span><span class="token function">imul</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span>   <span class="token comment">// =&gt; 6: optimized multiplication of 32-bit integers</span>
Math<span class="token punctuation">.</span><span class="token function">clz32</span><span class="token punctuation">(</span><span class="token number">0xf</span><span class="token punctuation">)</span>  <span class="token comment">// =&gt; 28: number of leading zero bits in a 32-bit integer</span>
Math<span class="token punctuation">.</span><span class="token function">trunc</span><span class="token punctuation">(</span><span class="token number">3.9</span><span class="token punctuation">)</span>  <span class="token comment">// =&gt; 3: convert to an integer by truncating fractional part</span>
Math<span class="token punctuation">.</span><span class="token function">fround</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span>   <span class="token comment">// Round to nearest 32-bit float number</span>
Math<span class="token punctuation">.</span><span class="token function">sinh</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span>     <span class="token comment">// Hyperbolic sine. Also Math.cosh(), Math.tanh()</span>
Math<span class="token punctuation">.</span><span class="token function">asinh</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span>    <span class="token comment">// Hyperbolic arcsine. Also Math.acosh(), Math.atanh()</span>
</code></pre></div><p>Arithmetic in JavaScript does not raise errors in cases of overflow, underflow, or division by zero. When the result of a numeric operation is larger than the largest representable number (overflow), the result is a special infinity value, Infinity. Similarly, when the absolute value of a negative value becomes larger than the absolute value of the largest representable negative number, the result is negative infinity, -Infinity. The infinite values behave as you would expect: adding, subtracting, multiplying, or dividing them by anything results in an infinite value (possibly with the sign reversed).</p> <p>Underflow occurs when the result of a numeric operation is closer to zero than the smallest representable number. In this case, JavaScript returns 0. If underflow occurs from a negative number, JavaScript returns a special value known as “negative zero.” This value is almost completely indistinguishable from regular zero and JavaScript programmers rarely need to detect it.</p> <p>Division by zero is not an error in JavaScript: it simply returns infinity or negative infinity. There is one exception, however: zero divided by zero does not have a well-defined value, and the result of this operation is the special not-a-number value, NaN. NaN also arises if you attempt to divide infinity by infinity, take the square root of a negative number, or use arithmetic operators with non-numeric operands that cannot be converted to numbers.</p> <p>JavaScript predefines global constants Infinity and NaN to hold the positive infinity and not-a-number value, and these values are also available as properties of the Number object:</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token number">Infinity</span>                    <span class="token comment">// A positive number too big to represent</span>
Number<span class="token punctuation">.</span><span class="token constant">POSITIVE_INFINITY</span>    <span class="token comment">// Same value</span>
<span class="token number">1</span><span class="token operator">/</span><span class="token number">0</span>                         <span class="token comment">// =&gt; Infinity</span>
Number<span class="token punctuation">.</span><span class="token constant">MAX_VALUE</span> <span class="token operator">*</span> <span class="token number">2</span>        <span class="token comment">// =&gt; Infinity; overflow</span>

<span class="token operator">-</span><span class="token number">Infinity</span>                   <span class="token comment">// A negative number too big to represent</span>
Number<span class="token punctuation">.</span><span class="token constant">NEGATIVE_INFINITY</span>    <span class="token comment">// The same value</span>
<span class="token operator">-</span><span class="token number">1</span><span class="token operator">/</span><span class="token number">0</span>                        <span class="token comment">// =&gt; -Infinity</span>
<span class="token operator">-</span>Number<span class="token punctuation">.</span><span class="token constant">MAX_VALUE</span> <span class="token operator">*</span> <span class="token number">2</span>       <span class="token comment">// =&gt; -Infinity</span>

<span class="token number">NaN</span>                         <span class="token comment">// The not-a-number value</span>
Number<span class="token punctuation">.</span><span class="token number">NaN</span>                  <span class="token comment">// The same value, written another way</span>
<span class="token number">0</span><span class="token operator">/</span><span class="token number">0</span>                         <span class="token comment">// =&gt; NaN</span>
<span class="token number">Infinity</span><span class="token operator">/</span><span class="token number">Infinity</span>           <span class="token comment">// =&gt; NaN</span>

Number<span class="token punctuation">.</span><span class="token constant">MIN_VALUE</span><span class="token operator">/</span><span class="token number">2</span>          <span class="token comment">// =&gt; 0: underflow</span>
<span class="token operator">-</span>Number<span class="token punctuation">.</span><span class="token constant">MIN_VALUE</span><span class="token operator">/</span><span class="token number">2</span>         <span class="token comment">// =&gt; -0: negative zero</span>
<span class="token operator">-</span><span class="token number">1</span><span class="token operator">/</span><span class="token number">Infinity</span>                 <span class="token comment">// -&gt; -0: also negative 0</span>
<span class="token operator">-</span><span class="token number">0</span>

<span class="token comment">// The following Number properties are defined in ES6</span>
Number<span class="token punctuation">.</span><span class="token function">parseInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span>       <span class="token comment">// Same as the global parseInt() function</span>
Number<span class="token punctuation">.</span><span class="token function">parseFloat</span><span class="token punctuation">(</span><span class="token punctuation">)</span>     <span class="token comment">// Same as the global parseFloat() function</span>
Number<span class="token punctuation">.</span><span class="token function">isNaN</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span>         <span class="token comment">// Is x the NaN value?</span>
Number<span class="token punctuation">.</span><span class="token function">isFinite</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span>      <span class="token comment">// Is x a number and finite?</span>
Number<span class="token punctuation">.</span><span class="token function">isInteger</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span>     <span class="token comment">// Is x an integer?</span>
Number<span class="token punctuation">.</span><span class="token function">isSafeInteger</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token comment">// Is x an integer -(2**53) &lt; x &lt; 2**53?</span>
Number<span class="token punctuation">.</span><span class="token constant">MIN_SAFE_INTEGER</span> <span class="token comment">// =&gt; -(2**53 - 1)</span>
Number<span class="token punctuation">.</span><span class="token constant">MAX_SAFE_INTEGER</span> <span class="token comment">// =&gt; 2**53 - 1</span>
Number<span class="token punctuation">.</span><span class="token constant">EPSILON</span>          <span class="token comment">// =&gt; 2**-52: smallest difference between numbers</span>
</code></pre></div><p>The not-a-number value has one unusual feature in JavaScript: it does not compare equal to any other value, including itself. This means that you can’t write x === NaN to determine whether the value of a variable x is NaN. Instead, you must write x != x or Number.isNaN(x). Those expressions will be true if, and only if, x has the same value as the global constant NaN.</p> <p>The global function isNaN() is similar to Number.isNaN(). It returns true if its argument is NaN, or if that argument is a non-numeric value that cannot be converted to a number. The related function Number.isFinite() returns true if its argument is a number other than NaN, Infinity, or -Infinity. The global isFinite() function returns true if its argument is, or can be converted to, a finite number.</p> <p>The negative zero value is also somewhat unusual. It compares equal (even using JavaScript’s strict equality test) to positive zero, which means that the two values are almost indistinguishable, except when used as a divisor:</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> zero <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>         <span class="token comment">// Regular zero</span>
<span class="token keyword">let</span> negz <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">0</span><span class="token punctuation">;</span>        <span class="token comment">// Negative zero</span>
zero <span class="token operator">===</span> negz         <span class="token comment">// =&gt; true: zero and negative zero are equal</span>
<span class="token number">1</span><span class="token operator">/</span>zero <span class="token operator">===</span> <span class="token number">1</span><span class="token operator">/</span>negz     <span class="token comment">// =&gt; false: Infinity and -Infinity are not equal</span>
</code></pre></div><h3 id="_3-2-4-binary-floating-point-and-rounding-errors"><a href="#_3-2-4-binary-floating-point-and-rounding-errors" class="header-anchor">#</a> 3.2.4 Binary Floating-Point and Rounding Errors</h3> <p>There are infinitely many real numbers, but only a finite number of them (18,437,736,874,454,810,627, to be exact) can be represented exactly by the JavaScript floating-point format. This means that when you’re working with real numbers in JavaScript, the representation of the number will often be an approximation of the actual number.</p> <p>The IEEE-754 floating-point representation used by JavaScript (and just about every other modern programming language) is a binary representation, which can exactly represent fractions like 1/2, 1/8, and 1/1024. Unfortunately, the fractions we use most commonly (especially when performing financial calculations) are decimal fractions: 1/10, 1/100, and so on. Binary floating-point representations cannot exactly represent numbers as simple as 0.1.</p> <p>JavaScript numbers have plenty of precision and can approximate 0.1 very closely. But the fact that this number cannot be represented exactly can lead to problems. Consider this code:</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> x <span class="token operator">=</span> <span class="token number">.3</span> <span class="token operator">-</span> <span class="token number">.2</span><span class="token punctuation">;</span>    <span class="token comment">// thirty cents minus 20 cents</span>
<span class="token keyword">let</span> y <span class="token operator">=</span> <span class="token number">.2</span> <span class="token operator">-</span> <span class="token number">.1</span><span class="token punctuation">;</span>    <span class="token comment">// twenty cents minus 10 cents</span>
x <span class="token operator">===</span> y             <span class="token comment">// =&gt; false: the two values are not the same!</span>
x <span class="token operator">===</span> <span class="token number">.1</span>            <span class="token comment">// =&gt; false: .3-.2 is not equal to .1</span>
y <span class="token operator">===</span> <span class="token number">.1</span>            <span class="token comment">// =&gt; true: .2-.1 is equal to .1</span>
</code></pre></div><p>Because of rounding error, the difference between the approximations of .3 and .2 is not exactly the same as the difference between the approximations of .2 and .1. It is important to understand that this problem is not specific to JavaScript: it affects any programming language that uses binary floating-point numbers. Also, note that the values x and y in the code shown here are very close to each other and to the correct value. The computed values are adequate for almost any purpose; the problem only arises when we attempt to compare values for equality.</p> <p>If these floating-point approximations are problematic for your programs, consider using scaled integers. For example, you might manipulate monetary values as integer cents rather than fractional dollars.</p> <h3 id="_3-2-5-arbitrary-precision-integers-with-bigint"><a href="#_3-2-5-arbitrary-precision-integers-with-bigint" class="header-anchor">#</a> 3.2.5 Arbitrary Precision Integers with BigInt</h3> <p>One of the newest features of JavaScript, defined in ES2020, is a new numeric type known as BigInt. As of early 2020, it has been implemented in Chrome, Firefox, Edge, and Node, and there is an implementation in progress in Safari. As the name implies, BigInt is a numeric type whose values are integers. The type was added to JavaScript mainly to allow the representation of 64-bit integers, which are required for compatibility with many other programming languages and APIs. But BigInt values can have thousands or even millions of digits, should you have need to work with numbers that large. (Note, however, that BigInt implementations are not suitable for cryptography because they do not attempt to prevent timing attacks.)</p> <p>BigInt literals are written as a string of digits followed by a lowercase letter n. By default, the are in base 10, but you can use the 0b, 0o, and 0x prefixes for binary, octal, and hexadecimal BigInts:</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token number">1234n</span>                <span class="token comment">// A not-so-big BigInt literal</span>
<span class="token number">0b111111n</span>            <span class="token comment">// A binary BigInt</span>
<span class="token number">0o7777n</span>              <span class="token comment">// An octal BigInt</span>
<span class="token number">0x8000000000000000n</span>  <span class="token comment">// =&gt; 2n**63n: A 64-bit integer</span>
</code></pre></div><p>You can use BigInt() as a function for converting regular JavaScript numbers or strings to BigInt values:</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token function">BigInt</span><span class="token punctuation">(</span>Number<span class="token punctuation">.</span><span class="token constant">MAX_SAFE_INTEGER</span><span class="token punctuation">)</span>     <span class="token comment">// =&gt; 9007199254740991n</span>
<span class="token keyword">let</span> string <span class="token operator">=</span> <span class="token string">&quot;1&quot;</span> <span class="token operator">+</span> <span class="token string">&quot;0&quot;</span><span class="token punctuation">.</span><span class="token function">repeat</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 1 followed by 100 zeros.</span>
<span class="token function">BigInt</span><span class="token punctuation">(</span>string<span class="token punctuation">)</span>                      <span class="token comment">// =&gt; 10n**100n: one googol</span>
</code></pre></div><p>Arithmetic with BigInt values works like arithmetic with regular JavaScript numbers, except that division drops any remainder and rounds down (toward zero):</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token number">1000n</span> <span class="token operator">+</span> <span class="token number">2000n</span>  <span class="token comment">// =&gt; 3000n</span>
<span class="token number">3000n</span> <span class="token operator">-</span> <span class="token number">2000n</span>  <span class="token comment">// =&gt; 1000n</span>
<span class="token number">2000n</span> <span class="token operator">*</span> <span class="token number">3000n</span>  <span class="token comment">// =&gt; 6000000n</span>
<span class="token number">3000n</span> <span class="token operator">/</span> <span class="token number">997n</span>   <span class="token comment">// =&gt; 3n: the quotient is 3</span>
<span class="token number">3000n</span> <span class="token operator">%</span> <span class="token number">997n</span>   <span class="token comment">// =&gt; 9n: and the remainder is 9</span>
<span class="token punctuation">(</span><span class="token number">2n</span> <span class="token operator">**</span> <span class="token number">131071n</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1n</span>  <span class="token comment">// A Mersenne prime with 39457 decimal digits</span>
</code></pre></div><p>Although the standard +, -, *, /, %, and ** operators work with BigInt, it is important to understand that you may not mix operands of type BigInt with regular number operands. This may seem confusing at first, but there is a good reason for it. If one numeric type was more general than the other, it would be easy to define arithmetic on mixed operands to simply return a value of the more general type. But neither type is more general than the other: BigInt can represent extraordinarily large values, making it more general than regular numbers. But BigInt can only represent integers, making the regular JavaScript number type more general. There is no way around this problem, so JavaScript sidesteps it by simply not allowing mixed operands to the arithmetic operators.</p> <p>Comparison operators, by contrast, do work with mixed numeric types (but see §3.9.1 for more about the difference between == and ===):</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token number">1</span> <span class="token operator">&lt;</span> <span class="token number">2n</span>     <span class="token comment">// =&gt; true</span>
<span class="token number">2</span> <span class="token operator">&gt;</span> <span class="token number">1n</span>     <span class="token comment">// =&gt; true</span>
<span class="token number">0</span> <span class="token operator">==</span> <span class="token number">0n</span>    <span class="token comment">// =&gt; true</span>
<span class="token number">0</span> <span class="token operator">===</span> <span class="token number">0n</span>   <span class="token comment">// =&gt; false: the === checks for type equality as well</span>
</code></pre></div><p>The bitwise operators (described in §4.8.3) generally work with BigInt operands. None of the functions of the Math object accept BigInt operands, however.</p> <h3 id="_3-2-6-dates-and-times"><a href="#_3-2-6-dates-and-times" class="header-anchor">#</a> 3.2.6 Dates and Times</h3> <p>JavaScript defines a simple Date class for representing and manipulating the numbers that represent dates and times. JavaScript Dates are objects, but they also have a numeric representation as a timestamp that specifies the number of elapsed milliseconds since January 1, 1970:</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> timestamp <span class="token operator">=</span> Date<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// The current time as a timestamp (a number).</span>
<span class="token keyword">let</span> now <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// The current time as a Date object.</span>
<span class="token keyword">let</span> ms <span class="token operator">=</span> now<span class="token punctuation">.</span><span class="token function">getTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment">// Convert to a millisecond timestamp.</span>
<span class="token keyword">let</span> iso <span class="token operator">=</span> now<span class="token punctuation">.</span><span class="token function">toISOString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Convert to a string in standard format.</span>
</code></pre></div><p>The Date class and its methods are covered in detail in §11.4. But we will see Date objects again in §3.9.3 when we examine the details of JavaScript type conversions.</p> <h2 id="_3-3-text"><a href="#_3-3-text" class="header-anchor">#</a> 3.3 Text</h2> <p>The JavaScript type for representing text is the string. A string is an immutable ordered sequence of 16-bit values, each of which typically represents a Unicode character. The length of a string is the number of 16-bit values it contains. JavaScript’s strings (and its arrays) use zero-based indexing: the first 16-bit value is at position 0, the second at position 1, and so on. The empty string is the string of length 0. JavaScript does not have a special type that represents a single element of a string. To represent a single 16-bit value, simply use a string that has a length of 1.</p> <p>CHARACTERS, CODEPOINTS, AND JAVASCRIPT STRINGS
JavaScript uses the UTF-16 encoding of the Unicode character set, and JavaScript strings are sequences of unsigned 16-bit values. The most commonly used Unicode characters (those from the “basic multilingual plane”) have codepoints that fit in 16 bits and can be represented by one element of a string. Unicode characters whose codepoints do not fit in 16 bits are encoded using the rules of UTF-16 as a sequence (known as a “surrogate pair”) of two 16-bit values. This means that a JavaScript string of length 2 (two 16-bit values) might represent only a single Unicode character:</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> euro <span class="token operator">=</span> <span class="token string">&quot;€&quot;</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> love <span class="token operator">=</span> <span class="token string">&quot;❤&quot;</span><span class="token punctuation">;</span>
euro<span class="token punctuation">.</span>length   <span class="token comment">// =&gt; 1: this character has one 16-bit element</span>
love<span class="token punctuation">.</span>length   <span class="token comment">// =&gt; 2: UTF-16 encoding of ❤ is &quot;\ud83d\udc99&quot;</span>
</code></pre></div><p>Most string-manipulation methods defined by JavaScript operate on 16-bit values, not characters. They do not treat surrogate pairs specially, they perform no normalization of the string, and don’t even ensure that a string is well-formed UTF-16.</p> <p>In ES6, however, strings are iterable, and if you use the for/of loop or ... operator with a string, it will iterate the actual characters of the string, not the 16-bit values.</p> <h3 id="_3-3-1-string-literals"><a href="#_3-3-1-string-literals" class="header-anchor">#</a> 3.3.1 String Literals</h3> <p>To include a string in a JavaScript program, simply enclose the characters of the string within a matched pair of single or double quotes or backticks (' or &quot; or `). Double-quote characters and backticks may be contained within strings delimited by single-quote characters, and similarly for strings delimited by double quotes and backticks. Here are examples of string literals:</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token string">&quot;&quot;</span>  <span class="token comment">// The empty string: it has zero characters</span>
<span class="token string">'testing'</span>
<span class="token string">&quot;3.14&quot;</span>
<span class="token string">'name=&quot;myform&quot;'</span>
<span class="token string">&quot;Wouldn't you prefer O'Reilly's book?&quot;</span>
<span class="token string">&quot;τ is the ratio of a circle's circumference to its radius&quot;</span>
<span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">&quot;She said 'hi'&quot;, he said.</span><span class="token template-punctuation string">`</span></span>
</code></pre></div><p>Strings delimited with backticks are a feature of ES6, and allow JavaScript expressions to be embedded within (or interpolated into) the string literal. This expression interpolation syntax is covered in §3.3.4.</p> <p>The original versions of JavaScript required string literals to be written on a single line, and it is common to see JavaScript code that creates long strings by concatenating single-line strings with the + operator. As of ES5, however, you can break a string literal across multiple lines by ending each line but the last with a backslash <code>(\)</code>. Neither the backslash nor the line terminator that follow it are part of the string literal. If you need to include a newline character in a single-quoted or double-quoted string literal, use the character sequence \n (documented in the next section). The ES6 backtick syntax allows strings to be broken across multiple lines, and in this case, the line terminators are part of the string literal:</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// A string representing 2 lines written on one line:</span>
<span class="token string">'two\nlines'</span>

<span class="token comment">// A one-line string written on 3 lines:</span>
<span class="token string">&quot;one\
 long\
 line&quot;</span>

<span class="token comment">// A two-line string written on two lines:</span>
<span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">the newline character at the end of this line
is included literally in this string</span><span class="token template-punctuation string">`</span></span>
</code></pre></div><p>Note that when you use single quotes to delimit your strings, you must be careful with English contractions and possessives, such as can’t and O’Reilly’s. Since the apostrophe is the same as the single-quote character, you must use the backslash character () to “escape” any apostrophes that appear in single-quoted strings (escapes are explained in the next section).</p> <p>In client-side JavaScript programming, JavaScript code may contain strings of HTML code, and HTML code may contain strings of JavaScript code. Like JavaScript, HTML uses either single or double quotes to delimit its strings. Thus, when combining JavaScript and HTML, it is a good idea to use one style of quotes for JavaScript and the other style for HTML. In the following example, the string “Thank you” is single-quoted within a JavaScript expression, which is then double-quoted within an HTML event-handler attribute:</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token operator">&lt;</span>button onclick<span class="token operator">=</span><span class="token string">&quot;alert('Thank you')&quot;</span><span class="token operator">&gt;</span>Click Me<span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">&gt;</span>
</code></pre></div><h3 id="_3-3-2-escape-sequences-in-string-literals"><a href="#_3-3-2-escape-sequences-in-string-literals" class="header-anchor">#</a> 3.3.2 Escape Sequences in String Literals</h3> <p>The backslash character <code>(\)</code> has a special purpose in JavaScript strings. Combined with the character that follows it, it represents a character that is not otherwise representable within the string. For example, \n is an escape sequence that represents a newline character.</p> <p>Another example, mentioned earlier, is the ' escape, which represents the single quote (or apostrophe) character. This escape sequence is useful when you need to include an apostrophe in a string literal that is contained within single quotes. You can see why these are called escape sequences: the backslash allows you to escape from the usual interpretation of the single-quote character. Instead of using it to mark the end of the string, you use it as an apostrophe:</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token string">'You\'re right, it can\'t be a quote'</span>
</code></pre></div><p>Table 3-1 lists the JavaScript escape sequences and the characters they represent. Three escape sequences are generic and can be used to represent any character by specifying its Unicode character code as a hexadecimal number. For example, the sequence \xA9 represents the copyright symbol, which has the Unicode encoding given by the hexadecimal number A9. Similarly, the \u escape represents an arbitrary Unicode character specified by four hexadecimal digits or one to five digits when the digits are enclosed in curly braces: \u03c0 represents the character π, for example, and \u{1f600} represents the “grinning face” emoji.</p> <p>Table 3-1. JavaScript escape sequences</p> <table><thead><tr><th>Sequence</th> <th>Character represented</th></tr></thead> <tbody><tr><td>\0</td> <td>The NUL character (\u0000)</td></tr> <tr><td>\b</td> <td>Backspace (\u0008)</td></tr> <tr><td>\t</td> <td>Horizontal tab (\u0009)</td></tr> <tr><td>\n</td> <td>Newline (\u000A)</td></tr> <tr><td>\v</td> <td>Vertical tab (\u000B)</td></tr> <tr><td>\f</td> <td>Form feed (\u000C)</td></tr> <tr><td>\r</td> <td>Carriage return (\u000D)</td></tr> <tr><td>&quot;</td> <td>Double quote (\u0022)</td></tr> <tr><td>'</td> <td>Apostrophe or single quote (\u0027)</td></tr> <tr><td><code>\\</code></td> <td>Backslash (\u005C)</td></tr> <tr><td>\xnn</td> <td>The Unicode character specified by the two hexadecimal digits nn</td></tr> <tr><td>\unnnn</td> <td>The Unicode character specified by the four hexadecimal digits nnnn</td></tr> <tr><td>\u{n}</td> <td>The Unicode character specified by the codepoint n, where n is one to six hexadecimal digits between 0 and 10FFFF (ES6)</td></tr></tbody></table> <p>If the \ character precedes any character other than those shown in Table 3-1, the backslash is simply ignored (although future versions of the language may, of course, define new escape sequences). For example, <code>\#</code> is the same as #. Finally, as noted earlier, ES5 allows a backslash before a line break to break a string literal across multiple lines.</p> <h3 id="_3-3-3-working-with-strings"><a href="#_3-3-3-working-with-strings" class="header-anchor">#</a> 3.3.3 Working with Strings</h3> <p>One of the built-in features of JavaScript is the ability to concatenate strings. If you use the + operator with numbers, it adds them. But if you use this operator on strings, it joins them by appending the second to the first. For example:</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> msg <span class="token operator">=</span> <span class="token string">&quot;Hello, &quot;</span> <span class="token operator">+</span> <span class="token string">&quot;world&quot;</span><span class="token punctuation">;</span>   <span class="token comment">// Produces the string &quot;Hello, world&quot;</span>
<span class="token keyword">let</span> greeting <span class="token operator">=</span> <span class="token string">&quot;Welcome to my blog,&quot;</span> <span class="token operator">+</span> <span class="token string">&quot; &quot;</span> <span class="token operator">+</span> name<span class="token punctuation">;</span>
</code></pre></div><p>Strings can be compared with the standard === equality and !== inequality operators: two strings are equal if and only if they consist of exactly the same sequence of 16-bit values. Strings can also be compared with the &lt;, &lt;=, &gt;, and &gt;= operators. String comparison is done simply by comparing the 16-bit values. (For more robust locale-aware string comparison and sorting, see §11.7.3.)</p> <p>To determine the length of a string—the number of 16-bit values it contains—use the length property of the string:</p> <div class="language-js extra-class"><pre class="language-js"><code>s<span class="token punctuation">.</span>length
</code></pre></div><p>In addition to this length property, JavaScript provides a rich API for working with strings:</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> s <span class="token operator">=</span> <span class="token string">&quot;Hello, world&quot;</span><span class="token punctuation">;</span> <span class="token comment">// Start with some text.</span>

<span class="token comment">// Obtaining portions of a string</span>
s<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">)</span>        <span class="token comment">// =&gt; &quot;ell&quot;: the 2nd, 3rd, and 4th characters.</span>
s<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">)</span>            <span class="token comment">// =&gt; &quot;ell&quot;: same thing</span>
s<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">3</span><span class="token punctuation">)</span>             <span class="token comment">// =&gt; &quot;rld&quot;: last 3 characters</span>
s<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">&quot;, &quot;</span><span class="token punctuation">)</span>           <span class="token comment">// =&gt; [&quot;Hello&quot;, &quot;world&quot;]: split at delimiter string</span>

<span class="token comment">// Searching a string</span>
s<span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span><span class="token string">&quot;l&quot;</span><span class="token punctuation">)</span>          <span class="token comment">// =&gt; 2: position of first letter l</span>
s<span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span><span class="token string">&quot;l&quot;</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span>       <span class="token comment">// =&gt; 3: position of first &quot;l&quot; at or after 3</span>
s<span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span><span class="token string">&quot;zz&quot;</span><span class="token punctuation">)</span>         <span class="token comment">// =&gt; -1: s does not include the substring &quot;zz&quot;</span>
s<span class="token punctuation">.</span><span class="token function">lastIndexOf</span><span class="token punctuation">(</span><span class="token string">&quot;l&quot;</span><span class="token punctuation">)</span>      <span class="token comment">// =&gt; 10: position of last letter l</span>

<span class="token comment">// Boolean searching functions in ES6 and later</span>
s<span class="token punctuation">.</span><span class="token function">startsWith</span><span class="token punctuation">(</span><span class="token string">&quot;Hell&quot;</span><span class="token punctuation">)</span>    <span class="token comment">// =&gt; true: the string starts with these</span>
s<span class="token punctuation">.</span><span class="token function">endsWith</span><span class="token punctuation">(</span><span class="token string">&quot;!&quot;</span><span class="token punctuation">)</span>         <span class="token comment">// =&gt; false: s does not end with that</span>
s<span class="token punctuation">.</span><span class="token function">includes</span><span class="token punctuation">(</span><span class="token string">&quot;or&quot;</span><span class="token punctuation">)</span>        <span class="token comment">// =&gt; true: s includes substring &quot;or&quot;</span>

<span class="token comment">// Creating modified versions of a string</span>
s<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token string">&quot;llo&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;ya&quot;</span><span class="token punctuation">)</span>  <span class="token comment">// =&gt; &quot;Heya, world&quot;</span>
s<span class="token punctuation">.</span><span class="token function">toLowerCase</span><span class="token punctuation">(</span><span class="token punctuation">)</span>         <span class="token comment">// =&gt; &quot;hello, world&quot;</span>
s<span class="token punctuation">.</span><span class="token function">toUpperCase</span><span class="token punctuation">(</span><span class="token punctuation">)</span>         <span class="token comment">// =&gt; &quot;HELLO, WORLD&quot;</span>
s<span class="token punctuation">.</span><span class="token function">normalize</span><span class="token punctuation">(</span><span class="token punctuation">)</span>           <span class="token comment">// Unicode NFC normalization: ES6</span>
s<span class="token punctuation">.</span><span class="token function">normalize</span><span class="token punctuation">(</span><span class="token string">&quot;NFD&quot;</span><span class="token punctuation">)</span>      <span class="token comment">// NFD normalization. Also &quot;NFKC&quot;, &quot;NFKD&quot;</span>

<span class="token comment">// Inspecting individual (16-bit) characters of a string</span>
s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>             <span class="token comment">// =&gt; &quot;H&quot;: the first character</span>
s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token comment">// =&gt; &quot;d&quot;: the last character</span>
s<span class="token punctuation">.</span><span class="token function">charCodeAt</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>         <span class="token comment">// =&gt; 72: 16-bit number at the specified position</span>
s<span class="token punctuation">.</span><span class="token function">codePointAt</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>        <span class="token comment">// =&gt; 72: ES6, works for codepoints &gt; 16 bits</span>

<span class="token comment">// String padding functions in ES2017</span>
<span class="token string">&quot;x&quot;</span><span class="token punctuation">.</span><span class="token function">padStart</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span>         <span class="token comment">// =&gt; &quot;  x&quot;: add spaces on the left to a length of 3</span>
<span class="token string">&quot;x&quot;</span><span class="token punctuation">.</span><span class="token function">padEnd</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span>           <span class="token comment">// =&gt; &quot;x  &quot;: add spaces on the right to a length of 3</span>
<span class="token string">&quot;x&quot;</span><span class="token punctuation">.</span><span class="token function">padStart</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token string">&quot;*&quot;</span><span class="token punctuation">)</span>    <span class="token comment">// =&gt; &quot;**x&quot;: add stars on the left to a length of 3</span>
<span class="token string">&quot;x&quot;</span><span class="token punctuation">.</span><span class="token function">padEnd</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token string">&quot;-&quot;</span><span class="token punctuation">)</span>      <span class="token comment">// =&gt; &quot;x--&quot;: add dashes on the right to a length of 3</span>

<span class="token comment">// Space trimming functions. trim() is ES5; others ES2019</span>
<span class="token string">&quot; test &quot;</span><span class="token punctuation">.</span><span class="token function">trim</span><span class="token punctuation">(</span><span class="token punctuation">)</span>         <span class="token comment">// =&gt; &quot;test&quot;: remove spaces at start and end</span>
<span class="token string">&quot; test &quot;</span><span class="token punctuation">.</span><span class="token function">trimStart</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment">// =&gt; &quot;test &quot;: remove spaces on left. Also trimLeft</span>
<span class="token string">&quot; test &quot;</span><span class="token punctuation">.</span><span class="token function">trimEnd</span><span class="token punctuation">(</span><span class="token punctuation">)</span>      <span class="token comment">// =&gt; &quot; test&quot;: remove spaces at right. Also trimRight</span>

<span class="token comment">// Miscellaneous string methods</span>
s<span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span><span class="token string">&quot;!&quot;</span><span class="token punctuation">)</span>           <span class="token comment">// =&gt; &quot;Hello, world!&quot;: just use + operator instead</span>
<span class="token string">&quot;&lt;&gt;&quot;</span><span class="token punctuation">.</span><span class="token function">repeat</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span>          <span class="token comment">// =&gt; &quot;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&quot;: concatenate n copies. ES6</span>
</code></pre></div><p>Remember that strings are immutable in JavaScript. Methods like replace() and toUpperCase() return new strings: they do not modify the string on which they are invoked.</p> <p>Strings can also be treated like read-only arrays, and you can access individual characters (16-bit values) from a string using square brackets instead of the charAt() method:</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> s <span class="token operator">=</span> <span class="token string">&quot;hello, world&quot;</span><span class="token punctuation">;</span>
s<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>                  <span class="token comment">// =&gt; &quot;h&quot;</span>
s<span class="token punctuation">[</span>s<span class="token punctuation">.</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>         <span class="token comment">// =&gt; &quot;d&quot;</span>
</code></pre></div><h3 id="_3-3-4-template-literals"><a href="#_3-3-4-template-literals" class="header-anchor">#</a> 3.3.4 Template Literals</h3> <p>In ES6 and later, string literals can be delimited with backticks:</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> s <span class="token operator">=</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">hello world</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">;</span>
</code></pre></div><p>This is more than just another string literal syntax, however, because these template literals can include arbitrary JavaScript expressions. The final value of a string literal in backticks is computed by evaluating any included expressions, converting the values of those expressions to strings and combining those computed strings with the literal characters within the backticks:</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> name <span class="token operator">=</span> <span class="token string">&quot;Bill&quot;</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> greeting <span class="token operator">=</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">Hello </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span> name <span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">.</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">;</span>  <span class="token comment">// greeting == &quot;Hello Bill.&quot;</span>
</code></pre></div><p>Everything between the ${ and the matching } is interpreted as a JavaScript expression. Everything outside the curly braces is normal string literal text. The expression inside the braces is evaluated and then converted to a string and inserted into the template, replacing the dollar sign, the curly braces, and everything in between them.</p> <p>A template literal may include any number of expressions. It can use any of the escape characters that normal strings can, and it can span any number of lines, with no special escaping required. The following template literal includes four JavaScript expressions, a Unicode escape sequence, and at least four newlines (the expression values may include newlines as well):</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> errorMessage <span class="token operator">=</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">\
\u2718 Test failure at </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>filename<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">:</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>linenumber<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">:
</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>exception<span class="token punctuation">.</span>message<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">
Stack trace:
</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>exception<span class="token punctuation">.</span>stack<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">
</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">;</span>
</code></pre></div><p>The backslash at the end of the first line here escapes the initial newline so that the resulting string begins with the Unicode ✘ character (\u2718) rather than a newline.</p> <p>TAGGED TEMPLATE LITERALS
A powerful but less commonly used feature of template literals is that, if a function name (or “tag”) comes right before the opening backtick, then the text and the values of the expressions within the template literal are passed to the function. The value of this “tagged template literal” is the return value of the function. This could be used, for example, to apply HTML or SQL escaping to the values before substituting them into the text.</p> <p>ES6 has one built-in tag function: String.raw(). It returns the text within backticks without any processing of backslash escapes:</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">\n</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">.</span>length            <span class="token comment">// =&gt; 1: the string has a single newline character</span>
String<span class="token punctuation">.</span>raw<span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">\n</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">.</span>length  <span class="token comment">// =&gt; 2: a backslash character and the letter n</span>
</code></pre></div><p>Note that even though the tag portion of a tagged template literal is a function, there are no parentheses used in its invocation. In this very specific case, the backtick characters replace the open and close parentheses.</p> <p>The ability to define your own template tag functions is a powerful feature of JavaScript. These functions do not need to return strings, and they can be used like constructors, as if defining a new literal syntax for the language. We’ll see an example in §14.5.</p> <h3 id="_3-3-5-pattern-matching"><a href="#_3-3-5-pattern-matching" class="header-anchor">#</a> 3.3.5 Pattern Matching</h3> <p>JavaScript defines a datatype known as a regular expression (or RegExp) for describing and matching patterns in strings of text. RegExps are not one of the fundamental datatypes in JavaScript, but they have a literal syntax like numbers and strings do, so they sometimes seem like they are fundamental. The grammar of regular expression literals is complex and the API they define is nontrivial. They are documented in detail in §11.3. Because RegExps are powerful and commonly used for text processing, however, this section provides a brief overview.</p> <p>Text between a pair of slashes constitutes a regular expression literal. The second slash in the pair can also be followed by one or more letters, which modify the meaning of the pattern. For example:</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">^HTML</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">;</span>             <span class="token comment">// Match the letters H T M L at the start of a string</span>
<span class="token operator">/</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token operator">-</span><span class="token number">9</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token operator">-</span><span class="token number">9</span><span class="token punctuation">]</span><span class="token operator">*</span><span class="token operator">/</span><span class="token punctuation">;</span>       <span class="token comment">// Match a nonzero digit, followed by any # of digits</span>
<span class="token operator">/</span>\bjavascript\b<span class="token operator">/</span>i<span class="token punctuation">;</span>   <span class="token comment">// Match &quot;javascript&quot; as a word, case-insensitive</span>
</code></pre></div><p>RegExp objects define a number of useful methods, and strings also have methods that accept RegExp arguments. For example:</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> text <span class="token operator">=</span> <span class="token string">&quot;testing: 1, 2, 3&quot;</span><span class="token punctuation">;</span>   <span class="token comment">// Sample text</span>
<span class="token keyword">let</span> pattern <span class="token operator">=</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">\d+</span><span class="token regex-delimiter">/</span><span class="token regex-flags">g</span></span><span class="token punctuation">;</span>            <span class="token comment">// Matches all instances of one or more digits</span>
pattern<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span>text<span class="token punctuation">)</span>               <span class="token comment">// =&gt; true: a match exists</span>
text<span class="token punctuation">.</span><span class="token function">search</span><span class="token punctuation">(</span>pattern<span class="token punctuation">)</span>             <span class="token comment">// =&gt; 9: position of first match</span>
text<span class="token punctuation">.</span><span class="token function">match</span><span class="token punctuation">(</span>pattern<span class="token punctuation">)</span>              <span class="token comment">// =&gt; [&quot;1&quot;, &quot;2&quot;, &quot;3&quot;]: array of all matches</span>
text<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span>pattern<span class="token punctuation">,</span> <span class="token string">&quot;#&quot;</span><span class="token punctuation">)</span>       <span class="token comment">// =&gt; &quot;testing: #, #, #&quot;</span>
text<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">\D+</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">)</span>                <span class="token comment">// =&gt; [&quot;&quot;,&quot;1&quot;,&quot;2&quot;,&quot;3&quot;]: split on nondigits</span>
</code></pre></div><h2 id="_3-4-boolean-values"><a href="#_3-4-boolean-values" class="header-anchor">#</a> 3.4 Boolean Values</h2> <p>A boolean value represents truth or falsehood, on or off, yes or no. There are only two possible values of this type. The reserved words true and false evaluate to these two values.</p> <p>Boolean values are generally the result of comparisons you make in your JavaScript programs. For example:</p> <div class="language-js extra-class"><pre class="language-js"><code>a <span class="token operator">===</span> <span class="token number">4</span>
</code></pre></div><p>This code tests to see whether the value of the variable a is equal to the number 4. If it is, the result of this comparison is the boolean value true. If a is not equal to 4, the result of the comparison is false.</p> <p>Boolean values are commonly used in JavaScript control structures. For example, the if/else statement in JavaScript performs one action if a boolean value is true and another action if the value is false. You usually combine a comparison that creates a boolean value directly with a statement that uses it. The result looks like this:</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">if</span> <span class="token punctuation">(</span>a <span class="token operator">===</span> <span class="token number">4</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    b <span class="token operator">=</span> b <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    a <span class="token operator">=</span> a <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>This code checks whether a equals 4. If so, it adds 1 to b; otherwise, it adds 1 to a.</p> <p>As we’ll discuss in §3.9, any JavaScript value can be converted to a boolean value. The following values convert to, and therefore work like, false:</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">undefined</span>
<span class="token keyword">null</span>
<span class="token number">0</span>
<span class="token operator">-</span><span class="token number">0</span>
<span class="token number">NaN</span>
<span class="token string">&quot;&quot;</span>  <span class="token comment">// the empty string</span>
</code></pre></div><p>All other values, including all objects (and arrays) convert to, and work like, true. false, and the six values that convert to it, are sometimes called falsy values, and all other values are called truthy. Any time JavaScript expects a boolean value, a falsy value works like false and a truthy value works like true.</p> <p>As an example, suppose that the variable o either holds an object or the value null. You can test explicitly to see if o is non-null with an if statement like this:</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">if</span> <span class="token punctuation">(</span>o <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token operator">...</span>
</code></pre></div><p>The not-equal operator !== compares o to null and evaluates to either true or false. But you can omit the comparison and instead rely on the fact that null is falsy and objects are truthy:</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">if</span> <span class="token punctuation">(</span>o<span class="token punctuation">)</span> <span class="token operator">...</span>
</code></pre></div><p>In the first case, the body of the if will be executed only if o is not null. The second case is less strict: it will execute the body of the if only if o is not false or any falsy value (such as null or undefined). Which if statement is appropriate for your program really depends on what values you expect to be assigned to o. If you need to distinguish null from 0 and &quot;&quot;, then you should use an explicit comparison.</p> <p>Boolean values have a toString() method that you can use to convert them to the strings “true” or “false”, but they do not have any other useful methods. Despite the trivial API, there are three important boolean operators.</p> <p>The &amp;&amp; operator performs the Boolean AND operation. It evaluates to a truthy value if and only if both of its operands are truthy; it evaluates to a falsy value otherwise. The || operator is the Boolean OR operation: it evaluates to a truthy value if either one (or both) of its operands is truthy and evaluates to a falsy value if both operands are falsy. Finally, the unary ! operator performs the Boolean NOT operation: it evaluates to true if its operand is falsy and evaluates to false if its operand is truthy. For example:</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>x <span class="token operator">===</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> y <span class="token operator">===</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token operator">!</span><span class="token punctuation">(</span>z <span class="token operator">===</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// x and y are both zero or z is non-zero</span>
<span class="token punctuation">}</span>
</code></pre></div><p>Full details on these operators are in §4.10.</p> <h2 id="_3-5-null-and-undefined"><a href="#_3-5-null-and-undefined" class="header-anchor">#</a> 3.5 null and undefined</h2> <p>null is a language keyword that evaluates to a special value that is usually used to indicate the absence of a value. Using the typeof operator on null returns the string “object”, indicating that null can be thought of as a special object value that indicates “no object”. In practice, however, null is typically regarded as the sole member of its own type, and it can be used to indicate “no value” for numbers and strings as well as objects. Most programming languages have an equivalent to JavaScript’s null: you may be familiar with it as NULL, nil, or None.</p> <p>JavaScript also has a second value that indicates absence of value. The undefined value represents a deeper kind of absence. It is the value of variables that have not been initialized and the value you get when you query the value of an object property or array element that does not exist. The undefined value is also the return value of functions that do not explicitly return a value and the value of function parameters for which no argument is passed. undefined is a predefined global constant (not a language keyword like null, though this is not an important distinction in practice) that is initialized to the undefined value. If you apply the typeof operator to the undefined value, it returns “undefined”, indicating that this value is the sole member of a special type.</p> <p>Despite these differences, null and undefined both indicate an absence of value and can often be used interchangeably. The equality operator == considers them to be equal. (Use the strict equality operator === to distinguish them.) Both are falsy values: they behave like false when a boolean value is required. Neither null nor undefined have any properties or methods. In fact, using . or [] to access a property or method of these values causes a TypeError.</p> <p>I consider undefined to represent a system-level, unexpected, or error-like absence of value and null to represent a program-level, normal, or expected absence of value. I avoid using null and undefined when I can, but if I need to assign one of these values to a variable or property or pass or return one of these values to or from a function, I usually use null. Some programmers strive to avoid null entirely and use undefined in its place wherever they can.</p> <h2 id="_3-6-symbols"><a href="#_3-6-symbols" class="header-anchor">#</a> 3.6 Symbols</h2> <p>Symbols were introduced in ES6 to serve as non-string property names. To understand Symbols, you need to know that JavaScript’s fundamental Object type is an unordered collection of properties, where each property has a name and a value. Property names are typically (and until ES6, were exclusively) strings. But in ES6 and later, Symbols can also serve this purpose:</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> strname <span class="token operator">=</span> <span class="token string">&quot;string name&quot;</span><span class="token punctuation">;</span>      <span class="token comment">// A string to use as a property name</span>
<span class="token keyword">let</span> symname <span class="token operator">=</span> <span class="token function">Symbol</span><span class="token punctuation">(</span><span class="token string">&quot;propname&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// A Symbol to use as a property name</span>
<span class="token keyword">typeof</span> strname                    <span class="token comment">// =&gt; &quot;string&quot;: strname is a string</span>
<span class="token keyword">typeof</span> symname                    <span class="token comment">// =&gt; &quot;symbol&quot;: symname is a symbol</span>
<span class="token keyword">let</span> o <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>                       <span class="token comment">// Create a new object</span>
o<span class="token punctuation">[</span>strname<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>                   <span class="token comment">// Define a property with a string name</span>
o<span class="token punctuation">[</span>symname<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>                   <span class="token comment">// Define a property with a Symbol name</span>
o<span class="token punctuation">[</span>strname<span class="token punctuation">]</span>                        <span class="token comment">// =&gt; 1: access the string-named property</span>
o<span class="token punctuation">[</span>symname<span class="token punctuation">]</span>                        <span class="token comment">// =&gt; 2: access the symbol-named property</span>
</code></pre></div><p>The Symbol type does not have a literal syntax. To obtain a Symbol value, you call the Symbol() function. This function never returns the same value twice, even when called with the same argument. This means that if you call Symbol() to obtain a Symbol value, you can safely use that value as a property name to add a new property to an object and do not need to worry that you might be overwriting an existing property with the same name. Similarly, if you use symbolic property names and do not share those symbols, you can be confident that other modules of code in your program will not accidentally overwrite your properties.</p> <p>In practice, Symbols serve as a language extension mechanism. When ES6 introduced the for/of loop (§5.4.4) and iterable objects (Chapter 12), it needed to define standard method that classes could implement to make themselves iterable. But standardizing any particular string name for this iterator method would have broken existing code, so a symbolic name was used instead. As we’ll see in Chapter 12, Symbol.iterator is a Symbol value that can be used as a method name to make an object iterable.</p> <p>The Symbol() function takes an optional string argument and returns a unique Symbol value. If you supply a string argument, that string will be included in the output of the Symbol’s toString() method. Note, however, that calling Symbol() twice with the same string produces two completely different Symbol values.</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> s <span class="token operator">=</span> <span class="token function">Symbol</span><span class="token punctuation">(</span><span class="token string">&quot;sym_x&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
s<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span>             <span class="token comment">// =&gt; &quot;Symbol(sym_x)&quot;</span>
</code></pre></div><p>toString() is the only interesting method of Symbol instances. There are two other Symbol-related functions you should know about, however. Sometimes when using Symbols, you want to keep them private to your own code so you have a guarantee that your properties will never conflict with properties used by other code. Other times, however, you might want to define a Symbol value and share it widely with other code. This would be the case, for example, if you were defining some kind of extension that you wanted other code to be able to participate in, as with the Symbol.iterator mechanism described earlier.</p> <p>To serve this latter use case, JavaScript defines a global Symbol registry. The Symbol.for() function takes a string argument and returns a Symbol value that is associated with the string you pass. If no Symbol is already associated with that string, then a new one is created and returned; otherwise, the already existing Symbol is returned. That is, the Symbol.for() function is completely different than the Symbol() function: Symbol() never returns the same value twice, but Symbol.for() always returns the same value when called with the same string. The string passed to Symbol.for() appears in the output of toString() for the returned Symbol, and it can also be retrieved by calling Symbol.keyFor() on the returned Symbol.</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> s <span class="token operator">=</span> Symbol<span class="token punctuation">.</span><span class="token function">for</span><span class="token punctuation">(</span><span class="token string">&quot;shared&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> t <span class="token operator">=</span> Symbol<span class="token punctuation">.</span><span class="token function">for</span><span class="token punctuation">(</span><span class="token string">&quot;shared&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
s <span class="token operator">===</span> t          <span class="token comment">// =&gt; true</span>
s<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span>     <span class="token comment">// =&gt; &quot;Symbol(shared)&quot;</span>
Symbol<span class="token punctuation">.</span><span class="token function">keyFor</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span> <span class="token comment">// =&gt; &quot;shared&quot;</span>
</code></pre></div><h2 id="_3-7-the-global-object"><a href="#_3-7-the-global-object" class="header-anchor">#</a> 3.7 The Global Object</h2> <p>The preceding sections have explained JavaScript’s primitive types and values. Object types—objects, arrays, and functions—are covered in chapters of their own later in this book. But there is one very important object value that we must cover now. The global object is a regular JavaScript object that serves a very important purpose: the properties of this object are the globally defined identifiers that are available to a JavaScript program. When the JavaScript interpreter starts (or whenever a web browser loads a new page), it creates a new global object and gives it an initial set of properties that define:</p> <ul><li>Global constants like undefined, Infinity, and NaN</li> <li>Global functions like isNaN(), parseInt() (§3.9.2), and eval() (§4.12)</li> <li>Constructor functions like Date(), RegExp(), String(), Object(), and Array() (§3.9.2)</li> <li>Global objects like Math and JSON (§6.8)</li></ul> <p>The initial properties of the global object are not reserved words, but they deserve to be treated as if they are. This chapter has already described some of these global properties. Most of the others will be covered elsewhere in this book.</p> <p>In Node, the global object has a property named global whose value is the global object itself, so you can always refer to the global object by the name global in Node programs.</p> <p>In web browsers, the Window object serves as the global object for all JavaScript code contained in the browser window it represents. This global Window object has a self-referential window property that can be used to refer to the global object. The Window object defines the core global properties, but it also defines quite a few other globals that are specific to web browsers and client-side JavaScript. Web worker threads (§15.13) have a different global object than the Window with which they are associated. Code in a worker can refer to its global object as self.</p> <p>ES2020 finally defines globalThis as the standard way to refer to the global object in any context. As of early 2020, this feature has been implemented by all modern browsers and by Node.</p> <h2 id="_3-8-immutable-primitive-values-and-mutable-object-references"><a href="#_3-8-immutable-primitive-values-and-mutable-object-references" class="header-anchor">#</a> 3.8 Immutable Primitive Values and Mutable Object References</h2> <p>There is a fundamental difference in JavaScript between primitive values (undefined, null, booleans, numbers, and strings) and objects (including arrays and functions). Primitives are immutable: there is no way to change (or “mutate”) a primitive value. This is obvious for numbers and booleans—it doesn’t even make sense to change the value of a number. It is not so obvious for strings, however. Since strings are like arrays of characters, you might expect to be able to alter the character at any specified index. In fact, JavaScript does not allow this, and all string methods that appear to return a modified string are, in fact, returning a new string value. For example:</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> s <span class="token operator">=</span> <span class="token string">&quot;hello&quot;</span><span class="token punctuation">;</span>   <span class="token comment">// Start with some lowercase text</span>
s<span class="token punctuation">.</span><span class="token function">toUpperCase</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// Returns &quot;HELLO&quot;, but doesn't alter s</span>
s                  <span class="token comment">// =&gt; &quot;hello&quot;: the original string has not changed</span>
</code></pre></div><p>Primitives are also compared by value: two values are the same only if they have the same value. This sounds circular for numbers, booleans, null, and undefined: there is no other way that they could be compared. Again, however, it is not so obvious for strings. If two distinct string values are compared, JavaScript treats them as equal if, and only if, they have the same length and if the character at each index is the same.</p> <p>Objects are different than primitives. First, they are mutable—their values can change:</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> o <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token literal-property property">x</span><span class="token operator">:</span> <span class="token number">1</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token comment">// Start with an object</span>
o<span class="token punctuation">.</span>x <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>           <span class="token comment">// Mutate it by changing the value of a property</span>
o<span class="token punctuation">.</span>y <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>           <span class="token comment">// Mutate it again by adding a new property</span>

<span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>   <span class="token comment">// Arrays are also mutable</span>
a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>          <span class="token comment">// Change the value of an array element</span>
a<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span>          <span class="token comment">// Add a new array element</span>
</code></pre></div><p>Objects are not compared by value: two distinct objects are not equal even if they have the same properties and values. And two distinct arrays are not equal even if they have the same elements in the same order:</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> o <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token literal-property property">x</span><span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">,</span> p <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token literal-property property">x</span><span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token comment">// Two objects with the same properties</span>
o <span class="token operator">===</span> p                      <span class="token comment">// =&gt; false: distinct objects are never equal</span>
<span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> b <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>          <span class="token comment">// Two distinct, empty arrays</span>
a <span class="token operator">===</span> b                      <span class="token comment">// =&gt; false: distinct arrays are never equal</span>
</code></pre></div><p>Objects are sometimes called reference types to distinguish them from JavaScript’s primitive types. Using this terminology, object values are references, and we say that objects are compared by reference: two object values are the same if and only if they refer to the same underlying object.</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>   <span class="token comment">// The variable a refers to an empty array.</span>
<span class="token keyword">let</span> b <span class="token operator">=</span> a<span class="token punctuation">;</span>    <span class="token comment">// Now b refers to the same array.</span>
b<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>     <span class="token comment">// Mutate the array referred to by variable b.</span>
a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>          <span class="token comment">// =&gt; 1: the change is also visible through variable a.</span>
a <span class="token operator">===</span> b       <span class="token comment">// =&gt; true: a and b refer to the same object, so they are equal.</span>
</code></pre></div><p>As you can see from this code, assigning an object (or array) to a variable simply assigns the reference: it does not create a new copy of the object. If you want to make a new copy of an object or array, you must explicitly copy the properties of the object or the elements of the array. This example demonstrates using a for loop (§5.4.3):</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">&quot;a&quot;</span><span class="token punctuation">,</span><span class="token string">&quot;b&quot;</span><span class="token punctuation">,</span><span class="token string">&quot;c&quot;</span><span class="token punctuation">]</span><span class="token punctuation">;</span>              <span class="token comment">// An array we want to copy</span>
<span class="token keyword">let</span> b <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                         <span class="token comment">// A distinct array we'll copy into</span>
<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> a<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// For each index of a[]</span>
    b<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>                    <span class="token comment">// Copy an element of a into b</span>
<span class="token punctuation">}</span>
<span class="token keyword">let</span> c <span class="token operator">=</span> Array<span class="token punctuation">.</span><span class="token function">from</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>              <span class="token comment">// In ES6, copy arrays with Array.from()</span>
</code></pre></div><p>Similarly, if we want to compare two distinct objects or arrays, we must compare their properties or elements. This code defines a function to compare two arrays:</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">equalArrays</span><span class="token punctuation">(</span><span class="token parameter">a<span class="token punctuation">,</span> b</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>a <span class="token operator">===</span> b<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                <span class="token comment">// Identical arrays are equal</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token punctuation">.</span>length <span class="token operator">!==</span> b<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span> <span class="token comment">// Different-size arrays not equal</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> a<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token comment">// Loop through all elements</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!==</span> b<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>     <span class="token comment">// If any differ, arrays not equal</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                             <span class="token comment">// Otherwise they are equal</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="_3-9-type-conversions"><a href="#_3-9-type-conversions" class="header-anchor">#</a> 3.9 Type Conversions</h2> <p>JavaScript is very flexible about the types of values it requires. We’ve seen this for booleans: when JavaScript expects a boolean value, you may supply a value of any type, and JavaScript will convert it as needed. Some values (“truthy” values) convert to true and others (“falsy” values) convert to false. The same is true for other types: if JavaScript wants a string, it will convert whatever value you give it to a string. If JavaScript wants a number, it will try to convert the value you give it to a number (or to NaN if it cannot perform a meaningful conversion).</p> <p>Some examples:</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token number">10</span> <span class="token operator">+</span> <span class="token string">&quot; objects&quot;</span>     <span class="token comment">// =&gt; &quot;10 objects&quot;:  Number 10 converts to a string</span>
<span class="token string">&quot;7&quot;</span> <span class="token operator">*</span> <span class="token string">&quot;4&quot;</span>           <span class="token comment">// =&gt; 28: both strings convert to numbers</span>
<span class="token keyword">let</span> n <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">-</span> <span class="token string">&quot;x&quot;</span><span class="token punctuation">;</span>    <span class="token comment">// n == NaN; string &quot;x&quot; can't convert to a number</span>
n <span class="token operator">+</span> <span class="token string">&quot; objects&quot;</span>      <span class="token comment">// =&gt; &quot;NaN objects&quot;: NaN converts to string &quot;NaN&quot;</span>
</code></pre></div><p>Table 3-2 summarizes how values convert from one type to another in JavaScript. Bold entries in the table highlight conversions that you may find surprising. Empty cells indicate that no conversion is necessary and none is performed.</p> <p>Table 3-2. JavaScript type conversions</p> <table><thead><tr><th>Value</th> <th>to String</th> <th>to Number</th> <th>to Boolean</th></tr></thead> <tbody><tr><td>undefined</td> <td>&quot;undefined&quot;</td> <td>NaN</td> <td>false</td></tr> <tr><td>null</td> <td>&quot;null&quot;</td> <td>0</td> <td>false</td></tr> <tr><td>true</td> <td>&quot;true&quot;</td> <td>1</td> <td></td></tr> <tr><td>false</td> <td>&quot;false&quot;</td> <td>0</td> <td></td></tr> <tr><td>&quot;&quot; (empty string)</td> <td></td> <td>0</td> <td>false</td></tr> <tr><td>&quot;1.2&quot; (nonempty, numeric)</td> <td></td> <td>1.2</td> <td>true</td></tr> <tr><td>&quot;one&quot; (nonempty, non-numeric)</td> <td></td> <td>NaN</td> <td>true</td></tr> <tr><td>0</td> <td>&quot;0&quot;</td> <td></td> <td>false</td></tr> <tr><td>-0</td> <td>&quot;0&quot;</td> <td></td> <td>false</td></tr> <tr><td>1 (finite, non-zero)</td> <td>&quot;1&quot;</td> <td></td> <td>true</td></tr> <tr><td>Infinity</td> <td>&quot;Infinity&quot;</td> <td></td> <td>true</td></tr> <tr><td>-Infinity</td> <td>&quot;-Infinity&quot;</td> <td></td> <td>true</td></tr> <tr><td>NaN</td> <td>&quot;NaN&quot;</td> <td></td> <td>false</td></tr> <tr><td>{} (any object)</td> <td>see §3.9.3</td> <td>see §3.9.3</td> <td>true</td></tr> <tr><td>[] (empty array)</td> <td>&quot;&quot;</td> <td>0</td> <td>true</td></tr> <tr><td>[9] (one numeric element)</td> <td>&quot;9&quot;</td> <td>9</td> <td>true</td></tr> <tr><td>['a'] (any other array)</td> <td>use join() method</td> <td>NaN</td> <td>true</td></tr> <tr><td>function(){} (any function)</td> <td>see §3.9.3</td> <td>NaN</td> <td>true</td></tr></tbody></table> <p>The primitive-to-primitive conversions shown in the table are relatively straightforward. Conversion to boolean was already discussed in §3.4. Conversion to strings is well defined for all primitive values. Conversion to numbers is just a little trickier. Strings that can be parsed as numbers convert to those numbers. Leading and trailing spaces are allowed, but any leading or trailing nonspace characters that are not part of a numeric literal cause the string-to-number conversion to produce NaN. Some numeric conversions may seem surprising: true converts to 1, and false and the empty string convert to 0.</p> <p>Object-to-primitive conversion is somewhat more complicated, and it is the subject of §3.9.3.</p> <h3 id="_3-9-1-conversions-and-equality"><a href="#_3-9-1-conversions-and-equality" class="header-anchor">#</a> 3.9.1 Conversions and Equality</h3> <p>JavaScript has two operators that test whether two values are equal. The “strict equality operator,” ===, does not consider its operands to be equal if they are not of the same type, and this is almost always the right operator to use when coding. But because JavaScript is so flexible with type conversions, it also defines the == operator with a flexible definition of equality. All of the following comparisons are true, for example:</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">null</span> <span class="token operator">==</span> <span class="token keyword">undefined</span> <span class="token comment">// =&gt; true: These two values are treated as equal.</span>
<span class="token string">&quot;0&quot;</span> <span class="token operator">==</span> <span class="token number">0</span>          <span class="token comment">// =&gt; true: String converts to a number before comparing.</span>
<span class="token number">0</span> <span class="token operator">==</span> <span class="token boolean">false</span>        <span class="token comment">// =&gt; true: Boolean converts to number before comparing.</span>
<span class="token string">&quot;0&quot;</span> <span class="token operator">==</span> <span class="token boolean">false</span>      <span class="token comment">// =&gt; true: Both operands convert to 0 before comparing!</span>
</code></pre></div><p>§4.9.1 explains exactly what conversions are performed by the == operator in order to determine whether two values should be considered equal.</p> <p>Keep in mind that convertibility of one value to another does not imply equality of those two values. If undefined is used where a boolean value is expected, for example, it will convert to false. But this does not mean that undefined == false. JavaScript operators and statements expect values of various types and perform conversions to those types. The if statement converts undefined to false, but the == operator never attempts to convert its operands to booleans.</p> <h3 id="_3-9-2-explicit-conversions"><a href="#_3-9-2-explicit-conversions" class="header-anchor">#</a> 3.9.2 Explicit Conversions</h3> <p>Although JavaScript performs many type conversions automatically, you may sometimes need to perform an explicit conversion, or you may prefer to make the conversions explicit to keep your code clearer.</p> <p>The simplest way to perform an explicit type conversion is to use the Boolean(), Number(), and String() functions:</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token function">Number</span><span class="token punctuation">(</span><span class="token string">&quot;3&quot;</span><span class="token punctuation">)</span>    <span class="token comment">// =&gt; 3</span>
<span class="token function">String</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span>  <span class="token comment">// =&gt; &quot;false&quot;:  Or use false.toString()</span>
<span class="token function">Boolean</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>    <span class="token comment">// =&gt; true</span>
</code></pre></div><p>Any value other than null or undefined has a toString() method, and the result of this method is usually the same as that returned by the String() function.</p> <p>As an aside, note that the Boolean(), Number(), and String() functions can also be invoked—with new—as constructor. If you use them this way, you’ll get a “wrapper” object that behaves just like a primitive boolean, number, or string value. These wrapper objects are a historical leftover from the earliest days of JavaScript, and there is never really any good reason to use them.</p> <p>Certain JavaScript operators perform implicit type conversions and are sometimes used explicitly for the purpose of type conversion. If one operand of the + operator is a string, it converts the other one to a string. The unary + operator converts its operand to a number. And the unary ! operator converts its operand to a boolean and negates it. These facts lead to the following type conversion idioms that you may see in some code:</p> <div class="language-js extra-class"><pre class="language-js"><code>x <span class="token operator">+</span> <span class="token string">&quot;&quot;</span>   <span class="token comment">// =&gt; String(x)</span>
<span class="token operator">+</span>x       <span class="token comment">// =&gt; Number(x)</span>
x<span class="token operator">-</span><span class="token number">0</span>      <span class="token comment">// =&gt; Number(x)</span>
<span class="token operator">!</span><span class="token operator">!</span>x      <span class="token comment">// =&gt; Boolean(x): Note double !</span>
</code></pre></div><p>Formatting and parsing numbers are common tasks in computer programs, and JavaScript has specialized functions and methods that provide more precise control over number-to-string and string-to-number conversions.</p> <p>The toString() method defined by the Number class accepts an optional argument that specifies a radix, or base, for the conversion. If you do not specify the argument, the conversion is done in base 10. However, you can also convert numbers in other bases (between 2 and 36). For example:</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> n <span class="token operator">=</span> <span class="token number">17</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> binary <span class="token operator">=</span> <span class="token string">&quot;0b&quot;</span> <span class="token operator">+</span> n<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// binary == &quot;0b10001&quot;</span>
<span class="token keyword">let</span> octal <span class="token operator">=</span> <span class="token string">&quot;0o&quot;</span> <span class="token operator">+</span> n<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// octal == &quot;0o21&quot;</span>
<span class="token keyword">let</span> hex <span class="token operator">=</span> <span class="token string">&quot;0x&quot;</span> <span class="token operator">+</span> n<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// hex == &quot;0x11&quot;</span>
</code></pre></div><p>When working with financial or scientific data, you may want to convert numbers to strings in ways that give you control over the number of decimal places or the number of significant digits in the output, or you may want to control whether exponential notation is used. The Number class defines three methods for these kinds of number-to-string conversions. toFixed() converts a number to a string with a specified number of digits after the decimal point. It never uses exponential notation. toExponential() converts a number to a string using exponential notation, with one digit before the decimal point and a specified number of digits after the decimal point (which means that the number of significant digits is one larger than the value you specify). toPrecision() converts a number to a string with the number of significant digits you specify. It uses exponential notation if the number of significant digits is not large enough to display the entire integer portion of the number. Note that all three methods round the trailing digits or pad with zeros as appropriate. Consider the following examples:</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> n <span class="token operator">=</span> <span class="token number">123456.789</span><span class="token punctuation">;</span>
n<span class="token punctuation">.</span><span class="token function">toFixed</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>         <span class="token comment">// =&gt; &quot;123457&quot;</span>
n<span class="token punctuation">.</span><span class="token function">toFixed</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>         <span class="token comment">// =&gt; &quot;123456.79&quot;</span>
n<span class="token punctuation">.</span><span class="token function">toFixed</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span>         <span class="token comment">// =&gt; &quot;123456.78900&quot;</span>
n<span class="token punctuation">.</span><span class="token function">toExponential</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>   <span class="token comment">// =&gt; &quot;1.2e+5&quot;</span>
n<span class="token punctuation">.</span><span class="token function">toExponential</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span>   <span class="token comment">// =&gt; &quot;1.235e+5&quot;</span>
n<span class="token punctuation">.</span><span class="token function">toPrecision</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span>     <span class="token comment">// =&gt; &quot;1.235e+5&quot;</span>
n<span class="token punctuation">.</span><span class="token function">toPrecision</span><span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">)</span>     <span class="token comment">// =&gt; &quot;123456.8&quot;</span>
n<span class="token punctuation">.</span><span class="token function">toPrecision</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span>    <span class="token comment">// =&gt; &quot;123456.7890&quot;</span>
</code></pre></div><p>In addition to the number-formatting methods shown here, the Intl.NumberFormat class defines a more general, internationalized number-formatting method. See §11.7.1 for details.</p> <p>If you pass a string to the Number() conversion function, it attempts to parse that string as an integer or floating-point literal. That function only works for base-10 integers and does not allow trailing characters that are not part of the literal. The parseInt() and parseFloat() functions (these are global functions, not methods of any class) are more flexible. parseInt() parses only integers, while parseFloat() parses both integers and floating-point numbers. If a string begins with “0x” or “0X”, parseInt() interprets it as a hexadecimal number. Both parseInt() and parseFloat() skip leading whitespace, parse as many numeric characters as they can, and ignore anything that follows. If the first nonspace character is not part of a valid numeric literal, they return NaN:</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token function">parseInt</span><span class="token punctuation">(</span><span class="token string">&quot;3 blind mice&quot;</span><span class="token punctuation">)</span>     <span class="token comment">// =&gt; 3</span>
<span class="token function">parseFloat</span><span class="token punctuation">(</span><span class="token string">&quot; 3.14 meters&quot;</span><span class="token punctuation">)</span>   <span class="token comment">// =&gt; 3.14</span>
<span class="token function">parseInt</span><span class="token punctuation">(</span><span class="token string">&quot;-12.34&quot;</span><span class="token punctuation">)</span>           <span class="token comment">// =&gt; -12</span>
<span class="token function">parseInt</span><span class="token punctuation">(</span><span class="token string">&quot;0xFF&quot;</span><span class="token punctuation">)</span>             <span class="token comment">// =&gt; 255</span>
<span class="token function">parseInt</span><span class="token punctuation">(</span><span class="token string">&quot;0xff&quot;</span><span class="token punctuation">)</span>             <span class="token comment">// =&gt; 255</span>
<span class="token function">parseInt</span><span class="token punctuation">(</span><span class="token string">&quot;-0XFF&quot;</span><span class="token punctuation">)</span>            <span class="token comment">// =&gt; -255</span>
<span class="token function">parseFloat</span><span class="token punctuation">(</span><span class="token string">&quot;.1&quot;</span><span class="token punctuation">)</span>             <span class="token comment">// =&gt; 0.1</span>
<span class="token function">parseInt</span><span class="token punctuation">(</span><span class="token string">&quot;0.1&quot;</span><span class="token punctuation">)</span>              <span class="token comment">// =&gt; 0</span>
<span class="token function">parseInt</span><span class="token punctuation">(</span><span class="token string">&quot;.1&quot;</span><span class="token punctuation">)</span>               <span class="token comment">// =&gt; NaN: integers can't start with &quot;.&quot;</span>
<span class="token function">parseFloat</span><span class="token punctuation">(</span><span class="token string">&quot;$72.47&quot;</span><span class="token punctuation">)</span>         <span class="token comment">// =&gt; NaN: numbers can't start with &quot;$&quot;</span>
</code></pre></div><p>parseInt() accepts an optional second argument specifying the radix (base) of the number to be parsed. Legal values are between 2 and 36. For example:</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token function">parseInt</span><span class="token punctuation">(</span><span class="token string">&quot;11&quot;</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span>     <span class="token comment">// =&gt; 3: (1*2 + 1)</span>
<span class="token function">parseInt</span><span class="token punctuation">(</span><span class="token string">&quot;ff&quot;</span><span class="token punctuation">,</span> <span class="token number">16</span><span class="token punctuation">)</span>    <span class="token comment">// =&gt; 255: (15*16 + 15)</span>
<span class="token function">parseInt</span><span class="token punctuation">(</span><span class="token string">&quot;zz&quot;</span><span class="token punctuation">,</span> <span class="token number">36</span><span class="token punctuation">)</span>    <span class="token comment">// =&gt; 1295: (35*36 + 35)</span>
<span class="token function">parseInt</span><span class="token punctuation">(</span><span class="token string">&quot;077&quot;</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">)</span>    <span class="token comment">// =&gt; 63: (7*8 + 7)</span>
<span class="token function">parseInt</span><span class="token punctuation">(</span><span class="token string">&quot;077&quot;</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span>   <span class="token comment">// =&gt; 77: (7*10 + 7)</span>
</code></pre></div><h3 id="_3-9-3-object-to-primitive-conversions"><a href="#_3-9-3-object-to-primitive-conversions" class="header-anchor">#</a> 3.9.3 Object to Primitive Conversions</h3> <p>The previous sections have explained how you can explicitly convert values of one type to another type and have explained JavaScript’s implicit conversions of values from one primitive type to another primitive type. This section covers the complicated rules that JavaScript uses to convert objects to primitive values. It is long and obscure, and if this is your first reading of this chapter, you should feel free to skip ahead to §3.10.</p> <p>One reason for the complexity of JavaScript’s object-to-primitive conversions is that some types of objects have more than one primitive representation. Date objects, for example, can be represented as strings or as numeric timestamps. The JavaScript specification defines three fundamental algorithms for converting objects to primitive values:</p> <p>prefer-string
This algorithm returns a primitive value, preferring a string value, if a conversion to string is possible.</p> <p>prefer-number
This algorithm returns a primitive value, preferring a number, if such a conversion is possible.</p> <p>no-preference
This algorithm expresses no preference about what type of primitive value is desired, and classes can define their own conversions. Of the built-in JavaScript types, all except Date implement this algorithm as prefer-number. The Date class implements this algorithm as prefer-string.</p> <p>The implementation of these object-to-primitive conversion algorithms is explained at the end of this section. First, however, we explain how the algorithms are used in JavaScript.</p> <p>OBJECT-TO-BOOLEAN CONVERSIONS
Object-to-boolean conversions are trivial: all objects convert to true. Notice that this conversion does not require the use of the object-to-primitive algorithms described, and that it literally applies to all objects, including empty arrays and even the wrapper object new Boolean(false).</p> <p>OBJECT-TO-STRING CONVERSIONS
When an object needs to be converted to a string, JavaScript first converts it to a primitive using the prefer-string algorithm, then converts the resulting primitive value to a string, if necessary, following the rules in Table 3-2.</p> <p>This kind of conversion happens, for example, if you pass an object to a built-in function that expects a string argument, if you call String() as a conversion function, and when you interpolate objects into template literals (§3.3.4).</p> <p>OBJECT-TO-NUMBER CONVERSIONS
When an object needs to be converted to a number, JavaScript first converts it to a primitive value using the prefer-number algorithm, then converts the resulting primitive value to a number, if necessary, following the rules in Table 3-2.</p> <p>Built-in JavaScript functions and methods that expect numeric arguments convert object arguments to numbers in this way, and most (see the exceptions that follow) JavaScript operators that expect numeric operands convert objects to numbers in this way as well.</p> <p>SPECIAL CASE OPERATOR CONVERSIONS
Operators are covered in detail in Chapter 4. Here, we explain the special case operators that do not use the basic object-to-string and object-to-number conversions described earlier.</p> <p>The + operator in JavaScript performs numeric addition and string concatenation. If either of its operands is an object, JavaScript converts them to primitive values using the no-preference algorithm. Once it has two primitive values, it checks their types. If either argument is a string, it converts the other to a string and concatenates the strings. Otherwise, it converts both arguments to numbers and adds them.</p> <p>The == and != operators perform equality and inequality testing in a loose way that allows type conversions. If one operand is an object and the other is a primitive value, these operators convert the object to primitive using the no-preference algorithm and then compare the two primitive values.</p> <p>Finally, the relational operators &lt;, &lt;=, &gt;, and &gt;= compare the order of their operands and can be used to compare both numbers and strings. If either operand is an object, it is converted to a primitive value using the prefer-number algorithm. Note, however, that unlike the object-to-number conversion, the primitive values returned by the prefer-number conversion are not then converted to numbers.</p> <p>Note that the numeric representation of Date objects is meaningfully comparable with &lt; and &gt;, but the string representation is not. For Date objects, the no-preference algorithm converts to a string, so the fact that JavaScript uses the prefer-number algorithm for these operators means that we can use them to compare the order of two Date objects.</p> <p>THE TOSTRING() AND VALUEOF() METHODS
All objects inherit two conversion methods that are used by object-to-primitive conversions, and before we can explain the prefer-string, prefer-number, and no-preference conversion algorithms, we have to explain these two methods.</p> <p>The first method is toString(), and its job is to return a string representation of the object. The default toString() method does not return a very interesting value (though we’ll find it useful in §14.4.3):</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token literal-property property">x</span><span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token literal-property property">y</span><span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment">// =&gt; &quot;[object Object]&quot;</span>
</code></pre></div><p>Many classes define more specific versions of the toString() method. The toString() method of the Array class, for example, converts each array element to a string and joins the resulting strings together with commas in between. The toString() method of the Function class converts user-defined functions to strings of JavaScript source code. The Date class defines a toString() method that returns a human-readable (and JavaScript-parsable) date and time string. The RegExp class defines a toString() method that converts RegExp objects to a string that looks like a RegExp literal:</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                  <span class="token comment">// =&gt; &quot;1,2,3&quot;</span>
<span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">x</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token function">f</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment">// =&gt; &quot;function(x) { f(x); }&quot;</span>
<span class="token operator">/</span>\d<span class="token operator">+</span><span class="token operator">/</span>g<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                   <span class="token comment">// =&gt; &quot;/\\d+/g&quot;</span>
<span class="token keyword">let</span> d <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token number">2020</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
d<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment">// =&gt; &quot;Wed Jan 01 2020 00:00:00 GMT-0800 (Pacific Standard Time)&quot;</span>
</code></pre></div><p>The other object conversion function is called valueOf(). The job of this method is less well defined: it is supposed to convert an object to a primitive value that represents the object, if any such primitive value exists. Objects are compound values, and most objects cannot really be represented by a single primitive value, so the default valueOf() method simply returns the object itself rather than returning a primitive. Wrapper classes such as String, Number, and Boolean define valueOf() methods that simply return the wrapped primitive value. Arrays, functions, and regular expressions simply inherit the default method. Calling valueOf() for instances of these types simply returns the object itself. The Date class defines a valueOf() method that returns the date in its internal representation: the number of milliseconds since January 1, 1970:</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> d <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token number">2010</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// January 1, 2010, (Pacific time)</span>
d<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                     <span class="token comment">// =&gt; 1262332800000</span>
</code></pre></div><p>OBJECT-TO-PRIMITIVE CONVERSION ALGORITHMS
With the toString() and valueOf() methods explained, we can now explain approximately how the three object-to-primitive algorithms work (the complete details are deferred until §14.4.7):</p> <ul><li>The prefer-string algorithm first tries the toString() method. If the method is defined and returns a primitive value, then JavaScript uses that primitive value (even if it is not a string!). If toString() does not exist or if it returns an object, then JavaScript tries the valueOf() method. If that method exists and returns a primitive value, then JavaScript uses that value. Otherwise, the conversion fails with a TypeError.</li> <li>The prefer-number algorithm works like the prefer-string algorithm, except that it tries valueOf() first and toString() second.</li> <li>The no-preference algorithm depends on the class of the object being converted. If the object is a Date object, then JavaScript uses the prefer-string algorithm. For any other object, JavaScript uses the prefer-number algorithm.</li></ul> <p>The rules described here are true for all built-in JavaScript types and are the default rules for any classes you define yourself. §14.4.7 explains how you can define your own object-to-primitive conversion algorithms for the classes you define.</p> <p>Before we leave this topic, it is worth noting that the details of the prefer-number conversion explain why empty arrays convert to the number 0 and single-element arrays can also convert to numbers:</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token function">Number</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>    <span class="token comment">// =&gt; 0: this is unexpected!</span>
<span class="token function">Number</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">99</span><span class="token punctuation">]</span><span class="token punctuation">)</span>  <span class="token comment">// =&gt; 99: really?</span>
</code></pre></div><p>The object-to-number conversion first converts the object to a primitive using the prefer-number algorithm, then converts the resulting primitive value to a number. The prefer-number algorithm tries valueOf() first and then falls back on toString(). But the Array class inherits the default valueOf() method, which does not return a primitive value. So when we try to convert an array to a number, we end up invoking the toString() method of the array. Empty arrays convert to the empty string. And the empty string converts to the number 0. An array with a single element converts to the same string that that one element does. If an array contains a single number, that number is converted to a string, and then back to a number.</p> <h2 id="_3-10-variable-declaration-and-assignment"><a href="#_3-10-variable-declaration-and-assignment" class="header-anchor">#</a> 3.10 Variable Declaration and Assignment</h2> <p>One of the most fundamental techniques of computer programming is the use of names—or identifiers—to represent values. Binding a name to a value gives us a way to refer to that value and use it in the programs we write. When we do this, we typically say that we are assigning a value to a variable. The term “variable” implies that new values can be assigned: that the value associated with the variable may vary as our program runs. If we permanently assign a value to a name, then we call that name a constant instead of a variable.</p> <p>Before you can use a variable or constant in a JavaScript program, you must declare it. In ES6 and later, this is done with the let and const keywords, which we explain next. Prior to ES6, variables were declared with var, which is more idiosyncratic and is explained later on in this section.</p> <h3 id="_3-10-1-declarations-with-let-and-const"><a href="#_3-10-1-declarations-with-let-and-const" class="header-anchor">#</a> 3.10.1 Declarations with let and const</h3> <p>In modern JavaScript (ES6 and later), variables are declared with the let keyword, like this:</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> i<span class="token punctuation">;</span>
<span class="token keyword">let</span> sum<span class="token punctuation">;</span>
</code></pre></div><p>You can also declare multiple variables in a single let statement:</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> i<span class="token punctuation">,</span> sum<span class="token punctuation">;</span>
</code></pre></div><p>It is a good programming practice to assign an initial value to your variables when you declare them, when this is possible:</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> message <span class="token operator">=</span> <span class="token string">&quot;hello&quot;</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> x <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">,</span> y <span class="token operator">=</span> x<span class="token operator">*</span>x<span class="token punctuation">;</span> <span class="token comment">// Initializers can use previously declared variables</span>
</code></pre></div><p>If you don’t specify an initial value for a variable with the let statement, the variable is declared, but its value is undefined until your code assigns a value to it.</p> <p>To declare a constant instead of a variable, use const instead of let. const works just like let except that you must initialize the constant when you declare it:</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> <span class="token constant">H0</span> <span class="token operator">=</span> <span class="token number">74</span><span class="token punctuation">;</span>         <span class="token comment">// Hubble constant (km/s/Mpc)</span>
<span class="token keyword">const</span> <span class="token constant">C</span> <span class="token operator">=</span> <span class="token number">299792.458</span><span class="token punctuation">;</span>  <span class="token comment">// Speed of light in a vacuum (km/s)</span>
<span class="token keyword">const</span> <span class="token constant">AU</span> <span class="token operator">=</span> <span class="token number">1.496E8</span><span class="token punctuation">;</span>    <span class="token comment">// Astronomical Unit: distance to the sun (km)</span>
</code></pre></div><p>As the name implies, constants cannot have their values changed, and any attempt to do so causes a TypeError to be thrown.</p> <p>It is a common (but not universal) convention to declare constants using names with all capital letters such as H0 or HTTP_NOT_FOUND as a way to distinguish them from variables.</p> <p>WHEN TO USE CONST
There are two schools of thought about the use of the const keyword. One approach is to use const only for values that are fundamentally unchanging, like the physical constants shown, or program version numbers, or byte sequences used to identify file types, for example. Another approach recognizes that many of the so-called variables in our program don’t actually ever change as our program runs. In this approach, we declare everything with const, and then if we find that we do actually want to allow the value to vary, we switch the declaration to let. This may help prevent bugs by ruling out accidental changes to variables that we did not intend.</p> <p>In one approach, we use const only for values that must not change. In the other, we use const for any value that does not happen to change. I prefer the former approach in my own code.</p> <p>In Chapter 5, we’ll learn about the for, for/in, and for/of loop statements in JavaScript. Each of these loops includes a loop variable that gets a new value assigned to it on each iteration of the loop. JavaScript allows us to declare the loop variable as part of the loop syntax itself, and this is another common way to use let:</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> len <span class="token operator">=</span> data<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> len<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>data<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> datum <span class="token keyword">of</span> data<span class="token punctuation">)</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>datum<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> property <span class="token keyword">in</span> object<span class="token punctuation">)</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>property<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>It may seem surprising, but you can also use const to declare the loop “variables” for for/in and for/of loops, as long as the body of the loop does not reassign a new value. In this case, the const declaration is just saying that the value is constant for the duration of one loop iteration:</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">const</span> datum <span class="token keyword">of</span> data<span class="token punctuation">)</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>datum<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">const</span> property <span class="token keyword">in</span> object<span class="token punctuation">)</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>property<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>VARIABLE AND CONSTANT SCOPE
The scope of a variable is the region of your program source code in which it is defined. Variables and constants declared with let and const are block scoped. This means that they are only defined within the block of code in which the let or const statement appears. JavaScript class and function definitions are blocks, and so are the bodies of if/else statements, while loops, for loops, and so on. Roughly speaking, if a variable or constant is declared within a set of curly braces, then those curly braces delimit the region of code in which the variable or constant is defined (though of course it is not legal to reference a variable or constant from lines of code that execute before the let or const statement that declares the variable). Variables and constants declared as part of a for, for/in, or for/of loop have the loop body as their scope, even though they technically appear outside of the curly braces.</p> <p>When a declaration appears at the top level, outside of any code blocks, we say it is a global variable or constant and has global scope. In Node and in client-side JavaScript modules (see Chapter 10), the scope of a global variable is the file that it is defined in. In traditional client-side JavaScript, however, the scope of a global variable is the HTML document in which it is defined. That is: if one <code>&lt;script&gt;</code> declares a global variable or constant, that variable or constant is defined in all of the <code>&lt;script&gt;</code> elements in that document (or at least all of the scripts that execute after the let or const statement executes).</p> <p>REPEATED DECLARATIONS
It is a syntax error to use the same name with more than one let or const declaration in the same scope. It is legal (though a practice best avoided) to declare a new variable with the same name in a nested scope:</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> x <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token comment">// Declare x as a global constant</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">===</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> x <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>      <span class="token comment">// Inside a block x can refer to a different value</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Prints 2</span>
<span class="token punctuation">}</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// Prints 1: we're back in the global scope now</span>
<span class="token keyword">let</span> x <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>          <span class="token comment">// ERROR! Syntax error trying to re-declare x</span>
</code></pre></div><p>DECLARATIONS AND TYPES
If you’re used to statically typed languages such as C or Java, you may think that the primary purpose of variable declarations is to specify the type of values that may be assigned to a variable. But, as you have seen, there is no type associated with JavaScript’s variable declarations.2 A JavaScript variable can hold a value of any type. For example, it is perfectly legal (but generally poor programming style) in JavaScript to assign a number to a variable and then later assign a string to that variable:</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
i <span class="token operator">=</span> <span class="token string">&quot;ten&quot;</span><span class="token punctuation">;</span>
</code></pre></div><h3 id="_3-10-2-variable-declarations-with-var"><a href="#_3-10-2-variable-declarations-with-var" class="header-anchor">#</a> 3.10.2 Variable Declarations with var</h3> <p>In versions of JavaScript before ES6, the only way to declare a variable is with the var keyword, and there is no way to declare constants. The syntax of var is just like the syntax of let:</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> x<span class="token punctuation">;</span>
<span class="token keyword">var</span> data <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> count <span class="token operator">=</span> data<span class="token punctuation">.</span>length<span class="token punctuation">;</span>
<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> count<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>data<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>Although var and let have the same syntax, there are important differences in the way they work:</p> <ul><li>Variables declared with var do not have block scope. Instead, they are scoped to the body of the containing function no matter how deeply nested they are inside that function.</li> <li>If you use var outside of a function body, it declares a global variable. But global variables declared with var differ from globals declared with let in an important way. Globals declared with var are implemented as properties of the global object (§3.7). The global object can be referenced as globalThis. So if you write var x = 2; outside of a function, it is like you wrote globalThis.x = 2;. Note however, that the analogy is not perfect: the properties created with global var declarations cannot be deleted with the delete operator (§4.13.4). Global variables and constants declared with let and const are not properties of the global object.</li> <li>Unlike variables declared with let, it is legal to declare the same variable multiple times with var. And because var variables have function scope instead of block scope, it is actually common to do this kind of redeclaration. The variable i is frequently used for integer values, and especially as the index variable of for loops. In a function with multiple for loops, it is typical for each one to begin for(var i = 0; .... Because var does not scope these variables to the loop body, each of these loops is (harmlessly) re-declaring and re-initializing the same variable.</li> <li>One of the most unusual features of var declarations is known as hoisting. When a variable is declared with var, the declaration is lifted up (or “hoisted”) to the top of the enclosing function. The initialization of the variable remains where you wrote it, but the definition of the variable moves to the top of the function. So variables declared with var can be used, without error, anywhere in the enclosing function. If the initialization code has not run yet, then the value of the variable may be undefined, but you won’t get an error if you use the variable before it is initialized. (This can be a source of bugs and is one of the important misfeatures that let corrects: if you declare a variable with let but attempt to use it before the let statement runs, you will get an actual error instead of just seeing an undefined value.)</li></ul> <p>USING UNDECLARED VARIABLES
In strict mode (§5.6.3), if you attempt to use an undeclared variable, you’ll get a reference error when you run your code. Outside of strict mode, however, if you assign a value to a name that has not been declared with let, const, or var, you’ll end up creating a new global variable. It will be a global no matter now deeply nested within functions and blocks your code is, which is almost certainly not what you want, is bug-prone, and is one of the best reasons for using strict mode!</p> <p>Global variables created in this accidental way are like global variables declared with var: they define properties of the global object. But unlike the properties defined by proper var declarations, these properties can be deleted with the delete operator (§4.13.4).</p> <h3 id="_3-10-3-destructuring-assignment"><a href="#_3-10-3-destructuring-assignment" class="header-anchor">#</a> 3.10.3 Destructuring Assignment</h3> <p>ES6 implements a kind of compound declaration and assignment syntax known as destructuring assignment. In a destructuring assignment, the value on the righthand side of the equals sign is an array or object (a “structured” value), and the lefthand side specifies one or more variable names using a syntax that mimics array and object literal syntax. When a destructuring assignment occurs, one or more values are extracted (“destructured”) from the value on the right and stored into the variables named on the left. Destructuring assignment is perhaps most commonly used to initialize variables as part of a const, let, or var declaration statement, but it can also be done in regular assignment expressions (with variables that have already been declared). And, as we’ll see in §8.3.5, destructuring can also be used when defining the parameters to a function.</p> <p>Here are simple destructuring assignments using arrays of values:</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> <span class="token punctuation">[</span>x<span class="token punctuation">,</span>y<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">// Same as let x=1, y=2</span>
<span class="token punctuation">[</span>x<span class="token punctuation">,</span>y<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span>x<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>y<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">// Same as x = x + 1, y = y + 1</span>
<span class="token punctuation">[</span>x<span class="token punctuation">,</span>y<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span>y<span class="token punctuation">,</span>x<span class="token punctuation">]</span><span class="token punctuation">;</span>      <span class="token comment">// Swap the value of the two variables</span>
<span class="token punctuation">[</span>x<span class="token punctuation">,</span>y<span class="token punctuation">]</span>               <span class="token comment">// =&gt; [3,2]: the incremented and swapped values</span>
</code></pre></div><p>Notice how destructuring assignment makes it easy to work with functions that return arrays of values:</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// Convert [x,y] coordinates to [r,theta] polar coordinates</span>
<span class="token keyword">function</span> <span class="token function">toPolar</span><span class="token punctuation">(</span><span class="token parameter">x<span class="token punctuation">,</span> y</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token punctuation">[</span>Math<span class="token punctuation">.</span><span class="token function">sqrt</span><span class="token punctuation">(</span>x<span class="token operator">*</span>x<span class="token operator">+</span>y<span class="token operator">*</span>y<span class="token punctuation">)</span><span class="token punctuation">,</span> Math<span class="token punctuation">.</span><span class="token function">atan2</span><span class="token punctuation">(</span>y<span class="token punctuation">,</span>x<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// Convert polar to Cartesian coordinates</span>
<span class="token keyword">function</span> <span class="token function">toCartesian</span><span class="token punctuation">(</span><span class="token parameter">r<span class="token punctuation">,</span> theta</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token punctuation">[</span>r<span class="token operator">*</span>Math<span class="token punctuation">.</span><span class="token function">cos</span><span class="token punctuation">(</span>theta<span class="token punctuation">)</span><span class="token punctuation">,</span> r<span class="token operator">*</span>Math<span class="token punctuation">.</span><span class="token function">sin</span><span class="token punctuation">(</span>theta<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">let</span> <span class="token punctuation">[</span>r<span class="token punctuation">,</span>theta<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">toPolar</span><span class="token punctuation">(</span><span class="token number">1.0</span><span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// r == Math.sqrt(2); theta == Math.PI/4</span>
<span class="token keyword">let</span> <span class="token punctuation">[</span>x<span class="token punctuation">,</span>y<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">toCartesian</span><span class="token punctuation">(</span>r<span class="token punctuation">,</span>theta<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// [x, y] == [1.0, 1,0]</span>
</code></pre></div><p>We saw that variables and constants can be declared as part of JavaScript’s various for loops. It is possible to use variable destructuring in this context as well. Here is a code that loops over the name/value pairs of all properties of an object and uses destructuring assignment to convert those pairs from two-element arrays into individual variables:</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> o <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token literal-property property">x</span><span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token literal-property property">y</span><span class="token operator">:</span> <span class="token number">2</span> <span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">// The object we'll loop over</span>
<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token punctuation">[</span>name<span class="token punctuation">,</span> value<span class="token punctuation">]</span> <span class="token keyword">of</span> Object<span class="token punctuation">.</span><span class="token function">entries</span><span class="token punctuation">(</span>o<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Prints &quot;x 1&quot; and &quot;y 2&quot;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>The number of variables on the left of a destructuring assignment does not have to match the number of array elements on the right. Extra variables on the left are set to undefined, and extra values on the right are ignored. The list of variables on the left can include extra commas to skip certain values on the right:</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> <span class="token punctuation">[</span>x<span class="token punctuation">,</span>y<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>     <span class="token comment">// x == 1; y == undefined</span>
<span class="token punctuation">[</span>x<span class="token punctuation">,</span>y<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>     <span class="token comment">// x == 1; y == 2</span>
<span class="token punctuation">[</span><span class="token punctuation">,</span>x<span class="token punctuation">,</span><span class="token punctuation">,</span>y<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// x == 2; y == 4</span>
</code></pre></div><p>If you want to collect all unused or remaining values into a single variable when destructuring an array, use three dots (...) before the last variable name on the left-hand side:</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> <span class="token punctuation">[</span>x<span class="token punctuation">,</span> <span class="token operator">...</span>y<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">// y == [2,3,4]</span>
</code></pre></div><p>We’ll see three dots used this way again in §8.3.2, where they are used to indicate that all remaining function arguments should be collected into a single array.</p> <p>Destructuring assignment can be used with nested arrays. In this case, the lefthand side of the assignment should look like a nested array literal:</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> <span class="token punctuation">[</span>a<span class="token punctuation">,</span> <span class="token punctuation">[</span>b<span class="token punctuation">,</span> c<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">2.5</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// a == 1; b == 2; c == 2.5</span>
</code></pre></div><p>A powerful feature of array destructuring is that it does not actually require an array! You can use any iterable object (Chapter 12) on the righthand side of the assignment; any object that can be used with a for/of loop (§5.4.4) can also be destructured:</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> <span class="token punctuation">[</span>first<span class="token punctuation">,</span> <span class="token operator">...</span>rest<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">&quot;Hello&quot;</span><span class="token punctuation">;</span> <span class="token comment">// first == &quot;H&quot;; rest == [&quot;e&quot;,&quot;l&quot;,&quot;l&quot;,&quot;o&quot;]</span>
</code></pre></div><p>Destructuring assignment can also be performed when the righthand side is an object value. In this case, the lefthand side of the assignment looks something like an object literal: a comma-separated list of variable names within curly braces:</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> transparent <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token literal-property property">r</span><span class="token operator">:</span> <span class="token number">0.0</span><span class="token punctuation">,</span> <span class="token literal-property property">g</span><span class="token operator">:</span> <span class="token number">0.0</span><span class="token punctuation">,</span> <span class="token literal-property property">b</span><span class="token operator">:</span> <span class="token number">0.0</span><span class="token punctuation">,</span> <span class="token literal-property property">a</span><span class="token operator">:</span> <span class="token number">1.0</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">// A RGBA color</span>
<span class="token keyword">let</span> <span class="token punctuation">{</span>r<span class="token punctuation">,</span> g<span class="token punctuation">,</span> b<span class="token punctuation">}</span> <span class="token operator">=</span> transparent<span class="token punctuation">;</span>  <span class="token comment">// r == 0.0; g == 0.0; b == 0.0</span>
</code></pre></div><p>The next example copies global functions of the Math object into variables, which might simplify code that does a lot of trigonometry:</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// Same as const sin=Math.sin, cos=Math.cos, tan=Math.tan</span>
<span class="token keyword">const</span> <span class="token punctuation">{</span>sin<span class="token punctuation">,</span> cos<span class="token punctuation">,</span> tan<span class="token punctuation">}</span> <span class="token operator">=</span> Math<span class="token punctuation">;</span>
</code></pre></div><p>Notice in the code here that the Math object has many properties other than the three that are destructured into individual variables. Those that are not named are simply ignored. If the lefthand side of this assignment had included a variable whose name was not a property of Math, that variable would simply be assigned undefined.</p> <p>In each of these object destructuring examples, we have chosen variable names that match the property names of the object we’re destructuring. This keeps the syntax simple and easy to understand, but it is not required. Each of the identifiers on the lefthand side of an object destructuring assignment can also be a colon-separated pair of identifiers, where the first is the name of the property whose value is to be assigned and the second is the name of the variable to assign it to:</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// Same as const cosine = Math.cos, tangent = Math.tan;</span>
<span class="token keyword">const</span> <span class="token punctuation">{</span> <span class="token literal-property property">cos</span><span class="token operator">:</span> cosine<span class="token punctuation">,</span> <span class="token literal-property property">tan</span><span class="token operator">:</span> tangent <span class="token punctuation">}</span> <span class="token operator">=</span> Math<span class="token punctuation">;</span>
</code></pre></div><p>I find that object destructuring syntax becomes too complicated to be useful when the variable names and property names are not the same, and I tend to avoid the shorthand in this case. If you choose to use it, remember that property names are always on the left of the colon, in both object literals and on the left of an object destructuring assignment.</p> <p>Destructuring assignment becomes even more complicated when it is used with nested objects, or arrays of objects, or objects of arrays, but it is legal:</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> points <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">{</span><span class="token literal-property property">x</span><span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token literal-property property">y</span><span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token literal-property property">x</span><span class="token operator">:</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token literal-property property">y</span><span class="token operator">:</span> <span class="token number">4</span><span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token punctuation">;</span>     <span class="token comment">// An array of two point objects</span>
<span class="token keyword">let</span> <span class="token punctuation">[</span><span class="token punctuation">{</span><span class="token literal-property property">x</span><span class="token operator">:</span> x1<span class="token punctuation">,</span> <span class="token literal-property property">y</span><span class="token operator">:</span> y1<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token literal-property property">x</span><span class="token operator">:</span> x2<span class="token punctuation">,</span> <span class="token literal-property property">y</span><span class="token operator">:</span> y2<span class="token punctuation">}</span><span class="token punctuation">]</span> <span class="token operator">=</span> points<span class="token punctuation">;</span> <span class="token comment">// destructured into 4 variables.</span>
<span class="token punctuation">(</span>x1 <span class="token operator">===</span> <span class="token number">1</span> <span class="token operator">&amp;&amp;</span> y1 <span class="token operator">===</span> <span class="token number">2</span> <span class="token operator">&amp;&amp;</span> x2 <span class="token operator">===</span> <span class="token number">3</span> <span class="token operator">&amp;&amp;</span> y2 <span class="token operator">===</span> <span class="token number">4</span><span class="token punctuation">)</span> <span class="token comment">// =&gt; true</span>
</code></pre></div><p>Or, instead of destructuring an array of objects, we could destructure an object of arrays:</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> points <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token literal-property property">p1</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token literal-property property">p2</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>         <span class="token comment">// An object with 2 array props</span>
<span class="token keyword">let</span> <span class="token punctuation">{</span> <span class="token literal-property property">p1</span><span class="token operator">:</span> <span class="token punctuation">[</span>x1<span class="token punctuation">,</span> y1<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token literal-property property">p2</span><span class="token operator">:</span> <span class="token punctuation">[</span>x2<span class="token punctuation">,</span> y2<span class="token punctuation">]</span> <span class="token punctuation">}</span> <span class="token operator">=</span> points<span class="token punctuation">;</span>   <span class="token comment">// destructured into 4 vars</span>
<span class="token punctuation">(</span>x1 <span class="token operator">===</span> <span class="token number">1</span> <span class="token operator">&amp;&amp;</span> y1 <span class="token operator">===</span> <span class="token number">2</span> <span class="token operator">&amp;&amp;</span> x2 <span class="token operator">===</span> <span class="token number">3</span> <span class="token operator">&amp;&amp;</span> y2 <span class="token operator">===</span> <span class="token number">4</span><span class="token punctuation">)</span> <span class="token comment">// =&gt; true</span>
</code></pre></div><p>Complex destructuring syntax like this can be hard to write and hard to read, and you may be better off just writing out your assignments explicitly with traditional code like let x1 = points.p1[0];.</p> <p>UNDERSTANDING COMPLEX DESTRUCTURING
If you find yourself working with code that uses complex destructuring assignments, there is a useful regularity that can help you make sense of the complex cases. Think first about a regular (single-value) assignment. After the assignment is done, you can take the variable name from the lefthand side of the assignment and use it as an expression in your code, where it will evaluate to whatever value you assigned it. The same thing is true for destructuring assignment. The lefthand side of a destructuring assignment looks like an array literal or an object literal (§6.2.1 and §6.10). After the assignment has been done, the lefthand side will actually work as a valid array literal or object literal elsewhere in your code. You can check that you’ve written a destructuring assignment correctly by trying to use the lefthand side on the righthand side of another assignment expression:</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// Start with a data structure and a complex destructuring</span>
<span class="token keyword">let</span> points <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">{</span><span class="token literal-property property">x</span><span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token literal-property property">y</span><span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token literal-property property">x</span><span class="token operator">:</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token literal-property property">y</span><span class="token operator">:</span> <span class="token number">4</span><span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> <span class="token punctuation">[</span><span class="token punctuation">{</span><span class="token literal-property property">x</span><span class="token operator">:</span> x1<span class="token punctuation">,</span> <span class="token literal-property property">y</span><span class="token operator">:</span> y1<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token literal-property property">x</span><span class="token operator">:</span> x2<span class="token punctuation">,</span> <span class="token literal-property property">y</span><span class="token operator">:</span> y2<span class="token punctuation">}</span><span class="token punctuation">]</span> <span class="token operator">=</span> points<span class="token punctuation">;</span>

<span class="token comment">// Check your destructuring syntax by flipping the assignment around</span>
<span class="token keyword">let</span> points2 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">{</span><span class="token literal-property property">x</span><span class="token operator">:</span> x1<span class="token punctuation">,</span> <span class="token literal-property property">y</span><span class="token operator">:</span> y1<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token literal-property property">x</span><span class="token operator">:</span> x2<span class="token punctuation">,</span> <span class="token literal-property property">y</span><span class="token operator">:</span> y2<span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// points2 == points</span>
</code></pre></div><h2 id="_3-11-summary"><a href="#_3-11-summary" class="header-anchor">#</a> 3.11 Summary</h2> <p>Some key points to remember about this chapter:</p> <ul><li>How to write and manipulate numbers and strings of text in JavaScript.</li> <li>How to work with JavaScript’s other primitive types: booleans, Symbols, null, and undefined.</li> <li>The differences between immutable primitive types and mutable reference types.</li> <li>How JavaScript converts values implicitly from one type to another and how you can do so explicitly in your programs.</li> <li>How to declare and initialize constants and variables (including with destructuring assignment) and the lexical scope of the variables and constants you declare.</li></ul> <hr> <ol><li>This is the format for numbers of type double in Java, C++, and most modern programming languages.</li> <li>There are JavaScript extensions, such as TypeScript and Flow (§17.8), that allow types to be specified as part of variable declarations with syntax like let x: number = 0;.</li></ol></div> <footer class="page-edit"><div class="edit-link"><a href="https://github.com/rexhang/rexhang.github.io/ebook/doc-jstdg7/edit/master/ch3.md" target="_blank" rel="noopener noreferrer">帮助我们改善此页面！</a> <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></div> <div class="last-updated"><span class="prefix">最后更新于:</span> <span class="time">2/22/2025, 9:58:16 PM</span></div></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/ebook/doc-jstdg7/ch2.html" class="prev">
        Chapter 2. Lexical Structure
      </a></span> <span class="next"><a href="/ebook/doc-jstdg7/ch4.html">
        Chapter 4. Expressions and Operators
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/ebook/doc-jstdg7/assets/js/app.c9a3fcc3.js" defer></script><script src="/ebook/doc-jstdg7/assets/js/2.d222cfdb.js" defer></script><script src="/ebook/doc-jstdg7/assets/js/1.7462a745.js" defer></script><script src="/ebook/doc-jstdg7/assets/js/34.6342948c.js" defer></script>
  </body>
</html>
