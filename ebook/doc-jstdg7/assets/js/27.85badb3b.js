(window.webpackJsonp=window.webpackJsonp||[]).push([[27],{342:function(e,t,a){"use strict";a.r(t);var r=a(25),n=Object(r.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h1",{attrs:{id:"chapter-12-iterators-and-generators"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#chapter-12-iterators-and-generators"}},[e._v("#")]),e._v(" Chapter 12. Iterators and Generators")]),e._v(" "),a("p",[e._v("Iterable objects and their associated iterators are a feature of ES6 that we‚Äôve seen several times throughout this book. Arrays (including TypedArrays) are iterable, as are strings and Set and Map objects. This means that the contents of these data structures can be iterated‚Äîlooped over‚Äîwith the for/of loop, as we saw in ¬ß5.4.4:")]),e._v(" "),a("p",[e._v("let sum = 0;\nfor(let i of [1,2,3]) { // Loop once for each of these values\nsum += i;\n}\nsum   // => 6\nIterators can also be used with the ... operator to expand or ‚Äúspread‚Äù an iterable object into an array initializer or function invocation, as we saw in ¬ß7.1.2:")]),e._v(" "),a("p",[e._v('let chars = [..."abcd"]; // chars == ["a", "b", "c", "d"]\nlet data = [1, 2, 3, 4, 5];\nMath.max(...data)        // => 5\nIterators can be used with destructuring assignment:')]),e._v(" "),a("p",[e._v("let purpleHaze = Uint8Array.of(255, 0, 255, 128);\nlet [r, g, b, a] = purpleHaze; // a == 128\nWhen you iterate a Map object, the returned values are [key, value] pairs, which work well with destructuring assignment in a for/of loop:")]),e._v(" "),a("p",[e._v("let m = new Map([[\"one\", 1], [\"two\", 2]]);\nfor(let [k,v] of m) console.log(k, v); // Logs 'one 1' and 'two 2'\nIf you want to iterate just the keys or just the values rather than the pairs, you can use the keys() and values() methods:")]),e._v(" "),a("p",[e._v('[...m]            // => [["one", 1], ["two", 2]]: default iteration\n[...m.entries()]  // => [["one", 1], ["two", 2]]: entries() method is the same\n[...m.keys()]     // => ["one", "two"]: keys() method iterates just map keys\n[...m.values()]   // => [1, 2]: values() method iterates just map values\nFinally, a number of built-in functions and constructors that are commonly used with Array objects are actually written (in ES6 and later) to accept arbitrary iterators instead. The Set() constructor is one such API:')]),e._v(" "),a("p",[e._v('// Strings are iterable, so the two sets are the same:\nnew Set("abc") // => new Set(["a", "b", "c"])\nThis chapter explains how iterators work and demonstrates how to create your own data structures that are iterable. After explaining basic iterators, this chapter covers generators, a powerful new feature of ES6 that is primarily used as a particularly easy way to create iterators.')]),e._v(" "),a("h2",{attrs:{id:"_12-1-how-iterators-work"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_12-1-how-iterators-work"}},[e._v("#")]),e._v(" 12.1 How Iterators Work")]),e._v(" "),a("p",[e._v("The for/of loop and spread operator work seamlessly with iterable objects, but it is worth understanding what is actually happening to make the iteration work. There are three separate types that you need to understand to understand iteration in JavaScript. First, there are the iterable objects: these are types like Array, Set, and Map that can be iterated. Second, there is the iterator object itself, which performs the iteration. And third, there is the iteration result object that holds the result of each step of the iteration.")]),e._v(" "),a("p",[e._v("An iterable object is any object with a special iterator method that returns an iterator object. An iterator is any object with a next() method that returns an iteration result object. And an iteration result object is an object with properties named value and done. To iterate an iterable object, you first call its iterator method to get an iterator object. Then, you call the next() method of the iterator object repeatedly until the returned value has its done property set to true. The tricky thing about this is that the iterator method of an iterable object does not have a conventional name but uses the Symbol Symbol.iterator as its name. So a simple for/of loop over an iterable object iterable could also be written the hard way, like this:")]),e._v(" "),a("p",[e._v("let iterable = [99];\nlet iterator = iterable"),a("a",{attrs:{href:""}},[e._v("Symbol.iterator")]),e._v(";\nfor(let result = iterator.next(); !result.done; result = iterator.next()) {\nconsole.log(result.value)  // result.value == 99\n}\nThe iterator object of the built-in iterable datatypes is itself iterable. (That is, it has a method named Symbol.iterator that just returns itself.) This is occasionally useful in code like the following when you want to iterate though a ‚Äúpartially used‚Äù iterator:")]),e._v(" "),a("p",[e._v("let list = [1,2,3,4,5];\nlet iter = list"),a("a",{attrs:{href:""}},[e._v("Symbol.iterator")]),e._v(";\nlet head = iter.next().value;  // head == 1\nlet tail = [...iter];          // tail == [2,3,4,5]")]),e._v(" "),a("h2",{attrs:{id:"_12-2-implementing-iterable-objects"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_12-2-implementing-iterable-objects"}},[e._v("#")]),e._v(" 12.2 Implementing Iterable Objects")]),e._v(" "),a("p",[e._v("Iterable objects are so useful in ES6 that you should consider making your own datatypes iterable whenever they represent something that can be iterated. The Range classes shown in Examples 9-2 and 9-3 in Chapter 9 were iterable. Those classes used generator functions to make themselves iterable. We‚Äôll document generators later in this chapter, but first, we will implement the Range class one more time, making it iterable without relying on a generator.")]),e._v(" "),a("p",[e._v("In order to make a class iterable, you must implement a method whose name is the Symbol Symbol.iterator. That method must return an iterator object that has a next() method. And the next() method must return an iteration result object that has a value property and/or a boolean done property. Example 12-1 implements an iterable Range class and demonstrates how to create iterable, iterator, and iteration result objects.")]),e._v(" "),a("p",[e._v("Example 12-1. An iterable numeric Range class\n/*")]),e._v(" "),a("ul",[a("li",[a("p",[e._v("A Range object represents a range of numbers {x: from <= x <= to}")])]),e._v(" "),a("li",[a("p",[e._v("Range defines a has() method for testing whether a given number is a member")])]),e._v(" "),a("li",[a("p",[e._v("of the range. Range is iterable and iterates all integers within the range.\n*/\nclass Range {\nconstructor (from, to) {\nthis.from = from;\nthis.to = to;\n}")]),e._v(" "),a("p",[e._v('// Make a Range act like a Set of numbers\nhas(x) { return typeof x === "number" && this.from <= x && x <= this.to; }')]),e._v(" "),a("p",[e._v("// Return string representation of the range using set notation\ntoString() { return "),a("code",[e._v("{ x | ${this.from} ‚â§ x ‚â§ ${this.to} }")]),e._v("; }")]),e._v(" "),a("p",[e._v("// Make a Range iterable by returning an iterator object.\n// Note that the name of this method is a special symbol, not a string.\n"),a("a",{attrs:{href:""}},[e._v("Symbol.iterator")]),e._v(" {\n// Each iterator instance must iterate the range independently of\n// others. So we need a state variable to track our location in the\n// iteration. We start at the first integer >= from.\nlet next = Math.ceil(this.from);  // This is the next value we return\nlet last = this.to;               // We won't return anything > this\nreturn {                          // This is the iterator object\n// This next() method is what makes this an iterator object.\n// It must return an iterator result object.\nnext() {\nreturn (next <= last)   // If we haven't returned last value yet\n? { value: next++ } // return next value and increment it\n: { done: true };   // otherwise indicate that we're done.\n},")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[e._v("     // As a convenience, we make the iterator itself iterable.\n     [Symbol.iterator]() { return this; }\n };\n")])])]),a("p",[e._v("}\n}")])])]),e._v(" "),a("p",[e._v("for(let x of new Range(1,10)) console.log(x); // Logs numbers 1 to 10\n[...new Range(-2,2)]                          // => [-2, -1, 0, 1, 2]\nIn addition to making your classes iterable, it can be quite useful to define functions that return iterable values. Consider these iterable-based alternatives to the map() and filter() methods of JavaScript arrays:")]),e._v(" "),a("p",[e._v("// Return an iterable object that iterates the result of applying f()\n// to each value from the source iterable\nfunction map(iterable, f) {\nlet iterator = iterable"),a("a",{attrs:{href:""}},[e._v("Symbol.iterator")]),e._v(";\nreturn {     // This object is both iterator and iterable\n"),a("a",{attrs:{href:""}},[e._v("Symbol.iterator")]),e._v(" { return this; },\nnext() {\nlet v = iterator.next();\nif (v.done) {\nreturn v;\n} else {\nreturn { value: f(v.value) };\n}\n}\n};\n}")]),e._v(" "),a("p",[e._v("// Map a range of integers to their squares and convert to an array\n[...map(new Range(1,4), x => x*x)]  // => [1, 4, 9, 16]")]),e._v(" "),a("p",[e._v("// Return an iterable object that filters the specified iterable,\n// iterating only those elements for which the predicate returns true\nfunction filter(iterable, predicate) {\nlet iterator = iterable"),a("a",{attrs:{href:""}},[e._v("Symbol.iterator")]),e._v(";\nreturn { // This object is both iterator and iterable\n"),a("a",{attrs:{href:""}},[e._v("Symbol.iterator")]),e._v(" { return this; },\nnext() {\nfor(;üòâ {\nlet v = iterator.next();\nif (v.done || predicate(v.value)) {\nreturn v;\n}\n}\n}\n};\n}")]),e._v(" "),a("p",[e._v("// Filter a range so we're left with only even numbers\n[...filter(new Range(1,10), x => x % 2 === 0)]  // => [2,4,6,8,10]\nOne key feature of iterable objects and iterators is that they are inherently lazy: when computation is required to compute the next value, that computation can be deferred until the value is actually needed. Suppose, for example, that you have a very long string of text that you want to tokenize into space-separated words. You could simply use the split() method of your string, but if you do this, then the entire string has to be processed before you can use even the first word. And you end up allocating lots of memory for the returned array and all of the strings within it. Here is a function that allows you to lazily iterate the words of a string without keeping them all in memory at once (in ES2020, this function would be much easier to implement using the iterator-returning matchAll() method described in ¬ß11.3.2):")]),e._v(" "),a("p",[e._v("function words(s) {\nvar r = /\\s+|$/g;                     // Match one or more spaces or end\nr.lastIndex = s.match(/[^ ]/).index;  // Start matching at first nonspace\nreturn {                              // Return an iterable iterator object\n"),a("a",{attrs:{href:""}},[e._v("Symbol.iterator")]),e._v(" {             // This makes us iterable\nreturn this;\n},\nnext() {                          // This makes us an iterator\nlet start = r.lastIndex;      // Resume where the last match ended\nif (start < s.length) {       // If we're not done\nlet match = r.exec(s);    // Match the next word boundary\nif (match) {              // If we found one, return the word\nreturn { value: s.substring(start, match.index) };\n}\n}\nreturn { done: true };        // Otherwise, say that we're done\n}\n};\n}")]),e._v(" "),a("p",[e._v('[...words(" abc def  ghi! ")] // => ["abc", "def", "ghi!"]')]),e._v(" "),a("h3",{attrs:{id:"_12-2-1-closing-an-iterator-the-return-method"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_12-2-1-closing-an-iterator-the-return-method"}},[e._v("#")]),e._v(" 12.2.1 ‚ÄúClosing‚Äù an Iterator: The Return Method")]),e._v(" "),a("p",[e._v("Imagine a (server-side) JavaScript variant of the words() iterator that, instead of taking a source string as its argument, takes the name of a file, opens the file, reads lines from it, and iterates the words from those lines. In most operating systems, programs that open files to read from them need to remember to close those files when they are done reading, so this hypothetical iterator would be sure to close the file after the next() method returns the last word in it.")]),e._v(" "),a("p",[e._v("But iterators don‚Äôt always run all the way to the end: a for/of loop might be terminated with a break or return or by an exception. Similarly, when an iterator is used with destructuring assignment, the next() method is only called enough times to obtain values for each of the specified variables. The iterator may have many more values it could return, but they will never be requested.")]),e._v(" "),a("p",[e._v("If our hypothetical words-in-a-file iterator never runs all the way to the end, it still needs to close the file it opened. For this reason, iterator objects may implement a return() method to go along with the next() method. If iteration stops before next() has returned an iteration result with the done property set to true (most commonly because you left a for/of loop early via a break statement), then the interpreter will check to see if the iterator object has a return() method. If this method exists, the interpreter will invoke it with no arguments, giving the iterator the chance to close files, release memory, and otherwise clean up after itself. The return() method must return an iterator result object. The properties of the object are ignored, but it is an error to return a non-object value.")]),e._v(" "),a("p",[e._v("The for/of loop and the spread operator are really useful features of JavaScript, so when you are creating APIs, it is a good idea to use them when possible. But having to work with an iterable object, its iterator object, and the iterator‚Äôs result objects makes the process somewhat complicated. Fortunately, generators can dramatically simplify the creation of custom iterators, as we‚Äôll see in the rest of this chapter.")]),e._v(" "),a("h2",{attrs:{id:"_12-3-generators"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_12-3-generators"}},[e._v("#")]),e._v(" 12.3 Generators")]),e._v(" "),a("p",[e._v("A generator is a kind of iterator defined with powerful new ES6 syntax; it‚Äôs particularly useful when the values to be iterated are not the elements of a data structure, but the result of a computation.")]),e._v(" "),a("p",[e._v("To create a generator, you must first define a generator function. A generator function is syntactically like a regular JavaScript function but is defined with the keyword function* rather than function. (Technically, this is not a new keyword, just a * after the keyword function and before the function name.) When you invoke a generator function, it does not actually execute the function body, but instead returns a generator object. This generator object is an iterator. Calling its next() method causes the body of the generator function to run from the start (or whatever its current position is) until it reaches a yield statement. yield is new in ES6 and is something like a return statement. The value of the yield statement becomes the value returned by the next() call on the iterator. An example makes this clearer:")]),e._v(" "),a("p",[e._v("// A generator function that yields the set of one digit (base-10) primes.\nfunction* oneDigitPrimes() { // Invoking this function does not run the code\nyield 2;                 // but just returns a generator object. Calling\nyield 3;                 // the next() method of that generator runs\nyield 5;                 // the code until a yield statement provides\nyield 7;                 // the return value for the next() method.\n}")]),e._v(" "),a("p",[e._v("// When we invoke the generator function, we get a generator\nlet primes = oneDigitPrimes();")]),e._v(" "),a("p",[e._v("// A generator is an iterator object that iterates the yielded values\nprimes.next().value          // => 2\nprimes.next().value          // => 3\nprimes.next().value          // => 5\nprimes.next().value          // => 7\nprimes.next().done           // => true")]),e._v(" "),a("p",[e._v("// Generators have a Symbol.iterator method to make them iterable\nprimes"),a("a",{attrs:{href:""}},[e._v("Symbol.iterator")]),e._v("    // => primes")]),e._v(" "),a("p",[e._v("// We can use generators like other iterable types\n[...oneDigitPrimes()]        // => [2,3,5,7]\nlet sum = 0;\nfor(let prime of oneDigitPrimes()) sum += prime;\nsum                          // => 17\nIn this example, we used a function* statement to define a generator. Like regular functions, however, we can also define generators in expression form. Once again, we just put an asterisk after the function keyword:")]),e._v(" "),a("p",[e._v("const seq = function*(from,to) {\nfor(let i = from; i <= to; i++) yield i;\n};\n[...seq(3,5)]  // => [3, 4, 5]\nIn classes and object literals, we can use shorthand notation to omit the function keyword entirely when we define methods. To define a generator in this context, we simply use an asterisk before the method name where the function keyword would have been, had we used it:")]),e._v(" "),a("p",[e._v('let o = {\nx: 1, y: 2, z: 3,\n// A generator that yields each of the keys of this object\n*g() {\nfor(let key of Object.keys(this)) {\nyield key;\n}\n}\n};\n[...o.g()] // => ["x", "y", "z", "g"]\nNote that there is no way to write a generator function using arrow function syntax.')]),e._v(" "),a("p",[e._v("Generators often make it particularly easy to define iterable classes. We can replace the "),a("a",{attrs:{href:""}},[e._v("Symbol.iterator")]),e._v(" method show in Example 12-1 with a much shorter *[Symbol.iterator]() generator function that looks like this:")]),e._v(" "),a("p",[e._v("*"),a("a",{attrs:{href:""}},[e._v("Symbol.iterator")]),e._v(" {\nfor(let x = Math.ceil(this.from); x <= this.to; x++) yield x;\n}\nSee Example 9-3 in Chapter 9 to see this generator-based iterator function in context.")]),e._v(" "),a("h3",{attrs:{id:"_12-3-1-generator-examples"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_12-3-1-generator-examples"}},[e._v("#")]),e._v(" 12.3.1 Generator Examples")]),e._v(" "),a("p",[e._v("Generators are more interesting if they actually generate the values they yield by doing some kind of computation. Here, for example, is a generator function that yields Fibonacci numbers:")]),e._v(" "),a("p",[e._v("function* fibonacciSequence() {\nlet x = 0, y = 1;\nfor(;üòâ {\nyield y;\n[x, y] = [y, x+y];  // Note: destructuring assignment\n}\n}\nNote that the fibonacciSequence() generator function here has an infinite loop and yields values forever without returning. If this generator is used with the ... spread operator, it will loop until memory is exhausted and the program crashes. With care, it is possible to use it in a for/of loop, however:")]),e._v(" "),a("p",[e._v("// Return the nth Fibonacci number\nfunction fibonacci(n) {\nfor(let f of fibonacciSequence()) {\nif (n-- <= 0) return f;\n}\n}\nfibonacci(20)   // => 10946\nThis kind of infinite generator becomes more useful with a take() generator like this:")]),e._v(" "),a("p",[e._v("// Yield the first n elements of the specified iterable object\nfunction* take(n, iterable) {\nlet it = iterable"),a("a",{attrs:{href:""}},[e._v("Symbol.iterator")]),e._v("; // Get iterator for iterable object\nwhile(n-- > 0) {           // Loop n times:\nlet next = it.next();  // Get the next item from the iterator.\nif (next.done) return; // If there are no more values, return early\nelse yield next.value; // otherwise, yield the value\n}\n}")]),e._v(" "),a("p",[e._v("// An array of the first 5 Fibonacci numbers\n[...take(5, fibonacciSequence())]  // => [1, 1, 2, 3, 5]\nHere is another useful generator function that interleaves the elements of multiple iterable objects:")]),e._v(" "),a("p",[e._v("// Given an array of iterables, yield their elements in interleaved order.\nfunction* zip(...iterables) {\n// Get an iterator for each iterable\nlet iterators = iterables.map(i => i"),a("a",{attrs:{href:""}},[e._v("Symbol.iterator")]),e._v(");\nlet index = 0;\nwhile(iterators.length > 0) {       // While there are still some iterators\nif (index >= iterators.length) {    // If we reached the last iterator\nindex = 0;                      // go back to the first one.\n}\nlet item = iterators[index].next(); // Get next item from next iterator.\nif (item.done) {                    // If that iterator is done\niterators.splice(index, 1);     // then remove it from the array.\n}\nelse {                              // Otherwise,\nyield item.value;               // yield the iterated value\nindex++;                        // and move on to the next iterator.\n}\n}\n}")]),e._v(" "),a("p",[e._v('// Interleave three iterable objects\n[...zip(oneDigitPrimes(),"ab",[0])]     // => [2,"a",0,3,"b",5,7]')]),e._v(" "),a("h3",{attrs:{id:"_12-3-2-yield-and-recursive-generators"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_12-3-2-yield-and-recursive-generators"}},[e._v("#")]),e._v(" 12.3.2 yield* and Recursive Generators")]),e._v(" "),a("p",[e._v("In addition to the zip() generator defined in the preceding example, it might be useful to have a similar generator function that yields the elements of multiple iterable objects sequentially rather than interleaving them. We could write that generator like this:")]),e._v(" "),a("p",[e._v("function* sequence(...iterables) {\nfor(let iterable of iterables) {\nfor(let item of iterable) {\nyield item;\n}\n}\n}")]),e._v(" "),a("p",[e._v('[...sequence("abc",oneDigitPrimes())]  // => ["a","b","c",2,3,5,7]\nThis process of yielding the elements of some other iterable object is common enough in generator functions that ES6 has special syntax for it. The yield* keyword is like yield except that, rather than yielding a single value, it iterates an iterable object and yields each of the resulting values. The sequence() generator function that we‚Äôve used can be simplified with yield* like this:')]),e._v(" "),a("p",[e._v("function* sequence(...iterables) {\nfor(let iterable of iterables) {\nyield* iterable;\n}\n}")]),e._v(" "),a("p",[e._v('[...sequence("abc",oneDigitPrimes())]  // => ["a","b","c",2,3,5,7]\nThe array forEach() method is often an elegant way to loop over the elements of an array, so you might be tempted to write the sequence() function like this:')]),e._v(" "),a("p",[e._v("function* sequence(...iterables) {\niterables.forEach(iterable => yield* iterable );  // Error\n}\nThis does not work, however. yield and yield* can only be used within generator functions, but the nested arrow function in this code is a regular function, not a function* generator function, so yield is not allowed.")]),e._v(" "),a("p",[e._v("yield* can be used with any kind of iterable object, including iterables implemented with generators. This means that yield* allows us to define recursive generators, and you might use this feature to allow simple non-recursive iteration over a recursively defined tree structure, for example.")]),e._v(" "),a("h2",{attrs:{id:"_12-4-advanced-generator-features"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_12-4-advanced-generator-features"}},[e._v("#")]),e._v(" 12.4 Advanced Generator Features")]),e._v(" "),a("p",[e._v("The most common use of generator functions is to create iterators, but the fundamental feature of generators is that they allow us to pause a computation, yield intermediate results, and then resume the computation later. This means that generators have features beyond those of iterators, and we explore those features in the following sections.")]),e._v(" "),a("h3",{attrs:{id:"_12-4-1-the-return-value-of-a-generator-function"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_12-4-1-the-return-value-of-a-generator-function"}},[e._v("#")]),e._v(" 12.4.1 The Return Value of a Generator Function")]),e._v(" "),a("p",[e._v("The generator functions we‚Äôve seen so far have not had return statements, or if they have, they have been used to cause an early return, not to return a value. Like any function, though, a generator function can return a value. In order to understand what happens in this case, recall how iteration works. The return value of the next() function is an object that has a value property and/or a done property. With typical iterators and generators, if the value property is defined, then the done property is undefined or is false. And if done is true, then value is undefined. But in the case of a generator that returns a value, the final call to next returns an object that has both value and done defined. The value property holds the return value of the generator function, and the done property is true, indicating that there are no more values to iterate. This final value is ignored by the for/of loop and by the spread operator, but it is available to code that manually iterates with explicit calls to next():")]),e._v(" "),a("p",[e._v('function *oneAndDone() {\nyield 1;\nreturn "done";\n}')]),e._v(" "),a("p",[e._v("// The return value does not appear in normal iteration.\n[...oneAndDone()]   // => [1]")]),e._v(" "),a("p",[e._v('// But it is available if you explicitly call next()\nlet generator = oneAndDone();\ngenerator.next()           // => { value: 1, done: false}\ngenerator.next()           // => { value: "done", done: true }\n// If the generator is already done, the return value is not returned again\ngenerator.next()           // => { value: undefined, done: true }')]),e._v(" "),a("h3",{attrs:{id:"_12-4-2-the-value-of-a-yield-expression"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_12-4-2-the-value-of-a-yield-expression"}},[e._v("#")]),e._v(" 12.4.2 The Value of a yield Expression")]),e._v(" "),a("p",[e._v("In the preceding discussion, we‚Äôve treated yield as a statement that takes a value but has no value of its own. In fact, however, yield is an expression, and it can have a value.")]),e._v(" "),a("p",[e._v("When the next() method of a generator is invoked, the generator function runs until it reaches a yield expression. The expression that follows the yield keyword is evaluated, and that value becomes the return value of the next() invocation. At this point, the generator function stops executing right in the middle of evaluating the yield expression. The next time the next() method of the generator is called, the argument passed to next() becomes the value of the yield expression that was paused. So the generator returns values to its caller with yield, and the caller passes values in to the generator with next(). The generator and caller are two separate streams of execution passing values (and control) back and forth. The following code illustrates:")]),e._v(" "),a("p",[e._v('function* smallNumbers() {\nconsole.log("next() invoked the first time; argument discarded");\nlet y1 = yield 1;    // y1 == "b"\nconsole.log("next() invoked a second time with argument", y1);\nlet y2 = yield 2;    // y2 == "c"\nconsole.log("next() invoked a third time with argument", y2);\nlet y3 = yield 3;    // y3 == "d"\nconsole.log("next() invoked a fourth time with argument", y3);\nreturn 4;\n}')]),e._v(" "),a("p",[e._v('let g = smallNumbers();\nconsole.log("generator created; no code runs yet");\nlet n1 = g.next("a");   // n1.value == 1\nconsole.log("generator yielded", n1.value);\nlet n2 = g.next("b");   // n2.value == 2\nconsole.log("generator yielded", n2.value);\nlet n3 = g.next("c");   // n3.value == 3\nconsole.log("generator yielded", n3.value);\nlet n4 = g.next("d");   // n4 == { value: 4, done: true }\nconsole.log("generator returned", n4.value);\nWhen this code runs, it produces the following output that demonstrates the back-and-forth between the two blocks of code:')]),e._v(" "),a("p",[e._v("generator created; no code runs yet\nnext() invoked the first time; argument discarded\ngenerator yielded 1\nnext() invoked a second time with argument b\ngenerator yielded 2\nnext() invoked a third time with argument c\ngenerator yielded 3\nnext() invoked a fourth time with argument d\ngenerator returned 4\nNote the asymmetry in this code. The first invocation of next() starts the generator, but the value passed to that invocation is not accessible to the generator.")]),e._v(" "),a("h3",{attrs:{id:"_12-4-3-the-return-and-throw-methods-of-a-generator"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_12-4-3-the-return-and-throw-methods-of-a-generator"}},[e._v("#")]),e._v(" 12.4.3 The return() and throw() Methods of a Generator")]),e._v(" "),a("p",[e._v("We‚Äôve seen that you can receive values yielded by or returned by a generator function. And you can pass values to a running generator by passing those values when you call the next() method of the generator.")]),e._v(" "),a("p",[e._v("In addition to providing input to a generator with next(), you can also alter the flow of control inside the generator by calling its return() and throw() methods. As the names suggest, calling these methods on a generator causes it to return a value or throw an exception as if the next statement in the generator was a return or throw.")]),e._v(" "),a("p",[e._v("Recall from earlier in the chapter that, if an iterator defines a return() method and iteration stops early, then the interpreter automatically calls the return() method to give the iterator a chance to close files or do other cleanup. In the case of generators, you can‚Äôt define a custom return() method to handle cleanup, but you can structure the generator code to use a try/finally statement that ensures the necessary cleanup is done (in the finally block) when the generator returns. By forcing the generator to return, the generator‚Äôs built-in return() method ensures that the cleanup code is run when the generator will no longer be used.")]),e._v(" "),a("p",[e._v("Just as the next() method of a generator allows us to pass arbitrary values into a running generator, the throw() method of a generator gives us a way to send arbitrary signals (in the form of exceptions) into a generator. Calling the throw() method always causes an exception inside the generator. But if the generator function is written with appropriate exception-handling code, the exception need not be fatal but can instead be a means of altering the behavior of the generator. Imagine, for example, a counter generator that yields an ever-increasing sequence of integers. This could be written so that an exception sent with throw() would reset the counter to zero.")]),e._v(" "),a("p",[e._v("When a generator uses yield* to yield values from some other iterable object, then a call to the next() method of the generator causes a call to the next() method of the iterable object. The same is true of the return() and throw() methods. If a generator uses yield* on an iterable object that has these methods defined, then calling return() or throw() on the generator causes the iterator‚Äôs return() or throw() method to be called in turn. All iterators must have a next() method. Iterators that need to clean up after incomplete iteration should define a return() method. And any iterator may define a throw() method, though I don‚Äôt know of any practical reason to do so.")]),e._v(" "),a("h3",{attrs:{id:"_12-4-4-a-final-note-about-generators"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_12-4-4-a-final-note-about-generators"}},[e._v("#")]),e._v(" 12.4.4 A Final Note About Generators")]),e._v(" "),a("p",[e._v("Generators are a very powerful generalized control structure. They give us the ability to pause a computation with yield and restart it again at some arbitrary later time with an arbitrary input value. It is possible to use generators to create a kind of cooperative threading system within single-threaded JavaScript code. And it is possible to use generators to mask asynchronous parts of your program so that your code appears sequential and synchronous, even though some of your function calls are actually asynchronous and depend on events from the network.")]),e._v(" "),a("p",[e._v("Trying to do these things with generators leads to code that is mind-bendingly hard to understand or to explain. It has been done, however, and the only really practical use case has been for managing asynchronous code. JavaScript now has async and await keywords (see Chapter 13) for this very purpose, however, and there is no longer any reason to abuse generators in this way.")]),e._v(" "),a("h2",{attrs:{id:"_12-5-summary"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_12-5-summary"}},[e._v("#")]),e._v(" 12.5 Summary")]),e._v(" "),a("p",[e._v("In this chapter, you have learned:")]),e._v(" "),a("p",[e._v("The for/of loop and the ... spread operator work with iterable objects.")]),e._v(" "),a("p",[e._v("An object is iterable if it has a method with the symbolic name [Symbol.iterator] that returns an iterator object.")]),e._v(" "),a("p",[e._v("An iterator object has a next() method that returns an iteration result object.")]),e._v(" "),a("p",[e._v("An iteration result object has a value property that holds the next iterated value, if there is one. If the iteration has completed, then the result object must have a done property set to true.")]),e._v(" "),a("p",[e._v("You can implement your own iterable objects by defining a "),a("a",{attrs:{href:""}},[e._v("Symbol.iterator")]),e._v(" method that returns an object with a next() method that returns iteration result objects. You can also implement functions that accept iterator arguments and return iterator values.")]),e._v(" "),a("p",[e._v("Generator functions (functions defined with function* instead of function) are another way to define iterators.")]),e._v(" "),a("p",[e._v("When you invoke a generator function, the body of the function does not run right away; instead, the return value is an iterable iterator object. Each time the next() method of the iterator is called, another chunk of the generator function runs.")]),e._v(" "),a("p",[e._v("Generator functions can use the yield operator to specify the values that are returned by the iterator. Each call to next() causes the generator function to run up to the next yield expression. The value of that yield expression then becomes the value returned by the iterator. When there are no more yield expressions, then the generator function returns, and the iteration is complete.")])])}),[],!1,null,null,null);t.default=n.exports}}]);